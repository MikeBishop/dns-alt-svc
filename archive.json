{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2022-01-06T00:26:17.862262+00:00",
  "repo": "MikeBishop/dns-alt-svc",
  "labels": [
    {
      "name": "bug",
      "description": null,
      "color": "ee0701"
    },
    {
      "name": "duplicate",
      "description": null,
      "color": "cccccc"
    },
    {
      "name": "enhancement",
      "description": null,
      "color": "84b6eb"
    },
    {
      "name": "help wanted",
      "description": null,
      "color": "33aa3f"
    },
    {
      "name": "good first issue",
      "description": null,
      "color": "7057ff"
    },
    {
      "name": "invalid",
      "description": null,
      "color": "e6e6e6"
    },
    {
      "name": "question",
      "description": null,
      "color": "cc317c"
    },
    {
      "name": "wontfix",
      "description": null,
      "color": "ffffff"
    },
    {
      "name": "wg",
      "description": "This should be considered by the working group",
      "color": "b60205"
    },
    {
      "name": "editorial",
      "description": "",
      "color": "4af7a6"
    },
    {
      "name": "proposed to close",
      "description": "Pending feedback prior to closing out",
      "color": "b3f22b"
    },
    {
      "name": "future draft",
      "description": "",
      "color": "bcff82"
    }
  ],
  "issues": [
    {
      "number": 23,
      "id": "MDU6SXNzdWU0NjE2MTUyNzM=",
      "title": "HTTPSSVC: Switch to null-delimited SvcDomainName",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/23",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "Right now SvcDomainName appears to be in presentation format (i.e. dot-delimited), which is inconvenient for recursive operators.  We should switch it to the usual DNS name encoding (but still uncompressed).",
      "createdAt": "2019-06-27T16:00:34Z",
      "updatedAt": "2019-06-28T01:05:41Z",
      "closedAt": "2019-06-28T01:05:41Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Merged PR  (which had a conflict so hopefully I didn't break things).",
          "createdAt": "2019-06-28T01:05:39Z",
          "updatedAt": "2019-06-28T01:05:39Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "MDU6SXNzdWU0NjE2NTY3NzM=",
      "title": "HTTPSSVC: Move \"pri\" out of the SvcFieldValue",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/24",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "It seems like it would be useful for DNS clients to be able to process the priority field directly, without having to gain Alt-Svc parsing capability.  Conversely, \"pri\" is not needed in Alt-Svc, where values are considered to be ordered already.  Therefore, we should consider a fourth value (`SvcFieldPriority`?) in the RR, present only when `SvcRecordType` is 1.",
      "createdAt": "2019-06-27T17:30:15Z",
      "updatedAt": "2019-06-28T00:58:48Z",
      "closedAt": "2019-06-28T00:58:48Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "That seems like a reasonable way to adapt this to DNS.",
          "createdAt": "2019-06-27T18:36:58Z",
          "updatedAt": "2019-06-27T18:36:58Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Makes sense.  Merged PR.",
          "createdAt": "2019-06-28T00:58:48Z",
          "updatedAt": "2019-06-28T00:58:48Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWU0NjM5MjkwNzk=",
      "title": "Remove ambiguities/redundancies in encoding",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/32",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From Ilari Liusvaara <ilariliusvaara@welho.com> \r\n\r\n- What if SvcDomainName has length different from its length field?\r\n  DNS wire-form names are self-delimiting (DNS message parsing relies\r\n  on this).\r\n- What does it mean for SvcDomainName to be absent in alternative\r\n  service form? I would guess it means \"same as RRNAME\".\r\n- Why there is length field for SvcFieldValue? Why not let it run to\r\n  the end of record?\r\n- 2 byte length field can encode values up to 65535, not 65536.\r\n  And the length of SvcFieldValue can not be that big, because\r\n  RRDATA and DNS message length limits (both 65535) would be hit.",
      "createdAt": "2019-07-03T20:00:45Z",
      "updatedAt": "2019-07-08T21:02:19Z",
      "closedAt": "2019-07-08T21:02:19Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Using the empty label (\".\") to specify an absent in alternative service form which means \"same as RRName\" would address both of the first two items.",
          "createdAt": "2019-07-03T20:33:51Z",
          "updatedAt": "2019-07-03T20:33:51Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "But what if the root wants to serve QUIC?  OK, that seems unlikely, but technically it does seem like squatting on their name.  I'm not sure what the formalities of that are.  (I wonder if Let's Encrypt would issue a cert for \".\"...)\r\n\r\nThinking about the text representation, the clearest way I can think of to indicate an omitted uri-host is to write the SvcDomainName as \"*\".  I'm not sure what that suggests for the RR serialization though.",
          "createdAt": "2019-07-03T20:40:56Z",
          "updatedAt": "2019-07-03T20:40:56Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "It looks like SRV and MX use \".\" to mean \"no service available\".  (See RFC 2782.)\r\n\r\nWould \"\"  be better to mean \"same as RRNAME\"?  Or does that mean \"same as hostname\"?\r\n",
          "createdAt": "2019-07-05T12:42:36Z",
          "updatedAt": "2019-07-05T12:42:36Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems like some special cases for SvcDomainName to cover for SvcRecordType=1:\r\n\r\n* How to indicate it should be equivalent to the RRNAME?\r\n* How to indicate it should be equivalent to the hostname?\r\n* What happens if it has the value \".\"?  SRV and MX have this\r\n  mean \"no service available.\r\n",
          "createdAt": "2019-07-05T12:47:48Z",
          "updatedAt": "2019-07-05T12:47:48Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Released in -02.",
          "createdAt": "2019-07-08T21:02:19Z",
          "updatedAt": "2019-07-08T21:02:19Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWU0NjM5MzAwNzc=",
      "title": "HTTPSSVC: Be more clear on chaining behaviors",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/34",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From Ilari Liusvaara <ilariliusvaara@welho.com> \r\n\r\n\r\n- Is there any envisioned use for chained HTTPSSVC records, except\r\n  for type 0 record pointing to type 1 record?\r\n- The MUST requirement to have only one type 0 record and then\r\n  SHOULD behave non-deterministically if this is violated is pretty\r\n  odd.",
      "createdAt": "2019-07-03T20:03:36Z",
      "updatedAt": "2019-11-04T16:40:45Z",
      "closedAt": "2019-11-04T16:40:45Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "See also #57.\r\n\r\n> MUST requirement to have only one type 0 record\r\n\r\nI think this has already been reduced to SHOULD.",
          "createdAt": "2019-09-27T21:18:21Z",
          "updatedAt": "2019-09-27T21:18:21Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Moving discussion to #57.",
          "createdAt": "2019-11-04T16:40:44Z",
          "updatedAt": "2019-11-04T16:40:44Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWU0NjU0Mzc2NTM=",
      "title": "Tracking through Alt SVC lifetimes",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/39",
      "state": "CLOSED",
      "author": "pes10k",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Similar to how HSTS super cookies are used to track users, I think the Alt SVC lifetime instructions could be used to create implicit long term identifiers for users.  \r\n\r\nB/c of local DNS caching, its unlikely that popular (e.g. Apple) protections for HSTS cookies could be applied here (since the context of the DNS request would be lost, there'd be no sense of 1p / 3p requests).\r\n\r\nI'm not sure how this issue could be addressed given then proposal, but would be happy to think through one.  This is less a problem with the existing markup / header ALT-SVC options, since the browser can control the life time of those.",
      "createdAt": "2019-07-08T20:09:27Z",
      "updatedAt": "2019-12-13T18:44:11Z",
      "closedAt": "2019-12-13T18:44:11Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "It sounds like you're concerned about DNS-based tracking that can identify a user whose IP address has changed.  This is a concern, but it's already present with standard A records.  You can see an implementation of this kind of supercookie at http://dnscookie.com/.\r\n\r\nThe only solution is for the client to tie its DNS cache to its IP address, so that the cache is cleared when the client's IP address changes.  I don't think HTTPSSVC changes that.",
          "createdAt": "2019-07-08T21:13:36Z",
          "updatedAt": "2019-07-08T21:13:36Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "@bemasc A difference here between the DNS cookie and the tracking enabled here is that I could perform it w/o needing to operate any DNS records, I just need a website.  If I can find enough domains sending ALT-SVC DNS headers, I can make requests to those domains from page, see where frame request ends up (or use something like [Performance Nav API](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceNavigationTiming) or [Resource Timing API](https://www.w3.org/TR/resource-timing-2/), and use that information as a tracking bit. (its also a very handy history leak\u2026)\r\n\r\nGiven enough examples, and varying TTLs, i should be able to uniquely identify users.\r\n\r\nHowever, i think the history leak issue here is more alarming",
          "createdAt": "2019-07-09T17:57:47Z",
          "updatedAt": "2019-07-09T17:57:47Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> see where frame request ends up\r\n\r\nDo you mean the selected server IP address?  I don't understand the proposed attack.  I don't see why the connection destination would be highly variable, and I don't see how the webpage would learn this IP address (which is not exposed to javascript).",
          "createdAt": "2019-07-09T19:02:35Z",
          "updatedAt": "2019-07-09T19:02:35Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "The IP address is not learned.  Whether or not the user has visited a domain previously can probably be teased out (If I understand the proposal correctly).\r\n\r\n1) Domain sets up DNS ALTSVC instruction with non-zero lifetime\r\n2) Website includes a resource from that domain on its site\r\n3) Website looks at the [nextHopProtocol](https://www.w3.org/TR/resource-timing-2/#dom-performanceresourcetiming-nexthopprotocol) from the Resource Timing API.  If it request goes to the ALTSVC end point immediately, the user very likely has visited that page before.  If the request goes HTTP -> ALTSVC end point, the user def has not visited that page before",
          "createdAt": "2019-07-09T19:48:23Z",
          "updatedAt": "2019-07-09T19:48:23Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the explanation.  I wasn't aware of nextHopProtocol.\r\n\r\nI think you are describing the status quo with Alt-Svc, regardless of these DNS-related proposals.  Additionally, the Resource Timing API is guarded by CORS headers (opt-in for each destination domain), and the proposed test is \"destructive\": after the test is complete, all the tested domains are in-cache, and the tracking information is destroyed.\r\n\r\nIf there is a privacy concern here, I don't think it is specific to the drafts in this repository.",
          "createdAt": "2019-07-09T20:09:20Z",
          "updatedAt": "2019-07-09T20:09:20Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "Yep, Alt-SVC in general has this issue, its not specific to DNS for sure.  But:\r\n\r\n1) Its also present in the DNS proposal, so seems important do deal with here before further entrenching Alt-SVC w/o a solution :)\r\n2) Alt-SVC in HTTP headers and markup can be (usually) dealt with in browser privacy tools (Brave is deploying protections, but extensions could also hook into this functionality to protect users).  Browser privacy tools wouldn't have the option of protecting browser users if the info is moved to DNS\r\n3) re CORS-opt in: unfortunately, if there is any lesson from web privacy, its that you can't expect websites to be good at protecting / opt-ing into user privacy (in general), it needs to be something the client / user stack mandates; I don't think CORS is a solution here\r\n4) Thats true for the lifetime of the instruction, sure, but leaking browsing history once per DNS record lifetime is bad!",
          "createdAt": "2019-07-09T23:25:59Z",
          "updatedAt": "2019-07-09T23:25:59Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> Browser privacy tools wouldn't have the option of protecting browser users if the info is moved to DNS\r\n\r\nHTTPSSVC cannot be handled by the operating system; it has to be handled by the browser.  I don't know how this would interact with current extension APIs in different browsers, but there's nothing preventing a browser from exposing custom behavior controls for HTTPSSVC.\r\n\r\n> you can't expect websites to be good at protecting / opt-ing into user privacy\r\n\r\nTo be clear, origins have to _add_ a special `Timing-Allow-Origin` header to specify which other origins are permitted to measure their timing.  By default, the Resource Timing API is same-origin only.  I think the odds of an origin accidentally enabling cross-origin resource timing seems very low.",
          "createdAt": "2019-07-10T14:34:41Z",
          "updatedAt": "2019-07-10T14:34:41Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "@bemasc apologies for this dropping off\r\n\r\nPoint taken on the above. I take your point that `Resource Timing API` not being the most likely way of leveraging this.  The main concern is just that the standard allows a site owner / DNS record controller to get the browser to store persistent information that pages can access (indirectly), but which is not (mostly?) w/in the realm of attacks privacy folks are considering.\r\n\r\nWhat are your thoughts on where / if it makes sense to make changes to the standard (or privacy considerations style text) to either alert privacy-oriented implementors of the new attack surface and or reduce it? (i dont have compelling ideas at the moment, saddly)",
          "createdAt": "2019-07-26T22:15:19Z",
          "updatedAt": "2019-07-26T22:15:19Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I think your first step should be to lay out a clear and plausible attack, and ideally put up a demo.  Alt-Svc (and HTTPSSVC) are designed with this class of attacks in mind, and designed with the belief that no such attacks are in fact possible.  If you can demonstrate an attack, I expect the IETF will act forcefully to fix the problem.\r\n\r\nYou're right that we need to be careful with client-side caching, but HTTP has cookies precisely to allow persistent client identification, along with rules about exactly how to ensure that state is managed appropriately.  These documents are both designed to follow those rules, and thereby avoid introducing privacy problems.",
          "createdAt": "2019-07-27T00:15:33Z",
          "updatedAt": "2019-07-27T00:15:33Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "Alt-Svc provides a couple of different levers here:\r\n\r\n- The `persist=` option indicates whether an entry should be flushed on address change.  Obviously, this is intended to indicate whether the alternative is being recommended because of location (this node is closer to you!) or because of capability (all IPs behind this hostname speak HTTP/3), but an attacker trying to track you wouldn't tell you to flush proactively.\r\n- The Alt-Svc cache is supposed to be flushed whenever cookies are cleared.  This implies that any Cookie partitioning strategy (as Brave is doing) should also partition Alt-Svc records.\r\n\r\nHowever, when Cookies are cleared, I don't believe browsers also force a flush of the OS DNS cache.  This is particularly relevant when the cache contains HTTPSSVC records, since such cached records could reintroduce an Alt-Svc entry the user intended to clear.\r\n\r\nIt almost seems like we want the records to be short-lived, but the Alt-Svc records they contain to live longer.  Or just use short-lifetime HTTPSSVC records, and provide a longer Alt-Svc entry over HTTPS once the connection is made.",
          "createdAt": "2019-08-14T17:50:07Z",
          "updatedAt": "2019-08-14T17:50:07Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWU0NjU1MjQ4MDk=",
      "title": "HTTPSSVC: Comments from Brian Dickson",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/40",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "One minor issue is that wherever CNAME is referenced, you probably want to also include a reference to DNAME, including any implied or explicit chaining of CNAMEs (which could be sequences of CNAME and/or DNAME modulo their respective behavior.)\r\n\r\nYou might also want to explain the motivation for keeping the FQDN separate from the alt-svc parameters (to make it trivial to parse, and thus to do DNS substitutions like CNAME/DNAME). It is there, just not as up-front as it could be.\r\n\r\n\r\nIt might be a little clearer if the list of alt-svc values (h2, h3, etc) that can occur were to be listed in the document. In particular, the association between h3 and QUIC is inferred but not explicitly called out (at least not that I noticed.)\r\n",
      "createdAt": "2019-07-09T01:24:04Z",
      "updatedAt": "2019-12-13T18:44:56Z",
      "closedAt": "2019-12-13T18:44:56Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "These are not yet addressed in the proposed draft-nygren-dnsop-svcb-httpssvc-00.\r\nWe should include in the next version.",
          "createdAt": "2019-09-23T21:30:34Z",
          "updatedAt": "2019-09-23T21:30:34Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> It might be a little clearer if the list of alt-svc values (h2, h3, etc) that can occur were to be listed in the document.\r\n\r\nThe values are in an IANA registry, and I don't think the \"alpn\" SVCB parameter is intended to be restricted to a subset of those values.  However, it is true that only some of those values make sense in the context of HTTPSSVC, and their meaning is indeed nontrivial.  I don't think we could enumerate them in the text in any permanent way, but I suppose we could explain the present state of affairs more explicitly.",
          "createdAt": "2019-11-08T16:35:53Z",
          "updatedAt": "2019-11-08T16:35:53Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWU0NjU3NTQ2NjQ=",
      "title": "HTTPSSVC: Feedback from Mark Andrews ",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/41",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From Mark Andrews:\r\n\r\n================================\r\n\r\nIntroductory Example: The example record\r\n\r\nexample.com.      2H  IN HTTPSSVC 0 0 svc.example.net.\r\n\r\ndoes not match the description of the record (missing last field). It should be:\r\n\r\nexample.com.      7200  IN HTTPSSVC 0 0 svc.example.net. \u201c\u201d\r\n\r\nSimilarly in 2.4.  HTTPSSVC records: alias form\r\n\r\nAlso don\u2019t use 2H for the TTL.  While some servers will accept it, it is not RFC compliant.\r\n\r\nUnless these is a real reason for the record to be class agnostic please specify that\r\nit is class IN specific.",
      "createdAt": "2019-07-09T12:32:54Z",
      "updatedAt": "2019-11-04T21:31:07Z",
      "closedAt": "2019-11-04T21:31:07Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "All of these should be addressed now except for \r\nthis not being class-agnostic.  That is proposed in PR: \r\n   https://github.com/MikeBishop/dns-alt-svc/pull/54",
          "createdAt": "2019-09-23T21:29:20Z",
          "updatedAt": "2019-09-23T21:29:20Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU0NjU3NTY4NzI=",
      "title": "HTTPSSVC: Security considerations: add note that unauthenticated",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/42",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We should add a note to Security Considerations indicating that HTTPSSVC is unauthenticated in many cases (ie, unless DNSSEC is present and verified) and thus care should be taken around Alt-Svc parameters that imply trust.\r\n\r\nI wonder if we should be explicit to say that Alt-Svc parameters must opt-in to indicate that they can be used in HTTPSSVC?  (As even with \"ma\" we've had to define constraints.)\r\n\r\n",
      "createdAt": "2019-07-09T12:37:48Z",
      "updatedAt": "2019-11-04T21:32:28Z",
      "closedAt": "2019-11-04T21:32:28Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is now addressed pretty clearly: \"Alt-Svc parameters that cannot be safely received in this model MUST NOT have a corresponding defined SvcParamKey.\"",
          "createdAt": "2019-11-04T21:32:28Z",
          "updatedAt": "2019-11-04T21:32:28Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "MDU6SXNzdWU0NzE3NzQ4NjU=",
      "title": "HTTPSSVC: make more generic?  and change record name?",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/44",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "A question from the DNSOP WG discussion is whether to make this record somewhat more generic, inclduing whether to change the record name.  Some options:\r\n\r\n0. Leave as-is and clarify that HTTPS is not just about web browsers.\r\n\r\n1.  Rename to ALTSVC.  Keep default behavior for https:// and http:// but clarify that _$label use-cases can be used more generically for other protocols.\r\n\r\n2. Make even more generic  (SRVBIS?  SRV2?).  Define that format of the SvcFieldValue is specific to the protocol/scheme.  (ie, might be Alt-Svc for HTTPS.)   \r\n\r\n3. Define a generic format with SvcFieldValue being specific to protocol/scheme. But then define a set of RRTYPES that are specific instantiations of this generic format.  For example: HTTPSSVC as an instantiation for HTTPS with Alt-Svc in SvcFieldFalue.  SRV2 as something purely generic.  NS2 for handling secure delegations to DoH/DoT authorities with specification of protocols, ESNIKEYS, ports, etc, in some format of SvcFieldValue.  \r\n\r\n",
      "createdAt": "2019-07-23T15:45:08Z",
      "updatedAt": "2019-09-23T21:21:25Z",
      "closedAt": "2019-09-23T21:21:25Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "In talking with Tommy Pauly (@tfpauly) and he was leaning towards 1 (ALTSVC).\r\nIf we also use this for recursive-to-authoritative DNS then it would want a separate RRTYPE (eg, NS2).",
          "createdAt": "2019-07-25T17:47:23Z",
          "updatedAt": "2019-07-25T18:09:51Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 for option 1.\r\n\r\nI'm definitely also eager to get an RRTYPE (like NS2) to point to the authoritative DoH server, in a way that clients can use to discover available trusted DoH servers for given domains. I would also want to the ability for the content to carry a set of keys that can be used with the DoH server (for both ESNI and allowing further encryption of inner queries for obfuscation).",
          "createdAt": "2019-07-26T14:07:37Z",
          "updatedAt": "2019-07-26T14:07:37Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's a cut at something like option 3, or maybe even more generic:\r\n\r\nAn _Indirection RRTYPE_ is an RRTYPE whose contents are _either_ (a) an FQDN or (b) a list of QTYPEs.\u00a0 To look up an Indirection RRTYPE, a recursive follows the chain of FQDNs (case a) until it reaches case b.\u00a0 In case b, the authoritative gathers all the listed QTYPEs for the QNAME and returns them (as Additional) along with the Indirection RR.\u00a0 The recursive returns all this to the stub.\r\n\r\nIf the recursive is delinquent, this can (and MUST) all be done by the stub/client.\r\n\r\nHTTPSSVC\u00a0is an Indirection RRTYPE initially intended for use with the A, AAAA, *ESNIKEYS*, and *HTTPSALT* QTYPEs.\r\n- ESNIKEYS is just the ESNIKeys.\r\n- HTTPSALT is the ALPN and port (i.e. `h2=:8002` in a compact encoding)\r\n\r\nRationale:\u00a0\r\n- Avoids adding another key-value layer on top of the DNS itself\r\n- Keeps all info for one endpoint in one name (unlike current draft)\r\n- Implementing any future Indirection RRTYPE (NS2?) is a one-line change to DNS code (just handle it identically to HTTPSSVC).\r\n- Can easily drop support for IPv4\r\n- Can easily add new types of info (just define an RRTYPE and add it to your QTYPE list)\r\n- Still fully equivalent to Alt-Svc\r\n- No base64\r\n\r\nProblems:\r\n- No binding between multiple ESNIKEYS and HTTPSALT\u00a0values in a single name.\u00a0 If h2 and h3 have different ESNIKeys, they have to have different names (as in our draft's example with svc2.example.com and svc3.example.com).\r\n- Zone files could end up with a lot of lines.\r\n- Possible to screw up by listing a QTYPE for a sister record that isn't actually present.\u00a0 This should probably be a parse error when loading the zone, but is there a precedent for multi-entry consistency checking?\r\n- Every future Alt-Svc key also needs a new RRTYPE to be usable in HTTPSSVC.  (On the plus side, keys that aren't safe for use in DNS are unrepresentable.)\r\n- Not clear how this interacts with DNS64.  (Doesn't seem worse than current draft.)\r\n\r\nOpen question: Is there a way to extend the [Unknown RRTYPE](https://tools.ietf.org/html/rfc3597) system to support handling an \"Unknown Indirection RRTYPE\", so further future Indirection RRTYPEs can be handled by future legacy DNS code?",
          "createdAt": "2019-07-27T01:28:51Z",
          "updatedAt": "2019-07-27T01:28:51Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "I worry that the Indirection RRType doesn't solve enough problems (such as service bindings).  It also seems like yet another attempt at the multi-query style approach of which there have been a huge number of failed drafts.",
          "createdAt": "2019-08-01T20:49:48Z",
          "updatedAt": "2019-08-01T20:49:48Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "What I'd been thinking of for option 2/3 (although option 1 may just be safer/simpler and good enough):\r\n\r\n* Generalize the HTTPSSVC record as something like \"B\" (or \"SRV2\") and remove the HTTPS-specific semantics from the doc.  Specify that other documents may create service-specific instantiations with their own RRtypes.  Protocols/services without special needs and willing to use SRV-style attribute leaf labels could also just use \"B\" directly. \r\n\r\n* In a separate draft define the \"HTTPS\" RRtype as an instantiation of \"B\" and define the HTTPS-specific semantics and behaviors, such as the mapping to AltSvc.  (A similar separate draft could also define \"NS2\".)  Separate RRTypes are really only needed when differentiation between services is needed on a name without attribute leaf labels.\r\n* How to handle the SvcFieldValue key=value pairs is one of the biggest open questions for me:\r\n    * The simple model would be to leave this as plain text and leave it up to application/service protocol bindings to define meanings.  HTTPS could then continue to use the Alt-Svc format.\r\n    * A much more ambitious approach would be to define the key=value pairs in a much structured way (perhaps but with a mapping for HTTPS over to Alt-Svc format in that separate draft).  This could allow for a few types of values (and I'm not sure what the right set of these is):  strings;  binary blobs (eg, for keys);  inlined RRDATA; references over to other {RRNames/RRTypes}.  This could become especially powerful if done right by allowing something like an ESNI key to either be literally included in the SvcFieldValue, or to be the name of another record (with a different TTL) containing the ESNI key, for example.  This could also support inlining AAAA/A records into a SvcFieldValue value element, perhaps.  This pushes even more complexity into clients, perhaps.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2019-08-01T20:51:55Z",
          "updatedAt": "2019-08-01T20:51:55Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "NONE",
          "body": "I think we need to make the decision on your approval speed.  Doing something more generic will definitely slow down DNSOP as they debate minutia, and perhaps spending all goodwill.   ",
          "createdAt": "2019-08-02T20:01:59Z",
          "updatedAt": "2019-08-02T20:01:59Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": ">   * The simple model would be to leave this as plain text and leave it up to application/service protocol bindings to define meanings.  HTTPS could then continue to use the Alt-Svc format.\r\n>   * A much more ambitious approach would be to define the key=value pairs in a much structured way\r\n\r\nAs an intermediate option, I propose a binary type-length-value store (16-bit keys and lengths).  Type codes are controlled by a new IANA registry.  Data format is type-dependent.\r\n\r\nHTTPSSVC (and NS2, etc.) would share the global IANA type code registry, adding type codes for port, ALPN, and ESNIKeys (which are all we need right now).  Some type codes (like port, ESNIKeys) are likely to be useful in multiple RRTYPEs, while others (like ALPN) are likely to be exclusive to a single RRTYPE.\r\n\r\nHTTPSSVC's zone-file representation remains unchanged.  SRV2/B also has a host file representation that doesn't require parsing the TLV data, and HTTPSSVC can be represented in this form if the implementation doesn't recognize one of the keys.\r\n\r\nWhat do you think?",
          "createdAt": "2019-08-05T22:18:32Z",
          "updatedAt": "2019-08-05T22:18:32Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "I have a first pass at doing a proposed generalization on this branch:\r\n\r\nhttps://github.com/MikeBishop/dns-alt-svc/blob/enygren-svcb-generalization-1/draft-nygren-httpbis-httpssvc.md\r\n\r\nIt does something roughly equivalent to what @bemasc proposes in the previous comment.  It has a SVCB record (name is a placeholder) that is general with an IANA parameter key registry (with 16-bit key values).  It separates out HTTPS and Alt-Svc into a dedicated section of the document where it specifies HTTPS-specific behaviors as well as the mapping from SVCB RRs to Alt-Svc values.\r\n\r\n",
          "createdAt": "2019-08-09T22:34:45Z",
          "updatedAt": "2019-08-09T22:34:45Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Included in the latest draft draft-nygren-dnsop-svcb-httpssvc which will be published shortly.",
          "createdAt": "2019-09-23T21:21:25Z",
          "updatedAt": "2019-09-23T21:21:25Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWU0NzI5MTc4MzI=",
      "title": "HTTPSSVC: clarify behavior when using a proxy",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/45",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Clients using a proxy want special handling.  Rather than simply doing a CONNECT through the proxy to the origin hostname, clients should attempt to resolve HTTPSSVC and then issue the CONNECT to the terminal SvcDomainName (ie, still the same name that a CONNECT for an Alt-Svc  received via a header would have used).\r\n\r\nFor background rfc7838 says:\r\n>    A client configured to use a proxy for a given request SHOULD NOT\r\n>    directly connect to an alternative service for this request, but\r\n>    instead route it through that proxy.\r\n\r\nOne caveat here is that environments requiring a proxy may not allow clients to do DNS resolution.  (Although clients doing HTTPSSVC resolutions via DoH through the proxy may not have this issue.)\r\n\r\nThe proxy case is another good reason/case to NOT inline the address records into the HTTPSSVC record.  (or into an ESNI record)",
      "createdAt": "2019-07-25T15:02:33Z",
      "updatedAt": "2019-09-23T21:20:43Z",
      "closedAt": "2019-09-23T21:20:43Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Gets its own section \"Clients using a Proxy\" in draft-nygren-dnsop-svcb-httpssvc",
          "createdAt": "2019-09-23T21:20:43Z",
          "updatedAt": "2019-09-23T21:20:43Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "MDU6SXNzdWU0NzI5OTIxOTQ=",
      "title": "HTTPSSVC: make SvcRecordType implicit?",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/46",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "One suggestion in DNSOP was to make the SvcRecordType implicit.\r\nFor example, remove the field and distinguish between the two forms by\r\nwhether the SvcRecordValue is empty or not.",
      "createdAt": "2019-07-25T17:48:35Z",
      "updatedAt": "2019-09-23T21:19:45Z",
      "closedAt": "2019-09-23T21:19:45Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "This is included in the first pass of generalizing:\r\n\r\nhttps://github.com/MikeBishop/dns-alt-svc/blob/enygren-svcb-generalization-1/draft-nygren-httpbis-httpssvc.md",
          "createdAt": "2019-08-09T22:31:08Z",
          "updatedAt": "2019-08-09T22:31:08Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Incorporated into the latest draft (draft-nygren-dnsop-svcb-httpssvc).",
          "createdAt": "2019-09-23T21:19:45Z",
          "updatedAt": "2019-09-23T21:19:45Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWU0ODA4NzAwMTU=",
      "title": "HTTPSSVC: incorporate comments from discussion on 2019-08-14",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/47",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Concrete changes to make based on todays' discussion with Mike, Erik, Tommy, Chris, Ben, and Tim:\r\n\r\n- Have one draft defining two rrtypes, making it easier to keep it all in DNSOP.\r\n- Define a separate HTTPSSVC RRTYPE in the draft\r\n\r\n- Add a separate draft that adds an optional A/AAAA stapling parameter (and altsvc parameter).\r\n    - Having this be a generic \"rrdata\" parameter is cute, but might add more problems.\r\n\r\n- Keep using expert review for the key type registry.  (No changes needed.)\r\n- Clarify that recursives should be able to treat key types as opaque.\r\n\r\n- Remove the \"esnikeysref\".  (But perhaps move it back to an issue.)   Helpful for separating operational management, but pull this out for now.\r\n    - Having an authoritative feature for copying this into place might be cute down-the-road but not needed here.\r\n\r\n- Remove general parameter type specifications.\r\n\r\n- Ben: remove the \"can ignore\" optimization.  (That Ben added in)\r\n\r\n- Bike shed: what to name the records.   Keep with them for now, and get consensus later on what to rename them with.\r\n  - SVCB            (later to ???)\r\n  - HTTPSSVC   (later to HTTPS or SVCHTTPS ?)\r\n\r\n- For delimiters between parameters and their encoding:\r\n  - Just leave delimiter as space.  \r\n  - Copy over or reference string quoting from TXT record RFC (or some similar but more recent RFC)\r\n",
      "createdAt": "2019-08-14T20:20:46Z",
      "updatedAt": "2019-09-23T21:19:28Z",
      "closedAt": "2019-09-23T21:19:28Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Most of this is now on this branch:\r\n\r\nhttps://github.com/MikeBishop/dns-alt-svc/blob/enygren-svcb-generalization-1/draft-nygren-dnsop-svcb-httpssvc.md",
          "createdAt": "2019-08-19T22:00:08Z",
          "updatedAt": "2019-08-19T22:00:08Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Incorporated into the latest draft (draft-nygren-dnsop-svcb-httpssvc).",
          "createdAt": "2019-09-23T21:19:28Z",
          "updatedAt": "2019-09-23T21:19:28Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "MDU6SXNzdWU0ODI1Mzg5NTI=",
      "title": "HTTPSSVC: reintroduce esnikeysref?",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/48",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'm pulling esnikeysref out of the existing version.  \r\nThis also allows DNS servers to treat the Params as opaque which I've added a SHOULD regarding.\r\n\r\nThe removed text is here in-case we wish to re-insert it:\r\n\r\n## in {#resolution}\r\n\r\n* If the selected alternative service\r\n   has parameters which reference other names (such as \"esnikeysref\")\r\n   the client will also need to resolve those prior to making a connection.\r\n\r\n## In DNS Server Behaviors:\r\n\r\nFor ServiceForm, recursive DNS servers\r\nMAY also include names referenced by SvcParamValue (such\r\nas \"esnikeysref\") when those records are available and fit\r\nwithin the response.\r\n\r\nFor ServiceForm, authoritative DNS\r\nservers MAY also include in-bailiwick names referenced by\r\nSvcParamValue (such as \"esnikeysref\").\r\n\r\n\r\n### External references to esnikeys\r\n\r\nA SVCB parameter \"esnikeysref\" is also defined for specifying a\r\nreference to ESNI keys.  This allows for both separation\r\nof ESNI keys operational management as well as allows\r\nESNI keys to be cached with a longer TTL than the\r\nSVCB record.\r\n\r\nThe value is a domain name which references a TXT RRSet containing\r\nexactly one RR with a base64-encoded ESNIKeys structure.\r\n\r\nThe presentation format of the SvcParamValue is a fully qualified\r\ndomain name.  The wire format of the SvcParamValue is the domain name\r\nrepresented as a sequence of length-prefixed labels as in Section 3.1\r\nof {{!RFC1035}}.\r\n\r\nTo translate this parameter to Alt-Svc, an \"esnikeys\"\r\nparameter should be generated with the contents of the \r\nTXT record pointed to by the domain name in the SvcParamValue.\r\n\r\nIf both \"esnikeys\" and \"esnikeysref\" parameters are specified in a\r\nSVCB RR, the \"esnikeysref\" parameter MUST be ignored.\r\n\r\n\r\nTODO: what happens if the TTL of the esnikeysref target is *shorter*\r\nthan that of the SVCB record?  Requiring replacement adds lots\r\nof complexity.  Perhaps a SHOULD on relative TTLs with a warning\r\nthat clients may not reconstruct the Alt-Svc?\r\n\r\nTODO: add logic on failure handling, perhaps also on when\r\nto wait, as well as on prefering entries with literal \"esnikeys\"\r\nwhen no \"esnikeysref\" value is in the DNS cache.\r\n\r\nTODO: does this add to much complexity?  This is in this draft to\r\nexpore the viability of external references since some people seemed\r\ninterested.\r\n\r\n\r\n\r\n",
      "createdAt": "2019-08-19T21:33:17Z",
      "updatedAt": "2019-08-19T21:51:46Z",
      "closedAt": "2019-08-19T21:51:46Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as WONTFIX for the moment.",
          "createdAt": "2019-08-19T21:51:45Z",
          "updatedAt": "2019-08-19T21:51:45Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "MDU6SXNzdWU0ODI1NDU4MDI=",
      "title": "HTTPSSVC: define \"ips\" SvcParamKey",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/49",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Define a way to include/inline a list of A and AAAA values to optimize for when SvcDomainName has not yet been resolved.  \r\n\r\nThe current proposal is to create a separate draft for this purpose defining an \"ips\" SvcParamKey that can be used as a hint while waiting on SvcDomainName.\r\n\r\nThis is likely needed to retain parity with optimizations in the ESNI draft.",
      "createdAt": "2019-08-19T21:52:30Z",
      "updatedAt": "2019-09-23T21:18:15Z",
      "closedAt": "2019-09-23T21:18:15Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Included as ipv4hint and ipv6hint in the latest draft.",
          "createdAt": "2019-09-23T21:18:15Z",
          "updatedAt": "2019-09-23T21:18:15Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "MDU6SXNzdWU0OTc3NjUzNTc=",
      "title": "Clarify RRset preservation with multiple AliasForm records [Bob Harold]",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/55",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The draft currently says that recursives must ignore additional AliasForm records, because only one is allowed.  (Following all aliases in parallel would allow some terrifying exponential blowup.)  We should clarify that recursives should nevertheless forward the entire RRset intact, in order to preserve DNSSEC validity.",
      "createdAt": "2019-09-24T15:32:33Z",
      "updatedAt": "2019-11-04T15:10:32Z",
      "closedAt": "2019-11-04T15:10:32Z",
      "comments": []
    },
    {
      "number": 57,
      "id": "MDU6SXNzdWU0OTg5NTQwMTM=",
      "title": "Consider limiting chain lengths to 1",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/57",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wg"
      ],
      "body": "It's not clear that we have a use case for SVCB chains containing more than one AliasForm record.  The purpose of AliasForm is mostly for aliasing the apex; everything else can pretty much be handled with CNAME (e.g. AliasForm -> CNAME -> CNAME -> SvcForm)\r\n\r\nAt a minimum, limiting the chain length to 1 would seem to reduce the likelihood of a performance footgun.",
      "createdAt": "2019-09-26T15:18:15Z",
      "updatedAt": "2020-05-29T19:41:04Z",
      "closedAt": "2020-05-29T19:41:04Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "I think I'd agree, at least as a SHOULD?  The counter-argument would be that clients will do SVCB lookups on the SvcDomainName of the AliasForm record and if they get back another AliasForm record we could enter ambiguous territory.  (I believe CNAME originally prohibited chaining but it ended up being a common pattern that got used anyways.)",
          "createdAt": "2019-09-26T15:22:49Z",
          "updatedAt": "2019-09-26T15:22:49Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's only ambiguous if we choose to make it ambiguous. I think, in that case, the client ought to reject the record. That way administrators know their config didn't work and get back on the well-lit path.\r\n\r\nI'm not familiar with the history of CNAMEs, but my guess is it was prohibited but clients accepted it anyway? In that case, yeah, the natural result is the prohibition gets dropped. Invariants are only invariants if enforced.",
          "createdAt": "2019-09-26T17:32:45Z",
          "updatedAt": "2019-09-26T17:32:45Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "AliasForm only exists to provide apex aliasing, so I think the question is: can we imagine any need for a chain of aliases where more than one is the apex of its zone.  For example:\r\n\r\n```\r\nfoo.example -> www.foo.example -> cdn.example -> cdn2.example.com -> us-east.cdn2.example.com\r\nAliasForm      CNAME              AliasForm      ServiceForm         AAAA\r\n```\r\n\r\nIn this example, \"cdn.example\" is a vanity alias for \"cdn2.example.com\", but because it's a zone apex, it can't use CNAME.  If the CDN were willing to add a label to the vanity alias, it could use a CNAME instead.  Alternatively, the CDN could place the ServiceForm record there, although that might be inconvenient if \"cdn.example\" is a simple static domain, because the ServiceForm record is highly \"dynamic\" (frequently updated and geo-targeted).\r\n\r\nGiven that CDN apex vanity aliases are currently impossible, I don't think this is a motivating use case, but I would still like to ask the working group before ruling it out.\r\n\r\nEDIT: A more compelling use case might be for zone structure flexibility.  If AliasForm can appear more than once, that makes it easier for CNAME users to add zone cuts that would put the CNAME at an apex, since they can replace the CNAME with an AliasForm without worrying that there might already be an AliasForm earlier in the chain.",
          "createdAt": "2019-11-04T16:57:45Z",
          "updatedAt": "2019-11-04T19:27:54Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "At IETF 106, the consensus of DNSOP seemed to oppose this kind of limit.  Recursive resolver developers explained that applying different limits to SVCB and CNAME would be difficult to implement, and some also declared that domain owners are to be blamed if they choose an inefficient layout of their own zone.  Some declared that, regardless of the spec, they would not enforce any low limit on the number of alias steps in their implementations.\r\n\r\nI think we could still specify that domain owners MUST NOT include more than one alias in a chain, and recursive/client implementors MAY impose limits as low as 1.",
          "createdAt": "2019-11-25T20:21:40Z",
          "updatedAt": "2019-11-25T20:21:40Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "After some further discussion, a new idea: \r\n * domain owners MUST NOT include more than one alias in a chain\r\n * recursive implementors MAY stop following aliases after the first\r\n * client implementors SHOULD stop following aliases after the first\r\n * client implementors SHOULD reject responses from recursive resolvers that contain chains with multiple aliases\r\n\r\nThis gets us reliable, consistent behavior without imposing any extra constraints on the recursive implementor.\r\n\r\nTODO: Figure out what happens when the chain length is exceeded in each case.  Does resolution fail or fall back?  Does HSTS still apply?",
          "createdAt": "2019-12-05T01:57:38Z",
          "updatedAt": "2019-12-05T01:57:38Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That seems reasonable to me. On the HSTS side, you don't actually need to follow anything when resolving an HTTP URL, right? Once you see an HTTPSSVC record of any flavor, you know you're going to abandon this URL and try a different URL. (Of course, that retry is likely going to make the same DNS query---though not necessarily depending on HTTP cache or Alt-Svc---so it's not a waste to follow it anyway.)",
          "createdAt": "2019-12-05T15:31:29Z",
          "updatedAt": "2019-12-05T15:31:29Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "We should remove the \"(8?)\" guidance and instead propose that AliasForm can't point to AliasForm (without imposing any restrictions on CNAMEs before, during, and after).  We'll need to review this with the commenters from the WG.",
          "createdAt": "2019-12-13T18:55:00Z",
          "updatedAt": "2019-12-13T18:55:00Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I brought this proposal to the group in December, but there did not appear to be consensus for a tight limit like this: https://mailarchive.ietf.org/arch/msg/dnsop/Fim9mbPIfSBwBQg-3uU6wwSfmhg/",
          "createdAt": "2020-05-25T02:07:47Z",
          "updatedAt": "2020-05-25T02:07:47Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Please review #151, which relaxes the requirement here in a way that I hope reflects the WG consensus (or lack thereof).",
          "createdAt": "2020-05-25T02:44:47Z",
          "updatedAt": "2020-05-25T02:44:47Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "I wonder if the MUST rules around following at least one link should be changed to a SHOULD since, while it's necessary in the general case to support apex delegation, it seems like you could come up with special-case situations where it would be fine to skip chain following eg looking up specific records where the stub has specific knowledge that there shouldn't be a chain at all.\r\n\r\nBut either way, I think this new language works well for Chrome.",
          "createdAt": "2020-05-26T21:09:27Z",
          "updatedAt": "2020-05-26T21:09:27Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "MDU6SXNzdWU0OTg5NjMyMzg=",
      "title": "Consider removing the in-band Alt-Svc precedence guarantee",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/58",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, in-band Alt-Svc always has precedence over HTTPSSVC, and the presence of a cached Alt-Svc is supposed to disable the HTTPSSVC query altogether.  However, this could be a problem for Chrome.\r\n\r\nChrome currently implements only \"local Alt-Svc\", i.e. Alt-Svc where the origin hostname is empty.  All other Alt-Svc headers are ignored.\r\n\r\nConsider a site hosted in a multi-CDN configuration, using QUIC on both CDNs.  Currently, that site could send a header like `h3=:443`, and Chrome would upgrade to QUIC.\r\n\r\nNow suppose that both CDNs support ESNI.  The site could send additional Alt-Svc headers like `h3=cdn1.example:443; esnikeys=ABC...` and `h3=cdn2.example:443; esnikeys=123...`, but Chrome would ignore both of these, so Chrome users would get QUIC but not ESNI.\r\n\r\nIf some Chrome users can query HTTPSSVC, those users could get the full package for ESNI through the DNS.  However, the presence of `h3=:443` in the Alt-Svc cache would prevent them from even doing the HTTPSSVC query (in the current draft).\r\n\r\nA straightforward solution here would be to declare that the precedence of HTTPSSVC vs. Alt-Svc is implementation-defined.  This might reduce the ability of origins to fine-tune suboptimal HTTPSSVC, but it gives clients more flexibility to do what makes sense for them.",
      "createdAt": "2019-09-26T15:34:12Z",
      "updatedAt": "2019-11-04T21:30:03Z",
      "closedAt": "2019-11-04T21:30:03Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another example of the sort of complex interactions between Alt-Svc and HTTPSSVC: HTTPSSVC's http-to-https upgrade does not have an Alt-Svc analog. That means an existing Alt-Svc entry on an http origin would mask off the upgrade behavior and prevent a client from discovering it.\r\n\r\nAlt-Svc is mostly an https-only thing, so this mostly doesn't matter, though I believe RFC8164 defines an http use. (Although clients [shouldn't implement](https://www.mozilla.org/en-US/security/advisories/mfsa2015-44/) RFC8164 anyway.)\r\n\r\nIn general, any property provided by HTTPSSVC but not Alt-Svc becomes a bit of a pickle.",
          "createdAt": "2019-09-26T16:36:06Z",
          "updatedAt": "2019-09-26T16:36:06Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "@davidben, I think you're incorrect in pointing to that vulnerability as a reason not to implement RFC8164.  Mozilla had a bug, wherein certificate verification could be bypassed.  They fixed it.  That doesn't say anything about the mechanism itself, which continues to require that the certificate be checked.",
          "createdAt": "2019-10-09T14:22:51Z",
          "updatedAt": "2019-10-09T14:22:51Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right, it's possible to implement it correctly. But it's a huge source of complexity risk in a very security-sensitive part of a modern HTTP client, with that Mozilla bug demonstrating that risk. Such a risk needs to be matched by benefit, which I don't believe exists.\r\n\r\nRegardless, that's an aside. RFC8164, not the lack of it, is a reason why the alt-svc/httpssvc interactions are a problem.",
          "createdAt": "2019-10-09T16:57:04Z",
          "updatedAt": "2019-10-09T16:57:21Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "This precedence rule has been removed, replaced by a \"MAY\".",
          "createdAt": "2019-11-04T21:30:03Z",
          "updatedAt": "2019-11-04T21:30:03Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "MDU6SXNzdWU0OTg5NjQzNzU=",
      "title": "Clarify rationale for SVCB/HTTPSSVC split",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/59",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "We've gotten a few questions about why these aren't a single RR type.  The text could be more explicit on the design rationale for this.",
      "createdAt": "2019-09-26T15:36:08Z",
      "updatedAt": "2020-01-14T22:54:29Z",
      "closedAt": "2020-01-14T22:54:29Z",
      "comments": []
    },
    {
      "number": 60,
      "id": "MDU6SXNzdWU0OTg5NjYzMTM=",
      "title": "Reduce emphasis on HTTPSSVC <-> Alt-Svc equivalence",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/60",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Given that conversion between HTTPSSVC and Alt-Svc is now potentially quite lossy (any unmapped or unrecognized keys are dropped) and has unclear security properties, we should probably de-emphasize the idea of converting between them, and focus on their parallel structure instead.",
      "createdAt": "2019-09-26T15:39:28Z",
      "updatedAt": "2019-11-04T15:07:40Z",
      "closedAt": "2019-11-04T15:07:40Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On the unclear security properties front, I'm a little dubious of this text:\r\n\r\n> SVCB/HTTPSSVC RRs and Alt-Svc Field Values are intended for distribution over untrusted channels, and clients are REQUIRED to verify that the alternative service is authoritative for the origin (Section 2.1 of {{!AltSvc}}).\r\n\r\nThe second clause does follow from section 2.1, but I'm not sure the first clause does. Alt-Svc is currently only ever delivered over a connection that is authoritative for the origin. HTTPSSVC is not. For more fun, neither is even strictly more secure than the other, depending on to what extent URLs like https://university.example/~some-student/evil.php are in your threat model.\r\n\r\nThis is somewhat a theoretical issue since HTTPSSVC is appropriate for all the Alt-Svc keys that are currently defined. Perhaps we need to freeze Alt-Svc or be very discerning about how to define it going forwards. There's already been some confusion in the security models in https://github.com/httpwg/http-extensions/pull/866.\r\n\r\n(Really this reflects flaws in Alt-Svc than anything else. It tries to solve too many problems at once and awkwardness like this and #58 are the result.)",
          "createdAt": "2019-09-26T16:28:03Z",
          "updatedAt": "2019-09-26T16:28:03Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "Alt-Svc is supposed to be delivered over a connection that is a) authorized to speak for the origin (either the origin itself or a duly appointed alternative), and b) at least as secure as the origin.  For an https:// origin, that means it came over TLS; for an http:// origin, it's fine if it didn't.\r\n\r\nHowever, if you can control the origin's DNS records and possess a certificate for the origin, you're as authorized to speak for the origin as it gets, in practice.  I think to achieve the second requirement, you probably do want guarantees that it wasn't modified in transit -- at least DoT/DoH (because the DNS server and anything upstream of it could have subverted DNS anyway), but even better if you have DNSsec.",
          "createdAt": "2019-10-09T14:20:49Z",
          "updatedAt": "2019-10-09T14:20:49Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "DoT/DoH does not give you the second requirement because the resolver does not have a certificate. That's exactly the unclear security property.",
          "createdAt": "2019-10-09T16:54:07Z",
          "updatedAt": "2019-10-09T16:54:07Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "RFC 8484 says that the resolver's identity is validated per RFC2818, i.e. with a cert, so you do have some authentication of the resolver -- but no proof of any relationship to the site.  A cursory read of DoT suggests that the client at a minimum *need not* check the server's validity, so you're definitely correct there.\r\n\r\nRegardless, this seems to all circle back to the question of whether DNS is a security factor in HTTP.  If a DNS entry has come from an unauthenticated source, but the certificate is valid -- is that sufficient?  What if the DNS entry was DNSsec-signed?\r\n\r\nThere has been fairly strong consensus that holding the relevant certificate is enough proof of authority, DNS notwithstanding.  I happen to think that consensus is somewhat misguided, but it's at least consistent.",
          "createdAt": "2019-10-11T19:03:43Z",
          "updatedAt": "2019-10-11T19:04:54Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "My conclusion from this discussion is that, while nothing in Alt-Svc currently requires secure delivery, the requirements on Alt-Svc delivery security are not actually specified anywhere, so Alt-Svc could theoretically be extended in a way that relies on secure delivery.  I'll update the text to avoid implying otherwise.",
          "createdAt": "2019-10-11T20:11:48Z",
          "updatedAt": "2019-10-11T20:11:48Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right, what @bemasc says. @MikeBishop, I think you and I are talking about different things. My comments have nothing to do with the DNS second factor. It's the much more important origin certificate first factor that's missing. While I certainly hope any DoT or DoH client will check the resolver's certificate (otherwise what is the point?), that just strengthens the second factor. It doesn't replace the first factor.",
          "createdAt": "2019-10-11T20:37:19Z",
          "updatedAt": "2019-10-11T20:37:19Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And, to clarify, this isn't a comment on HTTPSSVC in a vacuum. DNS-delivered HTTPSSVC is just fine without that first factor because all fields currently defined there give no more power than the resolver already has. (It can make the site unavailable, or cause information it already has (SNI) to be leaked.)\r\n\r\nThe concern is simply that HTTPSSVC asserts a strong association with Alt-Svc (happily less so now), which is typically delivered in a context that has *both* factors. (With the footnote that, if your threat model includes `users/attacker/evil.php` delivering a bad origin-wide header, Alt-Svc isn't quite strictly stronger.) I'd like to avoid a situation where someone adds an Alt-Svc field which only makes sense in the latter but not the former, such as https://github.com/httpwg/http-extensions/pull/866.",
          "createdAt": "2019-10-11T20:44:12Z",
          "updatedAt": "2019-10-11T20:44:12Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "@davidben, I think I see what you're suggesting.  Does this capture it?\r\n\r\nWhen Alt-Svc is delivered over HTTPS, you have trust -- from the certificate and possibly from the earlier DNS resolution -- that the record was in fact delivered by the origin.  That is, you trust the record itself, and the certificate check on connection is only to verify that the alternative connection hasn't been subverted.\r\n\r\nWith HTTPSSVC, unless you have DNSsec, there are one or more intermediaries who might have changed that record en route, meaning you can't fully trust it.  The certificate check on the declared alternative therefore serves to confirm the authenticity of the record itself, not just the connection to the alternative.\r\n\r\nThis is also true for Alt-Svc delivered over HTTP -- it could have been tampered with in transit, and therefore only the certificate confirms that the Alt-Svc field was legitimate.  An intermediary who could tamper with the Alt-Svc field could also have tampered with the content, but Alt-Svc permits them to persistent that control.  They couldn't otherwise do that, not even controlling the resolver and a certificate for the target.",
          "createdAt": "2019-10-14T18:25:48Z",
          "updatedAt": "2019-10-14T18:26:29Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we're broadly in agreement. Some nitpicks:\r\n\r\n> That is, you trust the [Alt-Svc] record itself, and the certificate check on connection is only to verify that the alternative connection hasn't been subverted.\r\n>\r\n> [...] The certificate check on the [HTTPSSVC-]declared alternative therefore serves to confirm the authenticity of the record itself, not just the connection to the alternative.\r\n\r\nI think your framing uses assumptions from the currently defined Alt-Svc and HTTPSSVC parameters. Both systems are extensible and I don't see any text in Alt-Svc which implies new parameters must account for the possibility of untrusted records, which means treating them equivalent is problematic.\r\n\r\nNote also the certificate check on the HTTPSSVC alternative does *not* confirm authenticity of the record. Maybe one of the parameters not directly involved in verification was bad. Or maybe it was all invalid, but the network directed the invalid alternative name to the real server, in an attempt to get you to believe the rest of the HTTPSSVC record. (This is in the same way certificate checks do not validate the A/AAAA record you used. You can't skip TLS tomorrow assuming the IP was good.)\r\n\r\n> [...] unless you have DNSsec [...]\r\n\r\nThe Web PKI and DNSSEC are different PKIs with different properties, so they're not automatically interchangeable. For better or worse, most HTTPS uses these days are based off the Web PKI, not the DNSSEC PKI. But, yeah, DNSSEC is certainly trying to actually authenticate the record, unlike DoT/DoH.\r\n\r\n> This is also true for Alt-Svc delivered over HTTP -- it could have been tampered with in transit, and therefore only the certificate confirms that the Alt-Svc field was legitimate.\r\n\r\nI not quite sure what this is referring to. You shouldn't be able to deliver an Alt-Svc for https://example.com over http://example.com and the latter has no certificate. (And, per above, the certificate check wouldn't retroactively verify the Alt-Svc record.)\r\n\r\nIs this a reference to our RFC8164 discussion in issue #58? That was about a different (but related) issue: believing Alt-Svc shadows HTTPSSVC means Alt-Svc will shadow any HTTPSSVC-only features, current or future. We already have one HTTPSSVC-only feature: for HTTP origins, HTTPSSVC automatically redirects. Alt-Svc is mostly HTTPS, but RFC8164 defines one for HTTP origins.",
          "createdAt": "2019-10-15T01:24:34Z",
          "updatedAt": "2019-10-15T01:24:34Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "MDU6SXNzdWU0OTkyNjUwMTA=",
      "title": "Semi-colon also needs to be escaped when used in master files.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/61",
      "state": "CLOSED",
      "author": "marka63",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "```\r\n   basic-visible = %x21 / %x23-5B / %x5D-7E ; VCHAR minus DQUOTE and \"\\\"\r\n   escaped-char  = \"\\\" (VCHAR / WSP)\r\n   contiguous    = *(basic-visible / escaped-char)\r\n   quoted-string = DQUOTE *(contiguous / WSP) DQUOTE\r\n   value         = quoted-string / contiguous\r\n   pair          = display-key \"=\" value\r\n```\r\nfails to account for ';' which is the comment leader in master files.",
      "createdAt": "2019-09-27T06:41:12Z",
      "updatedAt": "2019-10-13T02:20:31Z",
      "closedAt": "2019-10-13T02:20:31Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!  Would you also want to require semicolons to be escaped when they are inside a pair of double-quotes?",
          "createdAt": "2019-09-27T11:07:54Z",
          "updatedAt": "2019-09-27T11:07:54Z"
        },
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "No as they are already escaped. \n\n-- \nMark Andrews\n\n> On 27 Sep 2019, at 21:07, Benjamin M. Schwartz <notifications@github.com> wrote:\n> \n> \ufeff\n> Thanks! Would you also want to require semicolons to be escaped when they are inside a pair of double-quotes?\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n",
          "createdAt": "2019-09-29T06:59:51Z",
          "updatedAt": "2019-09-29T06:59:51Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "MDU6SXNzdWU0OTk2MzQzNTI=",
      "title": "Consider switching the SvcDomainName and SvcFieldPriority in presentation format",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/63",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wg"
      ],
      "body": "Currently, the format is `[SvcFieldPriority] [SvcDomainName] [SvcFieldValue]`.  I think it should probably be `[SvcDomainName] [SvcFieldPriority] [SvcFieldValue]`.  Then in AliasForm, the redundant `0` priority can be omitted without making the parser more complex.\r\n\r\nWe could maintain the current wire format, or reverse the order there too.",
      "createdAt": "2019-09-27T20:25:03Z",
      "updatedAt": "2019-11-25T20:23:39Z",
      "closedAt": "2019-11-25T20:23:38Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "The counter-point and why I chose the current ordering is for consistency with SRV, URI, and MX,\r\nboth of which have the priority come before the target domain name.  NAPTR also has order and pref come before other things.  \r\n\r\nIt seems like it could be a usability issue here to have ordering that is less consistent than the precedent set by most other record types.",
          "createdAt": "2019-09-27T20:38:22Z",
          "updatedAt": "2019-09-27T20:38:22Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "(Crazy idea could be for SvcFieldPriority to be a weight in AliasForm.  ie, if multiple are present then clients pick between one based on weight?  Not sure if this is worth complexity.)",
          "createdAt": "2019-09-27T20:39:56Z",
          "updatedAt": "2019-09-27T20:39:56Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think there's any risk of users getting it wrong (you'll get a parse error if you put them in backwards), but I take your point that there is a strong tradition here.  I'd like to poll some implementers and come back to this.",
          "createdAt": "2019-09-27T20:44:19Z",
          "updatedAt": "2019-09-27T20:44:19Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "WG seems to favor the current format",
          "createdAt": "2019-11-25T20:23:38Z",
          "updatedAt": "2019-11-25T20:23:38Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "MDU6SXNzdWU1MTg1ODE0MjQ=",
      "title": "Redesign ALPN mismatch handling",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/73",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [
        "wg"
      ],
      "body": "Currently, if a server publishes a QUIC-only HTTPSSVC RRSet with ESNI, there is no way for a client to fall back to a non-QUIC connection, because doing so would reveal the SNI.  This could increase the likelihood of partial outages for server admins who haven't considered the small fraction of users whose network path does not support QUIC.\r\n\r\nReviewers have reported concerns that this creates an undesirable level of fragility.  We should consider whether there is an alternative design that would be less likely to result in accidental breakage.",
      "createdAt": "2019-11-06T16:23:13Z",
      "updatedAt": "2020-02-14T21:28:51Z",
      "closedAt": "2020-02-14T21:28:51Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "After some thought, I'm leaning towards just declaring that if an \"h3\" attempt fails you should (may?) fall back to \"h2\" with the rest of the parameters unchanged.  That's a hack, and it won't always work (e.g. when H3 and H2 aren't colocated), but it avoids the \"footgun\" where an ordinary H3+H2 server becomes QUIC-only due to a server admin publishing an H3-only HTTPSSVC RRSet.",
          "createdAt": "2019-11-18T10:32:51Z",
          "updatedAt": "2019-11-18T10:32:51Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I've just learned of another closely related case: HTTP/1.1-only clients.  Just like an HTTP/2 client can't use an RR that has `alpn=h3`, an HTTP/1.1-only client can't use an RR that has `alpn=h2`.  This seems like a common mistake that people might make, but there are significant use cases for HTTP/1.1 with HTTPSSVC (e.g. WebSocket, which is currently mostly HTTP/1.1-only despite RFC 8441).\r\n\r\nAs with QUIC fallback, this can be handled within the current draft, but it requires any server that uses ESNI to remember to publish RRs for both `alpn=http/1.1` and `alpn=h2` (and `alpn=h3` if they do QUIC) in each RRSet.  Failure to include an `alpn=http/1.1` RR will cause silent loss of ESNI protection for HTTP/1.1 clients, which seems like a footgun.\r\n\r\nWe should think a little bit harder about what the ALPN field means, and whether there's a way to convey the right information (mostly whether this endpoint supports QUIC) in a way that makes misconfiguration harder.",
          "createdAt": "2019-12-04T19:10:28Z",
          "updatedAt": "2019-12-04T19:10:28Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "New plan: `proto` (I promise I support) and `no_proto`* (I don't support so don't bother trying).  For HTTPSSVC, \"http/1.1\" and \"h2\" are in the default set.  Multiple keys are allowed.\r\n\r\nBoth share the ALPN registry.\r\n\r\n*Need to add \"_\" to the allowed characters.",
          "createdAt": "2019-12-13T18:43:40Z",
          "updatedAt": "2019-12-13T18:43:40Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How does this interact with someone adding a new ALPN token that's used out of the TCP + TLS + {http/1.1, h2} entrypoint? What is the mapping to Alt-Svc, given that Alt-Svc got ALPN wrong? How does one handle the HTTPSSVC http/1.1 vs h2 subsetting getting out of sync with the server?\r\n\r\nThe root problem here is we're trying to repurpose ALPN, an in-band mid-connection-establishment variant selector, for out-of-band pre-connection-establishment entrypoint selector. These two objects don't have the same type. Specifying either \"http/1.1\" or \"h2\" in there doesn't make sense. Rather, we should add a name for the TCP + TLS + {any applicable HTTPS variant} stack to stick in there and drop the in-band vs. out-of-band interactions.",
          "createdAt": "2019-12-14T03:56:56Z",
          "updatedAt": "2019-12-14T03:57:26Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "One option may be to share the ALPN registry but be explicit about the differences here.  (ie, require each of the tokens to have a semantic meaning defined here.)\r\n\r\nShould clients only offer (or only accept server offers) of ALPN tokens in the set \"allowed\" by the HTTPSSVC set?  Or is that counter-productive?",
          "createdAt": "2019-12-14T03:59:43Z",
          "updatedAt": "2019-12-14T03:59:43Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Should clients only offer (or only accept server offers) of ALPN tokens in the set \"allowed\" by the HTTPSSVC set? Or is that counter-productive?\r\n\r\nRight, this mess is why Alt-Svc's use of ALPN was wrong. If we say yes here, we break downgrade protection of the protocol negotiation. That's a nonstarter. If we say no here, we have to worry about what happens if the server picks something outside of the set. Alt-Svc says it's an error, which means instead we have a deployment hazard. The PR just says any client behavior is fine. Ambiguity breeds interoperability problems, so that's no good. The spec should say what it means. We can't say anything in the same entrypoint is good because that's not defined. It's also bizarre because that means \"http/1.1\" and \"h2\" are just aliases for the thing we've failed to define.",
          "createdAt": "2019-12-14T04:08:35Z",
          "updatedAt": "2019-12-14T04:10:06Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "That might be a good argument for disconnecting these protocols from ALPN and having a separate registry for them with definitions that are independent of Alt-Svc?  I think what we want is:\r\n* Extensible (ie, can add new protocols down the road)\r\n* Able to have service endpoint support a subset of protocols.  (eg, HTTP/3 using unstable anycast IPs because the connection IDs are big enough to fix up and reforward during route changes, whereas TCP-based H/1.1 and H2 stick somewhere more stable).  Or another use-case is rolling out a new protocol to a subset of endpoints.\r\n* Minimize deployment hazards of all forms.\r\n* Have good downgrade protection (especially given DNS is often unauthenticated)\r\n* ... (maybe some other properties?)",
          "createdAt": "2019-12-14T04:15:06Z",
          "updatedAt": "2019-12-14T04:15:06Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(I meant to do a proper writeup of this issue this week but didn't end up having time. :-( Ah well, discussion on GitHub works.)\r\n\r\nI think separate registry or just overloading the existing one works. Separate is probably cleaner, but allocating new tokens may be easier to wedge back into Alt-Svc. I do want to touch on two of your points though, deployment hazards and downgrade protection. I think these attributes may be somewhat forced by whether the negotiation is in-band or out-of-band.\r\n\r\nALPN, in its original form, is an in-band protocol variant selector. It's negotiated in the TLS handshake, which gives us nice properties:\r\n* Deployment concerns are minimal. A single server can unilaterally reconfigure itself without consequences, so gradual rollout, rollback, etc., is natural.\r\n* Downgrade protection is natural. TLS promises that the protocol you get is the one you should have gotten.\r\n\r\nThis makes this a nice pattern for HTTP/2. We get the above for free. QUIC runs over UDP and can't use this trick. It needs an out-of-band signal, perhaps in an HTTP header (`Alt-Svc`, formerly `Alternate-Protocol`) or the DNS (this draft). Both of these involve some client state (caching, etc.). This has analogous consequences:\r\n* The server's configuration may get out of sync with the client's state. A priori, this means connection failure, so we must handle this. We pair QUIC with a TCP fallback (or run in parallel), which we need anyway due to network intolerance. Corollary: the TCP fallback is critical.\r\n* We do not have natural downgrade protection. An attacker can cause us to negotiate the \"wrong\" one of the two. Indeed we *want* this for network intolerance. Corollary: the QUIC and TCP flows must be capable of comparable security.\r\n\r\nI may be overgeneralizing from these examples, but these two properties seem closely related. Downgrade protection means you selected the thing you were supposed to, but if your selection is based on possibly stale information, it's hard to have downgrade protection. (Unless maybe the server reacts to your stale information and has an in-band fixup operation, in which case the out-of-band signal is more a hint than a selection mechanism.)\r\n\r\nAnyway, I think this framing helps illustrate how different of animals TLS/ALPN and HTTPSSVC/ALPN are.",
          "createdAt": "2019-12-14T04:33:17Z",
          "updatedAt": "2019-12-14T04:35:46Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm OK with replacing \"h2\" with \"tls\" in HTTPSSVC, but I want to point out that this would cause the spec to lean _more_ heavily on clients having a full implementation of fallback.\r\n\r\nConsider a future CDN that drops HTTP/1.1 support for some of its fleet.  In the scheme of PR #89, endpoints without HTTP/1.1 support are clearly marked, so clients that need HTTP/1.1 can identify the relevant endpoints before the connection attempt.  If instead of (h2, h3) the protocol set was (tls, quic), clients would have to attempt the connection before learning that \"http/1.1\" is not supported.\r\n\r\nTo generalize, whenever a client might be compatible with only a subset of endpoints, the client must either be able to tell this from the DNS record or must implement fallback.  The list of ALPNs isn't necessary for enabling the client to attempt a connection to an endpoint, but it is useful to allow clients to avoid attempts that will fail.",
          "createdAt": "2019-12-15T22:18:36Z",
          "updatedAt": "2019-12-15T22:18:36Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think that holds. Rather, I think we stop pretending to support a deployment doing that. If you're ready to drop HTTP/1.1 support (maybe you only care about modern clients), go ahead and drop it. If you're not, your fleet should still support HTTP/1.1.\r\n\r\nYou could make the same set of statements about a server deployment that wants to disable TLS 1.2 on some machines but not others. Or a server deployment that wants a completely different set of TLS cipher suite capabilities on each machine. With unbounded complexity we could express and handle unbounded partial deployments, but that doesn't mean it's a good idea.",
          "createdAt": "2019-12-15T23:05:25Z",
          "updatedAt": "2019-12-15T23:06:14Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "In the eventual world where QUIC has version negotiation and ALPN happens in-band for both TCP and UDP, most of what you really need is an indication of TCP vs. UDP and let TLS take care of the specifics at connection-time.  However, a hint about what is supported can make things faster, especially in the QUIC case.\r\n\r\nThe only case that doesn't cover is when you don't speak any of the protocol variants supported by that endpoint.  The current system lets you discover that without trying a connection.",
          "createdAt": "2019-12-19T16:35:56Z",
          "updatedAt": "2019-12-19T16:35:56Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "An ALPN hint is somewhere between not useful at all and barely useful. I say barely useful because the one-bit \"only HTTP/1.1\" vs \"supports something not HTTP/1.1\" does allow us to avoid opening some connections that we'd otherwise throw away if, say, 10 HTTP requests enter the net stack at once and we've never talked to this server before.\r\n\r\nHowever, if you want an ALPN or QUIC version hint, the needs to be explicit that it is a hint. The key thing about hints is that they are non-binding. They do not impact how an individual connection is negotiated, which is important for both the downgrade protection and deployability aspects above.\r\n\r\nIn contrast, the TCP+TLS vs QUIC indication is not a hint. It fundamentally impacts how an individual connection is negotiated. It does not have the downgrade protection and deployability properties. And if you want to support separate IPs for HTTP/2 and HTTP/3, it cannot be a hint.\r\n\r\nThese two use cases cannot be mixed up. Otherwise we land in exactly this problem. Any solution here *must* split the two apart.",
          "createdAt": "2019-12-19T17:50:09Z",
          "updatedAt": "2019-12-19T17:50:52Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually, here's a stronger reason why having different ALPN tokens on different parts of your fleet is no good. Suppose the CDN wanted to have some h1-only machines and some h2-only machines. Even if I get directed to the right one via HTTPSSVC, the network can redirect my packets to the h1-only machines and I get force down to h1.\r\n\r\nThe security model for multi-instance TLS services has always that we assume all instances of a service are equivalent and downgrade protection is limited to the weakest instance. Due to deployment requirements, instances may have different configurations temporarily, but we assume it eventually converges over time.\r\n\r\nThus these kinds of uneven deployment games are only acceptable in scenarios where we don't care about downgrade protection (TCP vs QUIC) because we met the same needs in other ways (QUIC must be able to meet TCP's security level).",
          "createdAt": "2019-12-19T19:20:42Z",
          "updatedAt": "2019-12-19T19:21:06Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I've opened a new PR to explore a version where we negotiate the transport up front, instead of the ALPN: https://github.com/MikeBishop/dns-alt-svc/pull/97",
          "createdAt": "2019-12-19T20:25:47Z",
          "updatedAt": "2019-12-19T20:25:47Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "MDU6SXNzdWU1MjIzMjkyMTI=",
      "title": "Remove TTL shortening recommendation",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/74",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "The current text recommends shortening the TTL to compensate for misbehaving clients.  This is not a good recommendation, since some clients will just ignore the shorter TTL.  Instead, we should just mention that servers cannot rely on prompt expiration.\r\n\r\nCredit: @puneetsood",
      "createdAt": "2019-11-13T16:23:04Z",
      "updatedAt": "2020-01-15T22:51:41Z",
      "closedAt": "2020-01-15T22:51:41Z",
      "comments": []
    },
    {
      "number": 75,
      "id": "MDU6SXNzdWU1MjIzMzQxMTM=",
      "title": "Clarity improvements",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/75",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "* Disentangle description of recursive and authoritative server behavior in section 4\r\n* Explain why alias and service forms need to share an RR type\r\n* Clarify interaction between CNAME and AliasForm in Section 4\r\n* State clearly that only A and AAAA records will ever need to be added to the response\r\n",
      "createdAt": "2019-11-13T16:31:01Z",
      "updatedAt": "2020-01-15T22:50:12Z",
      "closedAt": "2020-01-15T22:50:12Z",
      "comments": []
    },
    {
      "number": 79,
      "id": "MDU6SXNzdWU1MjI0ODY1NjE=",
      "title": "Clarify behavior when alpn=h2 but origin only supports http/1.1 (and vice-versa)",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/79",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We should clarify the behavior for how alpn=h2 and alpn=http/1.1 interact with ALPN negotiation over TLS with an origin, including in cases where only one is specified in the DNS but where only the other can get negotiated via TLA.\r\n\r\nOne option would be to call this out and recommend that \"h2\" can negotiate to http/1.1 and/or h2 if only one is specified in HTTPSSVC records.",
      "createdAt": "2019-11-13T21:36:04Z",
      "updatedAt": "2019-11-14T18:17:49Z",
      "closedAt": "2019-11-14T18:17:48Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I could see something like \"client MUST include the specified ALPN and SHOULD include any others that it would also support\".\r\n\r\n> in cases where only one is specified in the DNS but where only the other can get negotiated\r\n\r\nWhy would this happen?\r\n",
          "createdAt": "2019-11-13T21:46:33Z",
          "updatedAt": "2019-11-13T21:46:33Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@MikeBishop What do you think is supposed to happen with ALPN in Alt-Svc?  If the Alt-Svc says \"h2=...\", can the client also offer \"http/1.1\" in the ClientHello?  RFC 7838 doesn't seem very clear on this.",
          "createdAt": "2019-11-13T21:49:26Z",
          "updatedAt": "2019-11-13T21:49:26Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Synchronization between DNS configuration and HTTP/TLS server configuration seems challenging.  I suspect it is highly likely that mismatches here will happen regularly, especially as the h2 vs http/1.1 variations may be a little more subtle than QUIC.  It would be nice if things here had good usability and just worked as long as behaviors are safe and robust.",
          "createdAt": "2019-11-13T22:04:22Z",
          "updatedAt": "2019-11-13T22:04:22Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I added text for this to #78.",
          "createdAt": "2019-11-13T22:22:12Z",
          "updatedAt": "2019-11-13T22:22:12Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "As best I recall and without rechecking 7838:  With Alt-Svc, the client can offer anything, but if the connection winds up not having the properties the Alt-Svc entry told it to expect, it's not usable.  We might choose to depart from that, however.",
          "createdAt": "2019-11-14T01:58:08Z",
          "updatedAt": "2019-11-14T01:58:08Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the explanation.  Please take a look at #78 for the proposed change.",
          "createdAt": "2019-11-14T02:24:44Z",
          "updatedAt": "2019-11-14T02:24:44Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "Yes, RFC7838 says:\r\n> If the connection to the alternative service does not negotiate the expected protocol (for example, ALPN fails to negotiate h2, or an Upgrade request to h2c is not accepted), the connection to the alternative service MUST be considered to have failed.\r\n\r\nThe softer stance of \"SHOULD include others with equivalent security\" seems reasonable, but we might get some pushback on the divergence.",
          "createdAt": "2019-11-14T18:07:03Z",
          "updatedAt": "2019-11-14T18:07:03Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Merged #78",
          "createdAt": "2019-11-14T18:17:48Z",
          "updatedAt": "2019-11-14T18:17:48Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "MDU6SXNzdWU1MjI0ODc1MTg=",
      "title": "Bikeshed and finalize the record names",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/80",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wg"
      ],
      "body": "We should finalize the record names with community input (along with pronunciation for SVCB).\r\nIt's possible that \"SVCB\" is just fine, but \"HTTPSSVC\" is a constant pain due to the double-S.\r\n\"SVCHTTPS\" might be slightly better.  \"HTTPS\" is great but makes text less readable.\r\n",
      "createdAt": "2019-11-13T21:38:09Z",
      "updatedAt": "2020-06-12T20:12:25Z",
      "closedAt": "2020-06-12T20:12:25Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Proposal based on survey and discussions is to call the records \"SVCB\" and \"HTTPS\" but to talk about an \"SVCB-form HTTPS\" record to help disambiguate.",
          "createdAt": "2020-03-09T19:45:45Z",
          "updatedAt": "2020-03-09T19:45:45Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "MDU6SXNzdWU1MjQxNzY2NTU=",
      "title": "Clarify fallback behaviour",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/81",
      "state": "CLOSED",
      "author": "c-taylor",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "proposed to close",
        "question"
      ],
      "body": "I believe that either this draft or a revision of rfc7838 should clarify the client behaviour or provide stronger guidance for the scenarios:\r\n- Fallback to origin from alternates\r\n-- Both with and without downgrade considerations\r\n- Multiple same priority alternates\r\n-- After random shuffle do I use one? all?\r\n-- Should client fail to origin or same priority?\r\n- Multiple differing priority alternates\r\n-- Fail down the tree or straight to origin?\r\n\r\n \r\n\r\nrfc7838 was not explicit here either, which has (probably) led to the fail-back having low implementation. Defined/predictable client failover behaviour is a big win.\r\n\r\nHappy to help with words if you think there's a place for this...",
      "createdAt": "2019-11-18T07:08:47Z",
      "updatedAt": "2021-01-15T21:22:18Z",
      "closedAt": "2021-01-15T21:22:18Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "One thing I've learned here is that browser vendors do not like being told how to structure their fallback logic, which it seems is often deeply entangled with other aspects of their codebase and full of hard-won performance and compatibility hacks.  We should be clear in our recommendations about what is mandatory, but I don't think we should be more prescriptive than necessary.",
          "createdAt": "2019-11-18T10:07:46Z",
          "updatedAt": "2019-11-18T10:07:46Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Current text is \"If the connection fails, the client MAY try to connect using values from a lower-priority record.\"",
          "createdAt": "2020-05-29T19:46:15Z",
          "updatedAt": "2020-05-29T19:46:15Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "@c-taylor : there is a bunch more on this in the draft since November.  Do you think the current text is good enough?  (The current fallback description is a \"MAY\".)",
          "createdAt": "2020-05-29T19:46:25Z",
          "updatedAt": "2020-05-29T19:46:25Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "MDU6SXNzdWU1MjQyOTcyMzE=",
      "title": "Adjust CamelCase names",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/82",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Some of the CamelCase names could be improved.  For example, SvcFieldPriority is now used in AliasForm, so maybe it should just be SvcPriority or SvcIndex.",
      "createdAt": "2019-11-18T11:11:46Z",
      "updatedAt": "2020-07-13T17:32:13Z",
      "closedAt": "2020-07-13T17:32:12Z",
      "comments": [
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "These are the CamelCase names I found\r\n\r\nSvcDomainName\r\nSvcFieldPriority\r\nSvcFieldValue\r\nSvcParamKey\r\nSvcParamValue\r\nSvcRecordType\r\nAliasForm\r\nServiceForm\r\nClientHello\r\n",
          "createdAt": "2020-06-19T02:02:02Z",
          "updatedAt": "2020-06-19T02:02:02Z"
        },
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "Personally I'm happy with SvcFieldPriority.  If it has to change then SvcPriority.",
          "createdAt": "2020-06-19T02:28:31Z",
          "updatedAt": "2020-06-19T02:28:31Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Of these I think only SvcFieldPriority might want to change to SvcPriority but I don't strongly care either way.",
          "createdAt": "2020-06-19T02:36:10Z",
          "updatedAt": "2020-06-19T02:36:10Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "SvcPriority makes more sense as it is the priority for the RR itself, ",
          "createdAt": "2020-06-19T03:22:52Z",
          "updatedAt": "2020-06-19T03:22:52Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed that SvcFieldPriority can simply be SvcPriority.\r\n\r\nIs there a reason we need \"field\" in SvcFieldValue? Is SvcValue too value? Could that be SvcParams, to indicate that its the parameter list?",
          "createdAt": "2020-06-19T03:27:34Z",
          "updatedAt": "2020-06-19T03:27:34Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should do that, but we will also have to expand the ABNF to ref;ect ot\r\n\r\nSVCParams = SVCParam *(SVCParam)\r\n",
          "createdAt": "2020-06-19T03:36:30Z",
          "updatedAt": "2020-06-19T03:36:30Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I like \"SvcPriority\" and \"SvcParams\".\r\n\r\nI wrote up a more radical proposal in #160 that gets rid of all the camel case names.  From that analysis, some comments:\r\n\r\n* AliasForm/ServiceForm have generated some confusion because they are in fact a single form as far as parsing is concerned.  I think \"mode\" is probably more accurate than \"form\".\r\n* \"SvcDomainName\" is potentially confusing, given that it appears in both ServiceForm and AliasForm, and can itself contain either ServiceForm or AliasForm records.  Also, \"DomainName\" seems redundant.\r\n* SvcRecordType is vestigial.  It's now computed implicitly from SvcFieldPriority.  I would rephrase to remove it entirely.",
          "createdAt": "2020-06-22T19:46:56Z",
          "updatedAt": "2020-06-22T19:46:56Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Perhaps \"TargetName\" or \"TargetDomain\" instead of \"SvcDomainName\" ?\r\nSvcParams and SvcPriority sound good.\r\nAliasMode/ServiceMode also seem fine if \"Form\" causes confusion.",
          "createdAt": "2020-06-22T20:33:18Z",
          "updatedAt": "2020-06-22T20:33:18Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like \"TargetName\" - it is a fully qualified domain name and not just a domain name correct ?  \r\nThat should be more explicit",
          "createdAt": "2020-06-22T20:42:26Z",
          "updatedAt": "2020-06-22T20:42:26Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One thing in favor of keeping SvcDomainName is that it is the Alt-Svc name, so having \"Svc\" is nice.",
          "createdAt": "2020-06-22T20:43:34Z",
          "updatedAt": "2020-06-22T20:43:34Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "But given the decoupling from Alt-Svc, \"TargetName\" might actually reduce confusion.",
          "createdAt": "2020-06-22T20:48:55Z",
          "updatedAt": "2020-06-22T20:48:55Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fair!",
          "createdAt": "2020-06-22T21:06:57Z",
          "updatedAt": "2020-06-22T21:06:57Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I updated PR #160 to match the names discussed here.  Please review.",
          "createdAt": "2020-07-06T17:56:01Z",
          "updatedAt": "2020-07-06T17:56:01Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Okay, I went back through this and everything looks good Ben. ",
          "createdAt": "2020-07-07T01:35:13Z",
          "updatedAt": "2020-07-07T01:35:13Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #160",
          "createdAt": "2020-07-13T17:32:12Z",
          "updatedAt": "2020-07-13T17:32:12Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "MDU6SXNzdWU1MjgzNTIwNzY=",
      "title": "Grammar for presentation format does not produce parentheses",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/83",
      "state": "CLOSED",
      "author": "dmcardle",
      "authorAssociation": "NONE",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "Examples like this one (from section 1.1) use a notation where the SvcFieldValue is surrounded by parentheses.\r\n```\r\n   ; ServiceForm\r\n   svc.example.net.  7200  IN HTTPSSVC 2 svc3.example.net. ( alpn=h3\r\n                                       port=8003 esniconfig=\"...\" )\r\n```\r\n\r\nIt looks like the top-level production rule is this:\r\n```\r\n   pair          = display-key \"=\" value\r\n```\r\n\r\nShouldn't there be a rule just one level higher? Something like this?\r\n```\r\n   svc-field-value = [ \"(\" 1*pair \")\" ]\r\n```\r\n",
      "createdAt": "2019-11-25T21:39:19Z",
      "updatedAt": "2020-01-15T21:25:20Z",
      "closedAt": "2020-01-15T21:25:20Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "The parentheses are zone file format for spanning a line break (RFC 1035 Section 5.1).  They're not part of the SVCB presentation format.\r\n\r\nIf this is confusing maybe we can structure the examples differently.  The examples originally used \"\\\\\" to indicate a line break that readers should ignore, but this is not valid zone file syntax.",
          "createdAt": "2019-11-25T21:42:28Z",
          "updatedAt": "2019-11-25T21:42:54Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "NONE",
          "body": "Aha, thanks!  I think it's worth mentioning how this grammar hooks up to the zone file syntax so newcomers like me can follow along mechanically.\r\n\r\nIt looks like RFC 1035 predates the ABNF syntax defined in RFC 5234, so maybe \"hooking up\" the grammars is not really possible/meaningful?",
          "createdAt": "2019-11-25T21:59:22Z",
          "updatedAt": "2019-11-25T21:59:22Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I will try to make that clearer.\r\n\r\nYeah, there's no ABNF for zone files, which is why we had to define this ugly `basic-visible` thing, etc.  I'm pretty sure it's still not exactly right but it's close enough.",
          "createdAt": "2019-11-25T22:54:31Z",
          "updatedAt": "2019-11-25T22:54:31Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "MDU6SXNzdWU1MjgzNTU0Mzc=",
      "title": "Add a simple example",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/84",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "After looking at the examples, several readers came away with the impression that an alias is required to use SVCB.  In fact, aliasing is bad for performance and should be avoided when possible, but we've included it in all of our examples to show how all the pieces of the system work.\r\n\r\nWe should include an optimized example, and make it clear that many common cases can be handled without adding any indirection.",
      "createdAt": "2019-11-25T21:46:42Z",
      "updatedAt": "2020-05-29T19:48:02Z",
      "closedAt": "2020-05-29T19:47:51Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "This should be resolved now.",
          "createdAt": "2020-05-29T19:48:02Z",
          "updatedAt": "2020-05-29T19:48:02Z"
        }
      ]
    },
    {
      "number": 86,
      "id": "MDU6SXNzdWU1Mjg0MDIwNTQ=",
      "title": "Clarify server behavior",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/86",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "help wanted"
      ],
      "body": "We need a careful implementor review on Section 4, particularly regarding what to put in the Additional section for negative responses (with and without DNSSEC).\r\n\r\nI also wonder how this would interact with the CHAIN query.",
      "createdAt": "2019-11-25T23:43:40Z",
      "updatedAt": "2020-07-13T20:25:06Z",
      "closedAt": "2020-07-13T20:25:06Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "We also need more thought about what goes in the Answer vs. Additional.  If the authoritative puts more stuff in the Answer, will non-SVCB-aware recursives be more likely to forward that stuff to the client?",
          "createdAt": "2019-12-13T21:53:39Z",
          "updatedAt": "2019-12-13T21:53:39Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@marka63 Would you be able to review Section 4 with an eye toward DNSSEC and negative responses?  I'd like to make sure that the recommendations really make sense.",
          "createdAt": "2020-05-29T19:52:53Z",
          "updatedAt": "2020-05-29T19:52:53Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks like we're waiting on @marka63 to review Section 4 with an eye toward DNSSEC and negative responses before we can close this.",
          "createdAt": "2020-06-11T14:58:14Z",
          "updatedAt": "2020-06-11T14:58:14Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I will talk to Benno if someone on the Unbound team can also review this. ",
          "createdAt": "2020-06-18T04:09:27Z",
          "updatedAt": "2020-06-18T04:09:27Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Resolved by #199",
          "createdAt": "2020-07-13T20:25:06Z",
          "updatedAt": "2020-07-13T20:25:06Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "MDU6SXNzdWU1MzM0Mjc2NTQ=",
      "title": "Should the presence of an HTTPS record suppress any certificate warning bypass option?",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/87",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "davidben"
      ],
      "labels": [],
      "body": "Elsewhere, HTTPSSVC's redirect was referred to as HSTS and it occurred to me we're missing one of HSTS's properties. It redirects and then it directs the browser to suppress the certificate click through button.\r\n\r\nWe could do something similar and say that HTTPS connections made off an HTTPSSVC record are assumed to have a competent TLS config and don't get a bypass button.",
      "createdAt": "2019-12-05T15:36:40Z",
      "updatedAt": "2020-12-05T15:22:29Z",
      "closedAt": "2020-12-05T15:22:29Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Relevant parts of HSTS spec:\r\nhttps://tools.ietf.org/html/rfc6797#section-8.4\r\nhttps://tools.ietf.org/html/rfc6797#section-12.1",
          "createdAt": "2019-12-05T15:38:11Z",
          "updatedAt": "2019-12-05T15:38:11Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben There's a potential \"footgun escalation\" here, compared to HSTS.  With HSTS, we at least know that the site had correctly configured HTTPS at some point in the past; otherwise HSTS could not have been enabled (except for HSTS preload...).  With HTTPSSVC, there's no such guarantee.  The server could have been misconfigured all along.\r\n\r\nPersonally, I think it would be perfectly reasonable for a client to adopt the behavior you're describing, but I don't see why it needs to be part of the standard.  However, if you think it should be in the draft, we can certainly add it (e.g. \"Clients MAY/SHOULD disable security bypass UI as per RFC 6797 Section 12.1.\").",
          "createdAt": "2019-12-13T19:15:58Z",
          "updatedAt": "2019-12-13T19:15:58Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It needs to be part of the standard because the standard talks about what HTTPSSVC *means*. Right now it means \"you can assume my http URL is a redirect\". Does it also mean \"you can assume my https URL is sensible\"?\r\n\r\nThe point of standards is to promote interoperability. That means we need to all agree on the meanings of things.\r\n\r\nMy inclination is that it should mean this. A promise (up to DNS TTL) to deploy certificates correctly is not that much of a tall order over the existing promise to do https, and we nudge the web a little more towards security.",
          "createdAt": "2019-12-14T00:26:12Z",
          "updatedAt": "2019-12-14T00:26:56Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "NONE",
          "body": "@bemasc pointed me to this thread after I espoused the misconception that HTTPS RRs do not make certificate errors fatal, and I want to make an attempt to reverse this decision. :)\r\n\r\nI know this is an unpopular opinion, but I think it was a mistake to have STS make cert errors fatal. Cert errors are overwhelmingly false positives, and many of them are caused by client or network misconfigurations that the server operator has no control over (misconfigured middleboxes, captive portals, bad client clocks, etc.). I suspect that the vast majority of server operators who enable STS don't know about the cert error behavior, and even if they do I suspect they don't know about the vast array of (mostly benign) conditions outside their control that can cause cert errors.\r\n\r\nI think that the default configuration of HTTPS RRs should be to not make cert errors fatal, but maybe that can be a separate lever that site owners can configure. (Ideally I'd like STS to work this way too, but not sure if we can go back now.)",
          "createdAt": "2020-10-26T16:58:21Z",
          "updatedAt": "2020-10-26T16:58:21Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "I don't think IETF should be encouraging domain owners to make HTTPS protections bypassable unless we have a strong indication that not providing that option will significantly reduce adoption of HTTPS records.  We should be moving the internet to a world where connections are secure and validated, not one where we keep skipping those protections and allowing bad client/network misconfigurations to continue.\r\n\r\nDoes your knowledge on the subject lead you to believe such adoption reduction would be significant?",
          "createdAt": "2020-10-26T17:28:54Z",
          "updatedAt": "2020-10-26T17:28:54Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "NONE",
          "body": "I don't have data on whether it would impede adoption. However, I do know that false positive cert errors caused by non-server misconfigurations persist despite multiple person-years of effort to systematically drive them down (https://research.google/pubs/pub46359/). Also note that in modern browsers, cert errors are quite difficult to bypass, leading to low clickthrough rates that could probably be driven down even further with a bit more effort. For example users adhere to ~80% of cert errors in Chrome on Windows.",
          "createdAt": "2020-10-26T17:46:12Z",
          "updatedAt": "2020-10-26T17:46:12Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "Wouldn't low bypass clickthrough rates be a point against allowing bypass for new HTTPS technologies? Seems that in the vast majority of cases, users don't know how or don't want to bypass it, and that hasn't stopped HTTPS use on the internet.  The users either take action to fix the client/network misconfiguration, or they stop using the website/network that they can't connect to.\r\n\r\nThe only usecase I see being supported by allowing website control of this is for websites that want to give their users directions on how to bypass the error page.  I don't think that is a usecase IETF should be encouraging or further enabling as it seems terrible for user security.  If those websites want to keep doing that, I think it would be best that they do so without access to the shiny new toys like HTTPS records.",
          "createdAt": "2020-10-26T17:59:31Z",
          "updatedAt": "2020-10-26T17:59:31Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "NONE",
          "body": "Another possible interpretation of the low clickthrough rate is that more technical people who are able to reason correctly about the risks click through errors, while others leave the site. The point of having a bypass is that the browser can't always know what's in the user's best interest. That doesn't mean we can add an option/setting for every single security decision, but we already have this one. We (where by \"we\" here I mean a browser, not IETF) have a budget for how much we can inconvenience users in the name of security, and I'd rather spend that budget elsewhere (e.g., putting stronger warnings on http:// pages).\r\n\r\n> The only usecase I see being supported by allowing website control of this is for websites that want to give their users directions on how to bypass the error page\r\n\r\nI don't think that's a relevant use case here; the user wouldn't be able to access the website for directions until they click through the cert error, at which point they wouldn't need the directions.",
          "createdAt": "2020-10-26T18:17:03Z",
          "updatedAt": "2020-10-26T18:17:03Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@estark37 Hah, clearly I should have checked with you here before writing the PR. :-)\r\n\r\nThat's a good point that certificate warnings have better adherence now than when HSTS was designed. I probably haven't sufficiently updated my thoughts for this new world. Let me try thinking aloud for a bit and maybe you can tell me where we're not on the same page?\r\n\r\nI've generally considered the certificate click-through a legacy mistake, but one we're now stuck with because it has made self-signed or otherwise invalid certs *just barely* feasible enough that sites will do it, with the expectation that users bypass the error. Thus any ratchet we can use to get out of the hole and discourage \"intentional\" certificate errors is worthwhile. (After all, we don't ask users to validate syntax errors in HTTP/2 frames.)\r\n\r\nI like the framing of certificate errors from server- and non-server-related causes. That seems a good way to think about it, since it tells us whether to fix via client behavior (clickthrough or otherwise), or via server behavior (server gives us an opt-in and/or opt-out signal telling us they're good at such-and-such).\r\n\r\nFor non-server-related causes, it seems to me neither a server opt-in nor opt-out bit would make sense because the server doesn't have any information about the cause. Of the examples (misconfigured middleboxes, captive portals, bad client clocks, etc.), it seems a cert bypass isn't a good remedy for captive portals anyway. We don't actually want or need to give HTTPS-breaking privileges to the network, just separately get through the captive portal flow. So improving the captive portal flow seems preferable to me.\r\n\r\nI'm not such about the other two. In the bad clock case, I would have hoped the bad clock interstitial (which we should trigger independent of HSTS/HTTPSRR) would solve it, but I take it we still have gaps? Misconfigured middleboxes are interesting... my inclination would be that the enterprise or AV in question should be configuring this stuff rather than relying on users bypassing *every single* certificate error. Or is there another flow here?\r\n\r\nFor server-related causes, I guess it's a question of whether we think the ecosystem is ready enough for a particular commitment to be viable by default. A commitment to use a publicly trusted CA rather than relying on bypass seems pretty solid to me. I would like for sites to also be on the hook for resolving expired certificates (better yet, automate cert issuance!), but maybe we're not ready for that yet?",
          "createdAt": "2020-10-26T18:28:18Z",
          "updatedAt": "2020-10-26T18:31:44Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Something else that comes to mind: whatever server commitment we end up with, the text probably should be tweaked a bit. For something like the TLS 1.0/1.1 deprecation, we ended up with a temporarily bypassable error, as an intermediate step to removing the protocols entirely. I think HSTS/SVCB should *not* block those bypasses, yet the text doesn't account for it. Those bypasses are an artifact of the meaning of \"I promise to do HTTPS\" adjusting over time. While we're in the transition state, the prompt behavior should also be in the transition state.\r\n\r\n(Then again, unlike HSTS, SVCB does currently say SHOULD instead of MUST, so you could argue this case falls under the SHOULD. HSTS's text was maybe a bit prescriptive though. Ah well.)",
          "createdAt": "2020-10-26T18:37:47Z",
          "updatedAt": "2020-10-26T18:37:47Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "> (Then again, unlike HSTS, SVCB does currently say SHOULD instead of MUST, so you could argue this case falls under the SHOULD. HSTS's text was maybe a bit prescriptive though. Ah well.)\r\n\r\nI don't think we should add temporary transition complications to the text.  Being SHOULD instead of MUST is sufficient room for browsers to do any transition necessary.\r\n\r\nAnd you now give me two additional chains of thought on this subject:\r\n1. If the bypass is potentially something we're stuck with mostly just because we've always had it, how much does that factor apply to HTTPS records? Is this enough of a transition that, by setting up HTTPS records, sites are reasonably transitioning into a new way of doing things, potentially making that a reasonable point to disable the old legacy behavior? Or does the website transitioning things not matter, because to the user perspective, it's still just the same https:// websites and they're the ones (or at least the technical users among them that know how to bypass) being inconvenienced by any change.\r\n2. Is this something websites should have control over at all (through HSTS, HTTPS records, etc)? If most of these reasons to allow bypass have nothing to do with the specific website, should those websites have any control over inconveniencing the technical risk-knowledgable users that want to bypass? Should a website's knowledge of things such as being a security-sensitive website override that? If there's no reason for websites to influence it, this almost seems something unnecessary for IETF to deal with in specs like this, leaving it up to browsers to either implement or not a bypass for all cert errors.",
          "createdAt": "2020-10-26T18:54:18Z",
          "updatedAt": "2020-10-26T18:54:18Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "NONE",
          "body": "> @estark37 Hah, clearly I should have checked with you here before writing the PR. :-)\r\n> \r\n> That's a good point that certificate warnings have better adherence now than when HSTS was designed. I probably haven't sufficiently updated my thoughts for this new world. Let me try thinking aloud for a bit and maybe you can tell me where we're not on the same page?\r\n> \r\n> I've generally considered the certificate click-through a legacy mistake, but one we're now stuck with because it has made self-signed or otherwise invalid certs _just barely_ feasible enough that sites will do it, with the expectation that users bypass the error. Thus any ratchet we can use to get out of the hole and discourage \"intentional\" certificate errors is worthwhile. (After all, we don't ask users to validate syntax errors in HTTP/2 frames.)\r\n\r\nInteresting, I don't think of cert clickthroughs as a legacy mistake. Definitely the IE6-style ones where OK was the default button, but not modern cert errors where the bypass exists but is quite buried. If we really thought that having a bypass at all was a legacy mistake, I don't actually think it would be that hard to get rid of it for all sites, and I'd rather go at it directly that way rather than add more knobs and edge cases to the decision tree of whether a cert error is bypassable.\r\n\r\nI don't think we can exactly measure how many sites are using invalid certs expecting that users will click through, but my guess is that it's not common. In 2017, <=1% of all cert errors were self-signed certs. With modern cert errors making it so hard to click through, I doubt tons of sites are relying on users doing it.\r\n\r\nI agree that we can't expose user settings for every security decision, but I do think settings make sense in some scenarios, and it's more of an art than a science deciding where it makes sense to have them. In my mind a big factor in the decision is the complexity of implementing/maintaining the setting, and as I mentioned above, if a goal is to get rid of the complexity of maintaining the setting, then I'd rather go about it directly for all cert errors -- which would also exert more influence over the server operators who knowingly deploy bad certs (since who knows how many of such server operators would use HTTPS RRs).\r\n\r\n> \r\n> I like the framing of certificate errors from server- and non-server-related causes. That seems a good way to think about it, since it tells us whether to fix via client behavior (clickthrough or otherwise), or via server behavior (server gives us an opt-in and/or opt-out signal telling us they're good at such-and-such).\r\n>\r\n\r\nTo clarify my stance, clickthrough is definitely not the *ideal* fix for any situation, but it could be the right tradeoff for some users in some situations in today's reality, and I don't predict that HTTPS RRs would change today's reality much.\r\n \r\n> For non-server-related causes, it seems to me neither a server opt-in nor opt-out bit would make sense because the server doesn't have any information about the cause. Of the examples (misconfigured middleboxes, captive portals, bad client clocks, etc.), it seems a cert bypass isn't a good remedy for captive portals anyway. We don't actually want or need to give HTTPS-breaking privileges to the network, just separately get through the captive portal flow. So improving the captive portal flow seems preferable to me.\r\n\r\nImproving the captive portal flow would be great, but it's not really clear how to do it. Despite significant cycles spent to build OS- and browser-level captive portal detection, people still encounter cert errors while connecting to captive portals allllll the time, and often don't know what else to do but click through.\r\n\r\n> \r\n> I'm not such about the other two. In the bad clock case, I would have hoped the bad clock interstitial (which we should trigger independent of HSTS/HTTPSRR) would solve it, but I take it we still have gaps? Misconfigured middleboxes are interesting... my inclination would be that the enterprise or AV in question should be configuring this stuff rather than relying on users bypassing _every single_ certificate error. Or is there another flow here?\r\n\r\nBad clock interstitial works well in Chrome, but I don't think most browsers do that. And yeah, in the misconfigured middlebox case, as in every other misconfig case, it sure isn't the ideal outcome for users to bypass every cert error, but realistically that's what some people do now. If we want to go after improving the middlebox situation, for example, I think we'd be better off going after that situation directly rather than adding UX and implementation complexity to go after it indirectly by tying it to HTTPS RRs.\r\n\r\n> \r\n> For server-related causes, I guess it's a question of whether we think the ecosystem is ready enough for a particular commitment to be viable by default. A commitment to use a publicly trusted CA rather than relying on bypass seems pretty solid to me. I would like for sites to also be on the hook for resolving expired certificates (better yet, automate cert issuance!), but maybe we're not ready for that yet?\r\n\r\nIn a world where we knew that all cert errors were caused by server errors, then yeah I think removing the bypass would make a lot more sense. But right now many cert errors aren't caused by server errors, and with STS/HTTPS RRs, the server is making a decision on behalf of the user without actually knowing anything about what caused the error and what the user's situation is.",
          "createdAt": "2020-10-26T19:23:43Z",
          "updatedAt": "2020-10-26T19:32:07Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "NONE",
          "body": "> > (Then again, unlike HSTS, SVCB does currently say SHOULD instead of MUST, so you could argue this case falls under the SHOULD. HSTS's text was maybe a bit prescriptive though. Ah well.)\r\n> \r\n> I don't think we should add temporary transition complications to the text. Being SHOULD instead of MUST is sufficient room for browsers to do any transition necessary.\r\n> \r\n> And you now give me two additional chains of thought on this subject:\r\n> \r\n> 1. If the bypass is potentially something we're stuck with mostly just because we've always had it, how much does that factor apply to HTTPS records? Is this enough of a transition that, by setting up HTTPS records, sites are reasonably transitioning into a new way of doing things, potentially making that a reasonable point to disable the old legacy behavior? Or does the website transitioning things not matter, because to the user perspective, it's still just the same https:// websites and they're the ones (or at least the technical users among them that know how to bypass) being inconvenienced by any change.\r\n> 2. Is this something websites should have control over at all (through HSTS, HTTPS records, etc)? If most of these reasons to allow bypass have nothing to do with the specific website, should those websites have any control over inconveniencing the technical risk-knowledgable users that want to bypass? Should a website's knowledge of things such as being a security-sensitive website override that? If there's no reason for websites to influence it, this almost seems something unnecessary for IETF to deal with in specs like this, leaving it up to browsers to either implement or not a bypass for all cert errors.\r\n\r\nI think #2 is a very reasonable stance to take, in line with the priority of constituencies. A good chunk of cert errors have absolutely nothing to do with the server -- the server can't fix them, the server doesn't know what the right decision is for the user -- so why does the server get to have a say over how they're presented to the user? And if our position is that cert errors should never be bypassable, HTTPS RRs seems like an indirect way to go about accomplishing that.",
          "createdAt": "2020-10-26T19:30:05Z",
          "updatedAt": "2020-10-26T19:30:05Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "What are the options here?  Top contenders seem to be:\r\n1) Leave it as the current \"SHOULD NOT\" bypass cert errors\r\n2) Weaken this to a \"MAY\" but add in a new parameter that explicitly says MUST NOT bypass\r\n",
          "createdAt": "2020-10-26T20:36:16Z",
          "updatedAt": "2020-10-26T20:36:16Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "I think the direction of this conversation might be leaning more into:\r\n\r\n3. Weaken to \"MAY\" or maybe even remove any mention of the topic, and do not add any parameter to allow even optional server control.  Just leave it a matter for client implementors to decide how to communicate cert errors to users and whether or not the client UI will allow bypassing, same as any other HTTPS connections (except HSTS).",
          "createdAt": "2020-10-26T20:42:09Z",
          "updatedAt": "2020-10-26T20:42:09Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thinking as a dns person, In either case, we should have an example  in the appendix where we show a setup where this would return cert errors.  DNS people like to stand up broken DNS zones as examples. \r\n\r\nAny user issue will hit a DNS person first who should have guidance on head scratching. But I also admit I need to reread this whole thread.  thanks @estark37 ! \r\n\r\n",
          "createdAt": "2020-10-26T20:52:08Z",
          "updatedAt": "2020-10-26T20:52:08Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Interesting, I don't think of cert clickthroughs as a legacy mistake. Definitely the IE6-style ones where OK was the default button, but not modern cert errors where the bypass exists but is quite buried. If we really thought that having a bypass at all was a legacy mistake, I don't actually think it would be that hard to get rid of it for all sites, and I'd rather go at it directly that way rather than add more knobs and edge cases to the decision tree of whether a cert error is bypassable.\r\n>\r\n> I don't think we can exactly measure how many sites are using invalid certs expecting that users will click through, but my guess is that it's not common. In 2017, <=1% of all cert errors were self-signed certs. With modern cert errors making it so hard to click through, I doubt tons of sites are relying on users doing it.\r\n\r\nAnecdotally, we get quite a lot of networking bug reports where people expect to bypass certificate errors. Sometimes it's developers whose workflow involves bypassing a local cert error. Sometimes it's a weird networking product that's, distressingly, _designed_ to have the user bypass some error. :-( Even if all non-server issues were fixed, I suspect we'd still have difficulties getting rid of this bypass. Thus, the aim to ratchet away the invalid server configurations.\r\n\r\nRegarding it being legacy or not, I think my ideal state would be one where the bypass wasn't there. Browsers never ask humans to evaluate X.509 certificates, and, through that, the expectation would be on technologies to work without expecting humans to do this. (A nice self-reenforcing cycle to avoid regression.) Maybe automated certificate issuance would be standard so expired certs aren't a problem. Maybe developer use cases would go through better tooling. Maybe this would incentivize captive portals to work correctly with detectors, rather than hide from them.\r\n\r\nWe are, of course, not in the state right now. This is extra annoying because the self-reenforcing cycle is against improvement rather than regression. And so the hope is increasingly broad ratcheting strategies would help us get there and, in the meantime, carve off chunks of the web where the risks are mitigated.\r\n\r\nBut ratcheting works best when the obstacle is a property of the server. It sounds like it's no longer the primary bottleneck and maybe we need to address those before we can broaden the ratchet. :-/ On the plus side, the improved error dialogs also make the problem less severe. (Annoyingly, saying \"HTTPS RRs are a commitment not to rely on a bypass for server-related reasons\" is kinda pointless if the non-server reasons prevent us from enforcing it. Unenforced parts of protocols are mostly fiction.)\r\n\r\n> Improving the captive portal flow would be great, but it's not really clear how to do it. Despite significant cycles spent to build OS- and browser-level captive portal detection, people still encounter cert errors while connecting to captive portals allllll the time, and often don't know what else to do but click through.\r\n\r\nHrm. I don't suppose we've considered something truly absurd like just including a link to captive portal HTTP URL from the link? Users clicking through certificate errors in hopes of hitting a captive portal seems the worst possible outcome. :-/ But I recognize that's proposing to build a thing that doesn't actually exist right now, so not very helpful in resolving this issue.\r\n\r\n> Bad clock interstitial works well in Chrome, but I don't think most browsers do that.\r\n\r\nThat's fair. Although I would advocate those browsers do that. If bad clock interstitials fully mitigate this (do they?), I'm quite happy to declare that one solved and rejoice. :-)\r\n\r\n> And yeah, in the misconfigured middlebox case, as in every other misconfig case, it sure isn't the ideal outcome for users to bypass every cert error, but realistically that's what some people do now. If we want to go after improving the middlebox situation, for example, I think we'd be better off going after that situation directly rather than adding UX and implementation complexity to go after it indirectly by tying it to HTTPS RRs.\r\n\r\nI think I agree with everything you say here, except the conclusion. In my mind, the aim of tying something to HTTPS RRs is not to address middlebox misconfigurations, but to address server misconfigurations. The connection to non-server misconfigurations like middleboxes is, if they're too common, they make this strategy less viable.",
          "createdAt": "2020-10-26T21:28:07Z",
          "updatedAt": "2020-10-26T21:29:20Z"
        },
        {
          "author": "brian-peter-dickson",
          "authorAssociation": "NONE",
          "body": "Minor nit on the conversation/thread:\nThe term \"server\" has the potential to be ambiguous.\nCould we try to stick to more precise terms, like \"web server\", \"authority\nDNS server\", \"recursive DNS server (aka resolver\", \"CA server\",\n\"authoritative DNSSEC server\", \"DNSSEC signer\", or any other sort of server\nthat might be in play (e.g. OCSP, etc.)?\nThanks,\nBrian\n\nOn Mon, Oct 26, 2020 at 2:28 PM David Benjamin <notifications@github.com>\nwrote:\n\n> Interesting, I don't think of cert clickthroughs as a legacy mistake.\n> Definitely the IE6-style ones where OK was the default button, but not\n> modern cert errors where the bypass exists but is quite buried. If we\n> really thought that having a bypass at all was a legacy mistake, I don't\n> actually think it would be that hard to get rid of it for all sites, and\n> I'd rather go at it directly that way rather than add more knobs and edge\n> cases to the decision tree of whether a cert error is bypassable.\n>\n> I don't think we can exactly measure how many sites are using invalid\n> certs expecting that users will click through, but my guess is that it's\n> not common. In 2017, <=1% of all cert errors were self-signed certs. With\n> modern cert errors making it so hard to click through, I doubt tons of\n> sites are relying on users doing it.\n>\n> Anecdotally, we get quite a lot of networking bug reports where people\n> expect to bypass certificate errors. Sometimes it's developers whose\n> workflow involves bypassing a local cert error. Sometimes it's a weird\n> networking product that's, distressingly, *designed* to have the user\n> bypass some error. :-( Even if all non-server issues were fixed, I suspect\n> we'd still have difficulties getting rid of this bypass. Thus, the aim to\n> ratchet away the invalid server configurations.\n>\n> Regarding it being legacy or not, I think my ideal state would be one\n> where the bypass wasn't there. Browsers never ask humans to evaluate X.509\n> certificates, and, through that, the expectation would be on technologies\n> to work without expecting humans to do this. (A nice self-reenforcing cycle\n> to avoid regression.) Maybe automated certificate issuance would be\n> standard so expired certs aren't a problem. Maybe developer use cases would\n> go through better tooling. Maybe this would incentivize captive portals to\n> work correctly with detectors, rather than hide from them.\n>\n> We are, of course, not in the state right now. This is extra annoying\n> because the self-reenforcing cycle is against improvement rather than\n> regression. And so the hope is increasingly broad ratcheting strategies\n> would help us get there and, in the meantime, carve off chunks of the web\n> where the risks are mitigated.\n>\n> But ratcheting works best when the obstacle is a property of the server.\n> It sounds like it's no longer the primary bottleneck and maybe we need to\n> address those before we can broaden the ratchet. :-/ On the plus side, the\n> improved error dialogs also make the problem less severe, so it's less\n> critical. (Annoyingly, saying \"HTTPS RRs are a commitment not to rely on a\n> bypass for server-related reasons\" is kinda pointless if the non-server\n> reasons prevent us from enforcing it. Unenforced parts of protocols are\n> mostly fiction.)\n>\n> Improving the captive portal flow would be great, but it's not really\n> clear how to do it. Despite significant cycles spent to build OS- and\n> browser-level captive portal detection, people still encounter cert errors\n> while connecting to captive portals allllll the time, and often don't know\n> what else to do but click through.\n>\n> Hrm. I don't suppose we've considered something truly absurd like just\n> including a link to captive portal HTTP URL from the link? Users clicking\n> through certificate errors in hopes of hitting a captive portal seems the\n> worst possible outcome. :-/ But I recognize that's proposing to build a\n> thing that doesn't actually exist right now, so not very helpful in\n> resolving this issue.\n>\n> Bad clock interstitial works well in Chrome, but I don't think most\n> browsers do that.\n>\n> That's fair. Although I would advocate those browsers do that. If bad\n> clock interstitials fully mitigate this (do they?), I'm quite happy to\n> declare that one solved and rejoice. :-)\n>\n> And yeah, in the misconfigured middlebox case, as in every other misconfig\n> case, it sure isn't the ideal outcome for users to bypass every cert error,\n> but realistically that's what some people do now. If we want to go after\n> improving the middlebox situation, for example, I think we'd be better off\n> going after that situation directly rather than adding UX and\n> implementation complexity to go after it indirectly by tying it to HTTPS\n> RRs.\n>\n> I think I agree with everything you say here, except the same conclusion.\n> In my mind, the aim of tying something to HTTPS RRs is not to address\n> middlebox misconfigurations, but to address server misconfigurations. The\n> connection to non-server misconfigurations like middleboxes is, if they're\n> too common, they make this strategy less viable.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/MikeBishop/dns-alt-svc/issues/87#issuecomment-716833972>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ABPFI3KP3W5HJFMG2SXQOOLSMXSXLANCNFSM4JV3OBFA>\n> .\n>\n",
          "createdAt": "2020-10-26T22:35:30Z",
          "updatedAt": "2020-10-26T22:35:30Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds good. Being precise doesn't hurt.\r\n\r\nTo help with any existing ambiguity, the only relevant servers in this thread are HTTPS servers. They're what HTTPS records describe. The contents of the HTTPS record doesn't have much bearing on the other servers related to DNS. (Well, I suppose if your recursive is DoH and you use an HTTPS record to find it, this text applies to there too. But I'm not aware of any client that allows users to bypass HTTPS errors when establishing a connection to the DoH resolver, so it's moot.)",
          "createdAt": "2020-10-26T22:46:19Z",
          "updatedAt": "2020-10-26T22:46:19Z"
        },
        {
          "author": "fl1ger",
          "authorAssociation": "NONE",
          "body": "Moin!\r\n\r\nSo this probably goes sideways, but as a DNS person my main feature for HTTPS was to solve the CNAME at the APEX problem. As a test to the current clients out there I setup a couple of DNS resource records to try that and a bunch of web server to figure out where stuff ends up. As I was lazy I used regular port 80 http servers. And it worked with the current mostly Apple based clients (try bla42.de, https.bla42.de and hintdirect.bla42.de) . Now re reading the draft after this discussion it shouldn't, but I see no harm that it does and agree that we should not demand STS outright, but make it configurable via an option.\r\n\r\nSo long\r\n-Ralf\r\n",
          "createdAt": "2020-10-27T16:23:15Z",
          "updatedAt": "2020-10-27T16:23:15Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "Note that I believe this issue is mostly regarding just the behavior of whether clients can allow bypassing certificate errors via user action on error pages, or if the HTTP->HTTPS upgrade feature of HTTPS records of should follow the example of HSTS and require strictly terminating on cert errors with any option of bypass.  Sounds like you're talking about making the upgrade functionality in-general optional.  That's a different discussion, and there's already a separate bug for it: #100",
          "createdAt": "2020-10-27T21:30:24Z",
          "updatedAt": "2020-10-27T21:30:24Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi all.  I've proposed a middle-ground \"no recourse\" policy in #274; please take a look.  That proposal is based on the notion that there are some errors that almost-certainly reflect a server misconfiguration, and we can reasonably ask servers using this new RR type to make sure not to be misconfigured in this way.\r\n\r\nThis is a compromise: it's a small ratchet step, but it doesn't do much for security on its own.  It doesn't add knobs, but it does add edge cases.\r\n\r\nPlease comment ASAP.  The draft deadline is Monday, and I'd like to get this settled in time to get a new draft out.",
          "createdAt": "2020-10-28T20:10:12Z",
          "updatedAt": "2020-10-28T20:10:12Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not thrilled by PR #274.  I'm not sure why expiry is a no-recourse error by totally invalid certs are not.  What attacks does this guard against?  (Either way, it may be worth separating out the \"without recourse\" from the \"terminate the connection\" to make it clear that the latter is a MUST but that providing a recourse to the user is something that the U-A may wish to consider based on current best practices.)",
          "createdAt": "2020-10-28T20:49:12Z",
          "updatedAt": "2020-10-28T20:49:12Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Expiry is a no-recourse error because it's _definitely_ the server's fault, and the point of this section is that the server is promising to have working HTTPS.  A middlebox can't cause an expiry error.  Totally invalid certs could be a middlebox, so we leave the question of user recourse in that case entirely to the client.\r\n\r\nThis doesn't meaningfully guard against any attacks.  It's not a security measure on its own.  It's a \"situation simplification\" measure.  If we can reduce the number of cases where an escape hatch is offered, we'll have fewer cases to tackle in the future.  If we eventually close them all, then perhaps we can claim a security improvement.\r\n\r\nI should say that I have no strong opinion on what the draft should say on this point.  I'm just looking for a position that can command consensus.",
          "createdAt": "2020-10-28T21:08:13Z",
          "updatedAt": "2020-10-28T21:08:13Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "NONE",
          "body": "> Expiry is a no-recourse error because it's definitely the server's fault, and the point of this section is that the server is promising to have working HTTPS. A middlebox can't cause an expiry error.\r\n\r\nYou'd think so, but alas this isn't true. See Section 7.2 of https://storage.googleapis.com/pub-tools-public-publication-data/pdf/04822a2487f3cd27ff92dbfddf42d947acdc4257.pdf for an example where an AV product was installing and MITMing with an expired root. More generally, misconfigured client clocks can cause expired cert errors; we remediate this in Chrome with a custom error page, but not all browsers do that, and that wouldn't have helped with the case in Section 7.2 anyway.\r\n\r\nI'd suggest that no-user-recourse should just be a MAY, without any SHOULDs attached to it. If the ecosystem subsequently changes such that ratcheting down on server-caused errors becomes palatable without causing too much user pain for the non-server-caused error situations (as @davidben is imagining, I think), then UAs could start removing user recourse at that point.",
          "createdAt": "2020-10-28T22:48:26Z",
          "updatedAt": "2020-10-28T22:48:26Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "What about just replacing \"SHOULD\" with \"MAY\" and dropping the reference to HSTS?  (The question then becomes whether we should add more discussion.  We could reference some academic studies like the one from @estark37 as informational references  (or not)?",
          "createdAt": "2020-11-06T00:14:55Z",
          "updatedAt": "2020-11-06T00:14:55Z"
        },
        {
          "author": "tialaramex",
          "authorAssociation": "NONE",
          "body": "At least estark37 and possibly others have suggested that the user knows best. This is at least arguably wrong. https://11foot8.com/ matches years of psychological studies. Once humans have set upon a plan (in that case, driving under the low bridge in a truck) merely warning them that it's a bad idea won't help because they will strongly resist deviating from the plan - even though they do not in fact have independent reason to know it will work. A giant sign with \"Overheight Must Turn\" and stop lights ought to be enough right? Nope. They smash their truck into the bridge anyway. A \"bypass\" - even the one Chrome includes for HSTS - will be abused not only by people who should know better but also by people who haven't a clue, since it seems to work and they imagine (wrongly) that they wouldn't be able to smash their metaphorical truck into a bridge. They're relying on developers to prevent that. We should do so.\r\n\r\nUnlike Chrome, as far as I understand Firefox does not have any bypass for HSTS. I didn't see any recognisable Mozilla people in this thread (if I missed you, sorry) but I think it would be worth asking them about this because clearly they've had success (e.g. by shipping all public intermediates to sidestep AIA chasing/ caches) focusing on solving HTTPS user experience issues without leaving users constantly one wrong click away from doom.",
          "createdAt": "2020-11-06T07:00:05Z",
          "updatedAt": "2020-11-06T07:00:05Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@tialaramex I think there may be a misunderstanding here.  Chrome does not normally offer a bypass for HSTS, as you can verify [here](https://subdomain.preloaded-hsts.badssl.com/).  The question at hand is whether to extend that lack of bypass to domains that publish the new \"HTTPS\" RR.  (More precisely, the question is what recommendation the IETF should make regarding such a lack of bypass.)",
          "createdAt": "2020-11-06T15:03:38Z",
          "updatedAt": "2020-11-06T15:03:38Z"
        },
        {
          "author": "tialaramex",
          "authorAssociation": "NONE",
          "body": "Visiting the link @bemasc provided in Chrome on Windows behaved as I anticipated, you can simply type 'thisisunsafe' and bypass the HSTS error page.",
          "createdAt": "2020-11-06T20:40:58Z",
          "updatedAt": "2020-11-06T20:40:58Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "NONE",
          "body": "@tialaramex The 'thisisunsafe' bypass isn't part of the UI and isn't documented, and is used very very rarely. Please see https://emilymstark.com/2020/07/14/debunking-the-users-always-click-yes-myth.html for security warning research on this topic.",
          "createdAt": "2020-11-06T20:53:40Z",
          "updatedAt": "2020-11-06T20:53:40Z"
        },
        {
          "author": "brian-peter-dickson",
          "authorAssociation": "NONE",
          "body": "I'd like to leave a (hopefully both brief and succinct) comment on the larger issue:\r\nIMNSHO, the only party who should very specifically have control over any sort of fallback, should be the domain owner, i.e. the party publishing the HTTPS record.\r\n\r\nI'm not sure if it is currently part of the set of supported SVCB or HTTPS record values (which is the list of supported protocols), but IFF (if and only if) the owner publishes a supported non-HTTPS transport should it be at all possible to fallback.\r\n\r\nIf there is a fallback path (to non-HTTPS) published, then that would be how to handle cert failure(s).\r\nIf there is no fallback path published, meaning only the HTTPS variants are published, cert failures MUST be fatal.\r\n\r\nIs this a fairly clear logical if/then statement, and is the reason for this also obvious?",
          "createdAt": "2020-11-06T22:15:48Z",
          "updatedAt": "2020-11-06T22:15:48Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "NONE",
          "body": "@brian-peter-dickson please see the preceding discussion for why it is not an obvious conclusion that cert failures MUST be fatal when there is no fallback path. (https://github.com/MikeBishop/dns-alt-svc/issues/87#issuecomment-716735041 and the subsequent discussion with @davidben)",
          "createdAt": "2020-11-06T23:05:24Z",
          "updatedAt": "2020-11-06T23:05:24Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@brian-peter-dickson The word \"fatal\" here is somewhat ambiguous.  Everyone agrees that cert failures always cause the page load to fail with a big scary warning.  The question is whether the big scary warning can include some sort of \"user recourse\", i.e. escape hatch/bypass/override.  (I wouldn't call it a \"fallback\".)\r\n\r\nIn my view, the cert failure is \"fatal\" when the big scary warning appears, whether or not it offers a \"user recourse\".  Moreover, as @estark37 has highlighted, the presence or absence of \"user recourse\" is not really binary.  Interaction designers can make a \"user recourse\" highly visible, nearly unreachable, or anything in between.",
          "createdAt": "2020-11-06T23:09:03Z",
          "updatedAt": "2020-11-06T23:09:03Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "What if the draft clarifies that domains and addresses found through HTTPS records should only be connected to via HTTPS? If a domain publishes legacy A/AAAA records at the original domain that any client could have used to attempt non-HTTPS anyway, those are fair game for a client to attempt to use, depending on the logic and behavior of the client.  If a domain only publishes HTTPS, the domain owner is clearly communicating that that domain is intended to only handle HTTPS connections and no alternatives are given (and ideally, the server should reject any non-HTTPS connections).\r\n\r\nYes, this would mean that HTTPS-only domains would only be usable by clients that recognize HTTPS records, but those are the only clients that would know to only connect via HTTPS anyway.  The domain would also have to live with being unreliable if anything goes wrong with the network/client to make certs or HTTPS records unusable, but that's exactly why the recommendation should be to include A/AAAA records, to give clients more options and increase reliability.",
          "createdAt": "2020-11-06T23:13:16Z",
          "updatedAt": "2020-11-06T23:13:16Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@ericorth We're only talking about HTTPS here.  Even the \"user recourse\" option still runs over TLS and retains the https:// origin.\r\n\r\nHaving HTTPS and A/AAAA records for the name will be the common case for the foreseeable future.  I don't think there's any reason to sacrifice the HSTS behavior in that case.  It doesn't particularly help to answer the \"user recourse\" question.\r\n\r\nAlso, we recommend using \"TargetName=.\" to avoid extra indirection, but your logic here would _require_ that indirection, in order to avoid putting AAAA records on the hostname.",
          "createdAt": "2020-11-06T23:27:56Z",
          "updatedAt": "2020-11-06T23:27:56Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "Ah.  For some reason I thought that the user recourse was fully retrying using normal http://.  If that's not the case, nevermind.  My idea doesn't work.",
          "createdAt": "2020-11-06T23:54:52Z",
          "updatedAt": "2020-11-06T23:54:52Z"
        },
        {
          "author": "tialaramex",
          "authorAssociation": "NONE",
          "body": "@estark37 The research doesn't seem to say anything about 'thisisunsafe' beyond the general observation (which I agree with) that opinionated bypass UI is more effective.\r\n\r\nWe should be clear that this feature *is* documented, but I presume you meant that Chrome/ Chromium teams don't provide that documentation. The result is that users learn about it from third parties possibly *without* accompanying cautions of the consequences. For example I actually don't know if it bypasses WebAuthn restrictions, if a remote HTTPS server has no proof it is mybank.example can I send it working mybank.example credentials anyway now that I've typed a sequence of letters in a language I don't understand following the instructions in this phishing email? Or is that correctly locked out because My Bank has HSTS?\r\n\r\nThe main thing I took away from this research (and similar research I've seen previously) is that we can't hope to achieve universal or even near-universal Comprehension. That is, the user does not in fact know best. But anybody with a young child knows that while comprehension is desirable it's not strictly necessary to safety. A twelve month old does not understand why they shouldn't run towards the open fireplace, but fire guards work anyway. The child does not learn why fires are dangerous, but horrible accidents are prevented.\r\n\r\n@bemasc Thank you for the clarifying title change.",
          "createdAt": "2020-11-07T02:51:53Z",
          "updatedAt": "2020-11-07T02:51:53Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "NONE",
          "body": "@tialaramex yes this research is not about the 'thisisunsafe' bypass specifically; rather, the point is that people do not ignore security warnings categorically, and to the contrary they heed them quite often when they are well-designed.",
          "createdAt": "2020-11-07T04:18:44Z",
          "updatedAt": "2020-11-07T04:19:18Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oops, lost track of this thread at some point. I'm fine switching it to MAY. This whole situation makes me sad, but so it goes.\r\n\r\nIf we do that, I'd suggest we also be clearer as to what it means for a server to send HTTPS DNS records. If the MAY is to allow clients to use fatal errors if they feel they've addressed the non-server-fault cases, we should support that with the server rules. (For the web, something like you must refresh your certs on time and don't intentionally deploy self-signed or otherwise invalid certs.)\r\n\r\nIt also occurs to me that, when HTTPS records are fetched over DoH, the non-server-fault cases are probably already a lost cause. If the cert error is due to bad client clock, captive portal, or misconfigured \"trusted\" MITM, the DoH connection itself will probably fail anyway. By the time a browser has managed to fetch anything over DoH, I think we can more-or-less assume remaining causes are server-fault.\r\n\r\nHTTPS records over Do53 are another matter, of course. There the concerns around non-server-fault causes still apply. (Minus possibly the captive portal one, if the captive portal is hijacking DNS anyway.)",
          "createdAt": "2020-12-03T23:00:32Z",
          "updatedAt": "2020-12-03T23:00:32Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "Feels to me like we've gone beyond the scope of DNSOP with this one.  We're debating basic HTTPS/TLS behavior, which currently allows user recourse.  Making suggestions and writing up security considerations is one thing, but SVCB shouldn't be making requirements (unless necessary for the SVCB interaction) for the HTTPS/TLS connections to behave differently from normal.  If people don't like that TLS allows clients options to continue after cert failures, better to take that up in TLS-related WGs (who could later add a relevant SVCB parameter if they need to make it specifiable through DNS).\r\n\r\nI don't think we're going to get consensus here or stay reasonable to DNSOP scope by doing anything other than making this a MAY and writing up a couple paragraphs in security considerations.",
          "createdAt": "2020-12-04T19:46:53Z",
          "updatedAt": "2020-12-04T19:46:53Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I've updated #274 to reflect the apparent consensus here.  Please review.",
          "createdAt": "2020-12-04T22:02:42Z",
          "updatedAt": "2020-12-04T22:02:42Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "Looks good to me.  @estark37: How is this new language for you?",
          "createdAt": "2020-12-04T22:36:59Z",
          "updatedAt": "2020-12-04T22:36:59Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWU1MzQyMjc4MDQ=",
      "title": "ESNI is not up-to-date with ESNIConfig => ESNIConfigs change",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/88",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We changed the ESNI configuration from a single ESNIConfig to a list of ESNIConfigs in https://github.com/tlswg/draft-ietf-tls-esni/pull/200. HTTPSSVC/SVCB needs to be updated to match.",
      "createdAt": "2019-12-06T19:49:51Z",
      "updatedAt": "2020-05-29T19:52:42Z",
      "closedAt": "2020-05-29T19:52:41Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "See also #127 which may replace the need for this?",
          "createdAt": "2020-04-13T20:59:47Z",
          "updatedAt": "2020-04-13T20:59:47Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "This section has been substantially reworked.",
          "createdAt": "2020-05-29T19:52:41Z",
          "updatedAt": "2020-05-29T19:52:41Z"
        }
      ]
    },
    {
      "number": 90,
      "id": "MDU6SXNzdWU1MzUwOTcwMzE=",
      "title": "WebSockets should use HTTPSSVC",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/90",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "Despite having their own scheme (ws://, wss://), WebSockets should actually use HTTPSSVC.  This has a firm basis on the Fetch spec, which says that [each WebSocket has an equivalent http(s) URL](https://fetch.spec.whatwg.org/#websocket-opening-handshake), but it has come up as a point of confusion so I think it deserves a sentence in the draft.",
      "createdAt": "2019-12-09T18:11:31Z",
      "updatedAt": "2020-06-11T02:22:29Z",
      "closedAt": "2020-06-11T02:22:29Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Should just be a SHOULD",
          "createdAt": "2020-05-29T19:54:15Z",
          "updatedAt": "2020-05-29T19:54:15Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Especially now that we have HTTPS and SVCB, clarify that clients with a wss:// URL SHOULD use the equivalent https-scheme HTTPS record lookup",
          "createdAt": "2020-05-29T19:54:20Z",
          "updatedAt": "2020-05-29T19:54:20Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "MDU6SXNzdWU1Mzc2OTA5NDY=",
      "title": "Does HSTS apply if you fall back to A?",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/91",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc",
        "MikeBishop"
      ],
      "labels": [],
      "body": "We should clarify whether the HSTS implication applies to the fallback IPs, and also clarify that it _does_ apply to AliasForm.",
      "createdAt": "2019-12-13T18:05:22Z",
      "updatedAt": "2020-06-11T14:32:57Z",
      "closedAt": "2020-06-11T14:32:57Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Conclusion: yes, and we need to be explicit about it.",
          "createdAt": "2019-12-13T19:16:09Z",
          "updatedAt": "2019-12-13T19:16:09Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1",
          "createdAt": "2019-12-17T17:15:36Z",
          "updatedAt": "2019-12-17T17:15:36Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Example corner-case to think through as part of this: if something causes you to give up (eg, chain too long) should the HSTS-style behavior still apply?  And in the failure-case regime how long should this behavior change be cached?",
          "createdAt": "2020-05-29T19:57:42Z",
          "updatedAt": "2020-05-29T19:57:42Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think HTTP and HTTPS URLs would trigger the same HTTPSSVC handling logic anyway. If the HSTS behavior is triggered from DNS, the HTTP stack would need to effectively fail the HTTP request and bubble the error up past the HTTP cache to the redirect-handling and URL-dispatching layer (otherwise the URL can't change) to retry the request. Any DNS queries would most likely then be *reissued* for the HTTPS URL, though almost certainly cached.\r\n\r\nThat means that following AliasForms and whatnot doesn't really apply the HSTS flow. As soon as you see an HTTPSSVC record, you can bail. (Real HSTS does not have this oddity because we resolve HSTS before we decide to hit the network or anything.)",
          "createdAt": "2020-05-29T22:09:23Z",
          "updatedAt": "2020-05-29T22:09:55Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "MDU6SXNzdWU1Mzc3MDE1NjQ=",
      "title": "Consider requiring support for SNI",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/92",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "enygren"
      ],
      "labels": [],
      "body": "Clients that do HTTPSSVC should be modern enough to do SNI.",
      "createdAt": "2019-12-13T18:27:47Z",
      "updatedAt": "2020-06-11T16:12:46Z",
      "closedAt": "2020-06-11T03:30:39Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bemasc what is the rationale for this?",
          "createdAt": "2020-06-11T14:38:00Z",
          "updatedAt": "2020-06-11T14:38:00Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood : Same as with the SNI requirement in Alt-Svc and HTTP/2.  Servers must be able to assume that they will have a way to provide the proper server certificate to a client based on either SNI or the inner-SNI in ECH without needing to have an IP address per service endpoint.\r\nOne use-case for HTTPSSVC is to allow the default A/AAAA records to point to a per-certificate-per-cluster virtual IP (limited to a subset of clusters) for legacy client support but where the SvcDomainName points to a name that covers a much broader set of server clusters that support multiplexing via SNI. Almost all clients do support SNI, but we prevent backslide to avoid causing problems with continued growth/scaling of HTTPS adoption. ",
          "createdAt": "2020-06-11T15:26:57Z",
          "updatedAt": "2020-06-11T15:26:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What seems strange (to me) is that HTTPSSVC is purely a DNS artifact, and can (in theory) be used without TLS. As a silly example, imagine we used HTTPSSVC to publish public keys used for a protocol that is *not* TLS. Imagine further that the client consuming one of these records only uses this other fictitious protocol, and doesn't implement TLS. Would this prevent said client from using the record? If so, that seems needlessly prohibitive. Perhaps the text should say that clients using HTTPSSVC records for subsequent TLS connections must support SNI, to be more clear? ",
          "createdAt": "2020-06-11T15:32:07Z",
          "updatedAt": "2020-06-11T15:32:07Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood This requirement only applies to HTTPSSVC, not SVCB, so it's not used for any protocol other than HTTPS, i.e. TLS.  As such, I can't think of a way to encounter the problem you're describing (unless HTTP/4 doesn't use TLS...).",
          "createdAt": "2020-06-11T16:05:38Z",
          "updatedAt": "2020-06-11T16:05:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Got it. That does clarify!",
          "createdAt": "2020-06-11T16:12:45Z",
          "updatedAt": "2020-06-11T16:12:45Z"
        }
      ]
    },
    {
      "number": 95,
      "id": "MDU6SXNzdWU1MzkyMTcwOTI=",
      "title": "Why allow multiple values for the same parameter at all?",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/95",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It seems the only parameters which allow this is ipv4hint and ipv6hint, which is not necessary because the value serialization supports multiple addresses (https://github.com/MikeBishop/dns-alt-svc/pull/94).\r\n\r\nWhy do we need this? I think we should only allow one value per parameter.\r\n\r\nThis means duplicate values can be rejected generically in the parser. Right now the spec says individual parameters silently ignore all but the first value. Silently ignoring things isn't great. Other protocols like Roughtime further require keys be sorted, which makes it easy for the parser to reject duplicates generically.\r\n\r\nThis also avoids questions when designing a new parameter as to whether to use multiple parameter values or to encode multiple structures in the value. We should have one way to do things, so let's use the latter.",
      "createdAt": "2019-12-17T17:45:58Z",
      "updatedAt": "2020-04-13T20:58:58Z",
      "closedAt": "2020-04-13T20:58:58Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "The other argument would be to always do the former (multiple parameter values) in the wireformat and to strongly discourage things from having values that encode multiple structures in the value.  Presentation format multi-value parameters could be syntactic sugar and convert to to multiple parameters on the wire",
          "createdAt": "2019-12-17T17:51:55Z",
          "updatedAt": "2019-12-17T17:51:55Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed that we should be consistent here.\r\n\r\nPresumably ESNIConfig is another use-case?",
          "createdAt": "2019-12-17T17:52:16Z",
          "updatedAt": "2019-12-17T17:52:16Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe HTTPSSVC's ESNI story, as currently specified, does not allow for multiple ESNIConfigs. It doesn't say anything and thus gets the default. This is indeed a mistake, but we're fixing it by doing the multiple values at the TLS level, which lets us handle it consistently at all sources of ESNI config. (See #88.)\r\n\r\nIt's also generally more compact to handle multiplicity within the value. Each HTTPSSVC value costs four bytes of framing per value. If the value is self-delimiting (true for addresses and ESNIConfig), you have a one-time four byte cost from HTTPSSVC, then each additional value costs no extra framing. If the value is not self-delimiting, you need length prefixes internally, costing two bytes per value. That's two bytes extra at one value, breaking even at two values, and a win beyond that.\r\n\r\n(The difference comes from not repeating the parameter name each time.)",
          "createdAt": "2019-12-17T18:38:55Z",
          "updatedAt": "2019-12-17T18:39:47Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@dmcardle FYI",
          "createdAt": "2019-12-18T21:20:11Z",
          "updatedAt": "2019-12-18T21:20:11Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Your argument seems reasonable.  We should make this clear and deterministic especially at the wireformat layer (eg, must only use the first instance of a parameter, provisioning systems should warn on duplicates, etc).\r\n\r\nAllowing syntactic sugar at the presentation layer (eg, concatenation of parameters that are duplicated?) might be helpful usability-wise or could create many more problems and instead we should recommend that provisioning systems prevent this (or at least warn).",
          "createdAt": "2019-12-19T20:56:35Z",
          "updatedAt": "2019-12-19T20:56:35Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with this proposal, but it's going to collide heavily with #97, so I'd prefer to get that settled before updating the text.  I have updated #97 to make transport names easier to delimit.",
          "createdAt": "2020-01-15T19:00:27Z",
          "updatedAt": "2020-01-15T19:00:27Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "NONE",
          "body": "Could we revisit this? Given the current state of #97, it looks like it is expecting that multiple values are allowed, e.g. `transport=foo transport=bar no-default-transport`. \r\n\r\nEquivalently, the wire format could simply encode a length-prefixed sequence of protocol IDs, eliminating the need for repeated SvcParamKeys. A slight annoyance is that the protocol IDs don't have fixed lengths. We could (1) invent uint16 values in our registry, (2) add length prefixes to each protocol ID, or (3) use null terminators.",
          "createdAt": "2020-01-31T16:22:48Z",
          "updatedAt": "2020-01-31T16:22:48Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think I've lost track of what \"this\" is and what is being revisited where. :-) I think the encoding should be:\r\n\r\n* You only get one parameter per key, with one value.\r\n* As is already the case, that value has whatever internal format it needs. That internal format may be a single structure, a list of structures, or something more complicated.\r\n* Duplicate parameters are a syntax error. The receiver treats this as a parse error.\r\n* Keys must be listed in ascending order, so the receiver can check for duplicates without maintaining much state. Non-sorted keys are a parse error.\r\n\r\nRe protocol IDs not having fixed lengths, just add length prefixes as needed. That's all a multi-valued parameter is doing anyway. (I don't think we should use NUL-termination. That sort of thing is prone to injection problems. See also all the problems when things get stuck into C-style strings.)\r\n\r\n(I still need to review #97, but I doubt a `vector<transport>` would work anyway given that you need a port number. If it ends up being a `vector<tuple<transport, port>>` or a different design, that further suggests a key-specific serialization. A `vector<tuple<transport, port>>` needs a length prefix on the transport, not on the overall tuple.)",
          "createdAt": "2020-01-31T17:30:54Z",
          "updatedAt": "2020-01-31T17:30:54Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we pretty much have consensus on this encoding.\r\n\r\nSince #97 is a major semantic change, I'd like to get it finalized and merged before we make this syntax change.\r\n\r\nRegarding ports, the current plan is to have a single fixed port number for each SvcFieldValue, even if it has multiple transports.  This port number applies to all transports.  Endpoints with different port numbers will only be representable as separate RRs within the RRSet.  I'm not aware of a use case that would motivate putting multiple port numbers in one RR.",
          "createdAt": "2020-02-03T17:26:57Z",
          "updatedAt": "2020-02-03T17:26:57Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "This has been incorporated.",
          "createdAt": "2020-04-13T20:58:58Z",
          "updatedAt": "2020-04-13T20:58:58Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "MDU6SXNzdWU1MzkyNDk2ODc=",
      "title": "Require sorted order of SvcFieldParams?",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/96",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The order of the SvcFieldParams is not meaningful.  Should we require (and enforce?) that they appear in key order?  This makes serialization more annoying to implement, but also removes a source of entropy that could be used to fingerprint authoritative implementations.",
      "createdAt": "2019-12-17T18:54:50Z",
      "updatedAt": "2020-05-29T20:01:19Z",
      "closedAt": "2020-05-29T20:00:11Z",
      "comments": [
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "no.   they should be easy to sort when they arrive, yes? \r\n",
          "createdAt": "2020-04-20T23:02:42Z",
          "updatedAt": "2020-04-20T23:02:42Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "Done.",
          "createdAt": "2020-05-29T20:00:11Z",
          "updatedAt": "2020-05-29T20:00:11Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed in #109 ",
          "createdAt": "2020-05-29T20:01:19Z",
          "updatedAt": "2020-05-29T20:01:19Z"
        }
      ]
    },
    {
      "number": 98,
      "id": "MDU6SXNzdWU1NDM5OTI3Njg=",
      "title": "Explicitly state semantics of SvcParamKey ranges",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/98",
      "state": "CLOSED",
      "author": "dmcardle",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Can we nail down the semantics of the different SvcParamKey ranges?\r\n\r\nTo start with:\r\n\r\n* Reserved => FAIL_PARSE\r\n* PrivateUse => EXTRACT_OR_SKIP\r\n* ALPN | PORT | ESNICONFIG | ... => EXTRACT_OR_SKIP\r\n\r\nI can't see any reason why we should accept records that contain reserved keys.",
      "createdAt": "2019-12-30T19:53:34Z",
      "updatedAt": "2020-05-29T20:01:00Z",
      "closedAt": "2020-05-29T20:00:56Z",
      "comments": [
        {
          "author": "dmcardle",
          "authorAssociation": "NONE",
          "body": "@davidben ",
          "createdAt": "2019-12-30T19:53:54Z",
          "updatedAt": "2019-12-30T19:53:54Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Usually private use stuff isn't treated different from other unknown keys since it's just a way for folks to allocate things without going through the registries. Not sure what the reserved ones are for. I guess `key0` is so people can conveniently use zero for a nullable `SvcParamKey`. Was `key5` just used in an earlier iteration of the draft? In that case, we probably want to treat it as unknown since it's just a marker to not allocate it.",
          "createdAt": "2019-12-30T22:22:12Z",
          "updatedAt": "2019-12-30T22:22:12Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "NONE",
          "body": "As best as I can tell, key5 is there so that ipv4=4 and ipv6=6!\r\n\r\nCan you expand on nullable SvcParamKey? Seems you could just omit the SvcParam entirely in that situation.",
          "createdAt": "2019-12-30T23:09:56Z",
          "updatedAt": "2019-12-30T23:09:56Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just mean that if you're writing some function that wants to return a `std::optional<SvcParamKey>` or `Option<SvcParamKey>` or `SvcParamKey?` or whatever but your language doesn't have a convenient way to express option types, you can just return a `uint16_t` and have zero be the null value. :-)",
          "createdAt": "2019-12-30T23:26:32Z",
          "updatedAt": "2019-12-30T23:26:32Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "\"Reserved\" doesn't really mean \"disallowed\", exactly.  It's more like \"not yet allocated\".  Parsers can't generally reject reserved values, because they could have been allocated after the code was written.\r\n\r\nI like the idea of clarifying that zero is \"permanently reserved\" for the use @davidben described.  Maybe we can call it \"null\" or something...",
          "createdAt": "2020-01-02T16:49:12Z",
          "updatedAt": "2020-01-02T16:49:12Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "NONE",
          "body": "OK, I'm not entirely sure I get the distinction.\r\n\r\nI figured the unmentioned key values (7..65279) were the \"not yet allocated\" keys, and that the \"reserved\" keys (0, 5, 65535) were permanently reserved.\r\n\r\nAre you saying that \"reserved\" lies somewhere between \"permanently reserved\" (never to be used) and \"not yet allocated\"?\r\n\r\nI think it's worth explicitly describing what to do with each *type* of key.  My instinct was to reject records that contain reserved keys, since they must be nonsense :stuck_out_tongue:.",
          "createdAt": "2020-01-02T17:00:53Z",
          "updatedAt": "2020-01-02T17:00:53Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, we should improve the table to avoid this ambiguity.",
          "createdAt": "2020-01-02T17:03:23Z",
          "updatedAt": "2020-01-02T17:03:23Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW I don't have a preference either way about whether we reserve zero like that. That was me attempting to divine what it was reserved for. If it's a new idea to you, apparently I was wrong! :-)",
          "createdAt": "2020-01-02T17:20:24Z",
          "updatedAt": "2020-01-02T17:20:24Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would advocate not having random permanently reserved values that parsers are meant to reject though. That's more fuss for no benefit. If we want zero to be null, that's a reason, but key5 has no reason to be special.\r\n\r\nPerhaps just delete the key5 row? Then it's the same as the remaining unassigned range.",
          "createdAt": "2020-01-02T17:27:38Z",
          "updatedAt": "2020-01-02T17:27:38Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "NONE",
          "body": "Agreed, fewer rules is better. I'd support squashing key5.\r\n\r\nWhat's the rationale for key65535 being reserved?\r\n",
          "createdAt": "2020-01-02T17:42:33Z",
          "updatedAt": "2020-01-02T17:42:33Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "Closing in favor of #154.",
          "createdAt": "2020-05-29T20:00:56Z",
          "updatedAt": "2020-05-29T20:00:56Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "See also #154 which may be worth addressing at the same time.",
          "createdAt": "2020-05-29T20:01:00Z",
          "updatedAt": "2020-05-29T20:01:00Z"
        }
      ]
    },
    {
      "number": 99,
      "id": "MDU6SXNzdWU1NDY5MzM5MDU=",
      "title": "Clarify Alias wire format and motivation for binary SvcFieldValue encoding",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/99",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "proposed to close"
      ],
      "body": "@miekg has asked for two related clarifications:\r\n1. How is it that the AliasForm and ServiceForm encodings are compatible?\r\n2. Why not reuse the TXT/SPF format?",
      "createdAt": "2020-01-08T15:30:04Z",
      "updatedAt": "2020-06-18T03:27:51Z",
      "closedAt": "2020-06-18T03:27:51Z",
      "comments": [
        {
          "author": "miekg",
          "authorAssociation": "NONE",
          "body": "If this is previously discussed I am happy to read those emails.\r\n\r\nRe 1.: the text in the 01 draft is unclear to me that these two encoding (as proposed) are in fact identical.\r\n\r\nRe 2.: Easiest for us is to just re-use the TXT encoding, the draft talks about limit length (255 octets) per txt segment, which is true, but the total size can still be more than that. Downside is that parsing of the key, values must be done by the client, instead of the DNS client. But things like \\DDD are supported within TXT as well.\r\n\r\nSee https://github.com/miekg/dns/issues/1064 for our bug to add this.",
          "createdAt": "2020-01-12T13:25:38Z",
          "updatedAt": "2020-01-12T13:25:38Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "This has been extensively discussed in the WG.  Can we close this?",
          "createdAt": "2020-06-11T02:52:16Z",
          "updatedAt": "2020-06-11T02:52:16Z"
        }
      ]
    },
    {
      "number": 100,
      "id": "MDU6SXNzdWU1NDk4NjQyNTc=",
      "title": "Parameter to indicate no HSTS-like behavior?",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/100",
      "state": "OPEN",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "future draft"
      ],
      "body": "In digging into production use-cases, there may be scenarios where the \"HTTPSSVC means HTTPS-only\" is problematic.  For example, it may prevent a CDN from turning it on by default (as this means forcing everything to HTTPS-by-default which may not be possible for some customer content) which in-turns prevents turning on Encrypted SNI by default.\r\n\r\nLeaving the HSTS-like behavior as the default makes sense, but this asks the question as to whether an optional \"allow-insecure\" parameter should be included (with the default still being secure).  This opens up cans of worms from a security perspective but could ease deployment in some cases.",
      "createdAt": "2020-01-14T22:51:00Z",
      "updatedAt": "2020-07-13T17:33:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I think I understand the problem.  If a CDN has N customers who have CNAMEd their domains to a CDN domain, and some of those customers are using insecure HTTP and haven't provided the CDN with TLS certificates, then the CDN can't put HTTPSSVC on the domain.  They would have to create a new, HTTPS-only domain, and ask customers to update their CNAME.\r\n\r\nTechnically, the CDN could acquire DV certs for all the customer domains, and upgrade them to HTTPS (at least between the client and CDN), but this could cause problems related to mixed-content blocking, if some of those customer domains load third-party insecure content that isn't hosted on the same CDN.\r\n\r\nI think I would call this parameter \"disable-https-upgrade\", and continue to prohibit the \"_http\" prefix.",
          "createdAt": "2020-01-15T17:29:14Z",
          "updatedAt": "2020-01-15T17:29:14Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Such a CDN would then cause all N customers to go through the `allow-insecure` path, right? That means the customers who don't update their CNAME would inadvertently get a less secure configuration, so one would still want everyone to update CNAMEs, but now with decreased incentive (but correspondingly more adoption of other bits of HTTPSSVC, so it's a tradeoff between adoption and getting the ecosystem in a better place).",
          "createdAt": "2020-01-16T00:48:12Z",
          "updatedAt": "2020-01-16T00:48:12Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Given that it is 2020 and HTTPS is table stakes, I'm inclined to think this would not be the right tradeoff.",
          "createdAt": "2020-01-16T00:50:15Z",
          "updatedAt": "2020-01-16T00:50:15Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Possible compromise: `disable-https-upgrade` only applies if `echconfig` is also present.  This is extremely hacky and I'm not sure I really like it, but it would ensure that this is only used in cases where HTTPSSVC is actually providing some benefit to someone.",
          "createdAt": "2020-05-29T20:15:08Z",
          "updatedAt": "2020-05-29T20:15:08Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What David said.  I don't see any point in continuing to cater to unsecured protocols.\r\n\r\nIn the earlier example Ben provided, the CNAME that the mix of secure and insecure customers refer to doesn't need to be singular.  You don't need new servers, just a separate CNAME target.  That seems entirely workable.",
          "createdAt": "2020-06-23T09:06:40Z",
          "updatedAt": "2020-06-23T09:06:40Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed. If you want a bad mix of security, that's your burden for deployment.",
          "createdAt": "2020-06-23T16:25:49Z",
          "updatedAt": "2020-06-23T16:25:49Z"
        }
      ]
    },
    {
      "number": 101,
      "id": "MDU6SXNzdWU1NTAyNDU2MzQ=",
      "title": "Include Alt-Used example",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/101",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "enygren"
      ],
      "labels": [],
      "body": "It would be good to include an example for Alt-Used (or mention it in a previous example).\r\n\r\nThe {client-behavior} reference is also broken.",
      "createdAt": "2020-01-15T15:10:24Z",
      "updatedAt": "2020-04-13T20:58:14Z",
      "closedAt": "2020-04-13T20:58:14Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "WONTFIX (alternative is #107)",
          "createdAt": "2020-04-13T20:58:14Z",
          "updatedAt": "2020-04-13T20:58:14Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWU1NTA5NzU2ODY=",
      "title": "Expand SERVFAIL handling to prevent ESNI DoS",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/103",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "The HSTS section currently says\r\n> If the HTTPSSVC query results in a SERVFAIL error, and the connection between the client and the recursive resolver is cryptographically protected (e.g. using TLS {{!RFC7858}} or HTTPS {{!RFC8484}}), the client SHOULD abandon the connection attempt and display an error message.\r\n\r\nThis is meant to defend against DoS on the recursive-authoritative leg, when the zone is DNSSEC-signed and the recursive is validating.\r\n\r\nWe should generalize this defense to include timeouts and transport errors, not just explicit SERVFAIL, and move it out of the HSTS section, because (1) this DoS also applies to ESNI, not just HTTPS-upgrade, and (2) an attacker might be able to mount this attack on the client-recursive leg by selectively dropping DNS query or response packets (e.g. only dropping the largest responses, so the client gets the A record but not the HTTPSSVC record).",
      "createdAt": "2020-01-16T18:21:01Z",
      "updatedAt": "2020-01-27T21:08:45Z",
      "closedAt": "2020-01-27T21:08:45Z",
      "comments": []
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWU1NTEwNzE1NDY=",
      "title": "ESNI lifetime implications from Alt-Svc vs HTTPSSVC precedence",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/105",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The draft originally said (prior to #66) said the Alt-Svc cache overrides HTTPSSVC. This had problems (issue #58 and #60), so #66 downgraded it to a MAY. It seems this still has problems.\r\n\r\n**HTTPSSVC vs Alt-Svc**\r\n\r\nConsider a server which uses both QUIC and ESNI. It configures both in HTTPSSVC. It also cares about HTTPSSVC-less clients (older client or legacy DNS resolver), so it configures QUIC in Alt-Svc. Is it required to configure ESNI in Alt-Svc, or can it leave things alone (with the understanding that ESNI will be limited to clients that support HTTPSSVC)?\r\n\r\nThe spec currently says a client (that would otherwise support HTTPSSVC) MAY skip an HTTPSSVC lookup given an Alt-Svc cache entry. That means, for ESNI to work, the server MUST configure it in both. This is not obvious and should be written down. More importantly, it has deployment consequences.\r\n\r\nHTTPSSVC records apply to the *current* HTTP request. If the client has no cached DNS record, it still queries DNS and gets HTTPSSVC. That means HTTPSSVC TTLs may be set more-or-less freely depending on the site's performance vs. flexibility needs. Let's say it's O(1 hour).\r\n\r\nAlt-Svc headers apply to *subsequent* HTTP requests. If the client has no Alt-Svc entry cached, it will send the HTTP request without Alt-Svc. That means Alt-Svc TTLs must cover the time to the next HTTP request for Alt-Svc to be used at all. For reference, I see google.com currently uses 30 days.\r\n\r\n**Commitments**\r\n\r\nFor the duration of the HTTPSSVC or Alt-Svc lifetime, the server operator has made a commitment to the client. ESNI is a soft commitment that the server understands this ESNI key and a hard commitment that the server is colocated with the public name. The first lower-bounds key lifetime and rotation on the server. There is a recovery mechanism, but it is expensive, so this is a soft commitment. The second is roughly a commitment to use a particular hosting provider. ESNI's retry mechanism requires the public name, so this is a hard commitment. Breaking this will knock out your site.\r\n\r\n(Note Alt-Svc without ESNI was *not* a hosting provider commitment. A provider-specific Alt-Svc may fail if the site changes providers, but the client could still connect without Alt-Svc. ESNI must take this fallback away to prevent network downgrade.)\r\n\r\nHTTPSSVC and Alt-Svc commitment timescales are qualitatively different. Saying ESNI servers must advertise in both, as implied by the spec today, means servers must incur a long-lived hosting provider commitment to deploy ESNI at all. (Or send no Alt-Svc headers and lose QUIC on non-HTTPSSVC clients.) It also means ESNI keys must be long-lived, which makes them more sensitive.\r\n\r\n**Proposed fix**\r\n\r\nGiven the above, I don't see how allowing Alt-Svc to override HTTPSSVC is tenable. That suggests changing the spec so a client that makes HTTPSSVC queries makes them even if Alt-Svc is available. If it gets an HTTPSSVC record, it ignores Alt-Svc and uses those instead. Otherwise, it may freely use Alt-Svc.\r\n\r\nThis is fussy because Alt-Svc itself allows replacing the origin hostname with an alternate name. Clients would likely want to query the alternate's A/AAAA records, the origin's A/AAAA records, and the origin/s HTTPSSVC records in parallel. However, the alternate may leak ESNI, so the alternate connection must wait for whether HTTPSSVC aborts it before proceeding past that query.\r\n\r\nThat adds *even more* complexity to the prospect of actually implementing remote Alt-Svc. Personally, I think all these name indirections are seeming more and more like a mistake and questionably worthwhile.\r\n\r\n**Whither ESNI in Alt-Svc?**\r\n\r\nWith the above, it is no longer strictly necessary to allocate a way to spell ESNI in Alt-Svc. I don't know whether we still want to. This issue means ESNI in Alt-Svc is very different from ESNI in HTTPSSVC. At minimum, we must clearly call out the implications of the longer lifetime in the spec. We could decide this is not worth the trouble. On the other hand, it's likely a number of clients won't make HTTPSSVC queries for some time, and perhaps those clients getting ESNI for the subset of servers willing to make a longer-term public name commitment is worthwhile.\r\n\r\n**Parting thought**\r\n\r\nI think a lesson here is we cannot completely abstract ESNI from its delivery mechanism. Pulling ESNI into HTTPSSVC is reasonable so we only have one record to query, but HTTPSSVC's decisions still have implications for ESNI. (@chris-wood, I dunno if you watch this repo, so CC'ing you in here explicitly.)",
      "createdAt": "2020-01-16T21:40:43Z",
      "updatedAt": "2020-05-29T20:28:57Z",
      "closedAt": "2020-05-29T20:28:56Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The proposed fix does have an inverse consequence which is that Alt-Svc is *more* trustworthy than HTTPSSVC because it came from the origin. That makes overriding it odd. For everything currently delivered over Alt-Svc and HTTPSSVC, this is fine, but we are effectively constraining Alt-Svc to never depend on this trustworthiness in the future. (I.e. it can only be used for DNS-like things.)\r\n\r\nThis is hopefully fine because we can always make a new header (and probably should given all of the mistakes in Alt-Svc), but this is an implication to keep in mind.",
          "createdAt": "2020-01-16T22:30:09Z",
          "updatedAt": "2020-01-16T22:30:09Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for thinking through all these problems, @davidben.  I've posted a PR (#106) that provides a fully detailed set of requirements for the interaction here.  I think this PR gets us to a solution that makes sensible configurations fully downgrade-resistant, avoids pathologies when transitioning between hosting providers, and also covers all the use cases we're aware of.  It continues to allow the behavior you're describing (HTTPSSVC having precedence).\r\n\r\nI admit it's complex, but that's mostly because it's trying to describe a variety of potential client implementations.  I think the behavior of any specific client isn't really more complicated, just better specified.",
          "createdAt": "2020-01-21T19:49:10Z",
          "updatedAt": "2020-01-21T19:49:10Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Using HTTPSSVC to repair Alt-Svc errors rather than checking them ahead of time is an interesting idea, but it does not address the problem for clients that cannot make HTTPSSVC queries. Indeed the PR notes:\r\n\r\n> If the client does not support HTTPSSVC, it MUST fail the connection to avoid enabling a downgrade attack.\r\n\r\nThat means a server still cannot put ESNI in Alt-Svc without long-term commitment about their hosting provider. While the PR does claim Alt-Svc is unnecessary:\r\n\r\n> Origins MAY use esniconfig in Alt-Svc, HTTPSSVC, both, or neither\r\n\r\nThis is false. Saying it will break sporadically doesn't change the fact that it's broken. It also isn't sporadic: it will deterministicly break for all but the first connection. That does not count as deploying ESNI.\r\n\r\nThe section \"Non-authoritative servers\" needs to go in ESNI with full TLSWG analysis as it has security consequences for both the client and server and affects TLS itself. As to those security consequences, I do not think we should do this. Extracting an authenticated signal out of explicitly getting a bad certificate is *extremely* questionable. Certificate errors may arise from all kinds of reasons. Overloading that would be a problem for a client implementation.\r\n\r\nAdditionally, the text mandates particular behavior on unknown names. Given the subtle problems that come up when HTTP servers accept unknown Host headers, I don't think we should introduce such requirements, certainly not via an implicit signal like this.\r\n\r\nThis also still assumes the previous hosting provider behaves in a particular way.\r\n\r\nFinally, this is far too much complexity on the client. Please use the *much* simpler solution outlined above.",
          "createdAt": "2020-01-22T07:30:37Z",
          "updatedAt": "2020-01-22T07:30:37Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "A trivial \"HTTPSSVC first\" implementation would forfeit resistance to downgrade attacks by DNS intermediaries, which I think is valuable.  However, I appreciate that the authenticated fallback proposal requires some unusual layer-crossing, and represents some kind of shift in the long-term commitment (although you already rely on your old host not to serve 404s with your cert).\r\n\r\nI've updated #106 with a much shorter proposal that no longer discusses authenticated fallback.  It allows a simple client like you seem to be advocating for (HTTPSSVC first, no esniconfig in Alt-Svc), but also specifies how to do Alt-Svc in esniconfig safely, with a big warning label.",
          "createdAt": "2020-01-22T21:37:55Z",
          "updatedAt": "2020-01-22T21:37:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I\u2019d opt for @davidben\u2019s proposal, perhaps even with the additional condition that Alt-Svc not be a permissible vehicle for ESNIConfig values. The fact that these hang around for weeks at a time seems to encourage poor key management hygiene. ",
          "createdAt": "2020-01-23T01:57:27Z",
          "updatedAt": "2020-01-23T01:57:27Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I have concerns about any approach where HTTPSSVC without ESNI takes precedence over Alt-Svc ESNI.  That arrangement creates an incentive for hostile DNS servers to synthesize fake HTTPSSVC records, in order to override the ESNIConfig received in Alt-Svc.\r\n\r\nWe can certainly abandon ESNIConfig in Alt-Svc, but I think the loss is significant, and not to be done lightly.  Insofar as HTTPSSVC depends on encrypted DNS (as major clients seem likely to require), the vast majority of users will not be able to use it for the foreseeable future.  Alt-Svc ESNI is the only near-term path to broad deployment, and broad deployment is important to avoid ossification.\r\n\r\nNote that Alt-Svc ESNI is not HPKP.  The ESNI fallback mechanism allows key rotation, so long as the fallback name doesn't change.  Yes, for good performance you shouldn't set your Alt-Svc lifetime longer than your key rotation period, but occasional clock skews or unscheduled rotations won't break anything.\r\n\r\nAs for lifetimes, ESNI keys are substantially less sensitive than TLS keys, so requiring them to be rotated ultra-frequently seems like a low priority.  Typical TLS certificates last for 90 days.  A similar or shorter lifetime for ESNI keys would easily be compatible with Alt-Svc ESNI.",
          "createdAt": "2020-01-23T19:25:54Z",
          "updatedAt": "2020-01-23T19:25:54Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Would it make sense to consider the Alt-Svc TTL as part of priorities here?  (ie, some platforms use Alt-Svc TTLs in the range of an hour.)  \r\n\r\nNote that Alt-Svc and ESNI don't work well together unless clients honor alternate server DNS names separate from the hostname.  (ie, otherwise the same multi-server/multi-CDN issue shows up for Alt-Svc ESN.)  And in that model it is saner anyways to bound the TTL to something reasonable.  But reasonably short TTLs mostly make sense if clients honor Alt-Svc going to alternate servernames anyways as you want some degree of agility on these.\r\n\r\n(One good use-case would be opportunistically supporting ESNI with QUIC prior to being ready to support it in TLS and before clients support doing HTTPSSVC lookups.)",
          "createdAt": "2020-01-24T14:17:15Z",
          "updatedAt": "2020-01-24T14:17:15Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I have concerns about any approach where HTTPSSVC without ESNI takes precedence over Alt-Svc ESNI. That arrangement creates an incentive for hostile DNS servers to synthesize fake HTTPSSVC records, in order to override the ESNIConfig received in Alt-Svc.\r\n\r\nIt's certainly true that tying ESNI to DNS has consequences given a hostile DNS server. Both that and the dependency on new DNS records (which effectively depends on DoH) are indeed disappointing. But both properties have been true throughout this iteration of ESNI. We switched to the HTTPSSVC record on the assumption that it was equivalent to the original ESNI record. The Alt-Svc flaw breaks that assumption.\r\n\r\nIf we want to solve the hostile DNS server problem, we would need to get rid of all Alt-Svc failure paths on the client. The hostile DNS server also controls A/AAAA records, so it could blackhole `alt-svc-entrypoint.cdn.example` and cause all Alt-Svc routes to fail. (If we punt that problem and try only to solve the broad deployment problem, an Alt-Svc to HTTPSSVC fallback is tenable, though it alone doesn't solve the name pinning problem.)\r\n\r\nUnless we can make ESNI in Alt-Svc truly equivalent to HTTPSSVC (unlikely given the TTL), it *must* be possible for servers to use HTTPSSVC with ESNI, use Alt-Svc without ESNI, and *still* get ESNI support for clients which support both. That means HTTPSSVC *must* be able to override Alt-Svc.\r\n\r\nIf we can come up with a way to salvage ESNI in Alt-Svc, we can always add some Alt-Svc directive that means this configuration cannot be overridden by HTTPSSVC. (This, of course, would still need to meet all the usual deployability and availability requirements.) We'd also still need to backport all of the ALPN-related fixes or general Alt-Svc support is dead in the water. All of the issues raised in #73 apply to Alt-Svc once ESNI shows up.\r\n\r\n> As for lifetimes, ESNI keys are substantially less sensitive than TLS keys, so requiring them to be rotated ultra-frequently seems like a low priority. Typical TLS certificates last for 90 days. A similar or shorter lifetime for ESNI keys would easily be compatible with Alt-Svc ESNI.\r\n\r\nI agree they're less sensitive. I'm more concerned about the name pinning than the key rotation.\r\n\r\nA footnote on the equivalence to TLS keys however: 90 days is still too long for TLS certificates (the world needs to move to issuance automation). Also, as long-lived keys are fundamentally more sensitive than short-lived keys, server deployments apply extra protections to their long-lived keys like keeping them off of serving frontends. If ESNI keys, due to their lifetime, end up warranting such protections, it would double the cost of such measures.\r\n\r\n> But reasonably short TTLs mostly make sense if clients honor Alt-Svc going to alternate servernames anyways as you want some degree of agility on these.\r\n\r\nCertainly switching the names increases the desire for shorter TTLs, but that doesn't change the nature of Alt-Svc. Alt-Svc fundamentally only applies to *subsequent* connections, so the lifetime must extend to the *next* time you visit the site. (The current visit already has a preexisting connection. Even in clients willing to bear the complexity of cycling to new connection instantly, this is not useful for ossification purposes because blocking the alternate has no availability consequences while the main connection lives.)\r\n\r\nThe requirements on large enough Alt-Svc TTLs get stronger with ESNI. If you only use Alt-Svc as a routing optimization, perhaps you're fine with low Alt-Svc coverage as it's just an optimization. An ESNI-bearing Alt-Svc with small TTL barely applies.\r\n\r\n> (One good use-case would be opportunistically supporting ESNI with QUIC prior to being ready to support it in TLS and before clients support doing HTTPSSVC lookups.)\r\n\r\nThis use case doesn't make sense. Remember that clients will always try TCP. We often say \"fallback\", but this is misleading. One of the failure modes is blackholed packets, so the two are actually run in parallel, so doing this will deterministically leak the SNI.\r\n\r\nIndeed the one of the requirements on any fix to the many Alt-Svc ALPN mistakes is to *prevent* this, so that servers do not accidentally deploy a QUIC-only ESNI. Out-of-band signal => fallback for robustness => failing to provide equivalent security is a server configuration error.",
          "createdAt": "2020-01-24T15:14:19Z",
          "updatedAt": "2020-01-24T15:14:19Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe #106 specified the behavior you're requesting here, so I'm closing this (as fixed).",
          "createdAt": "2020-05-29T20:28:56Z",
          "updatedAt": "2020-05-29T20:28:56Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "MDU6SXNzdWU1NTQ4NTg1MDM=",
      "title": "Consider SVCB-Used header",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/107",
      "state": "OPEN",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "future draft"
      ],
      "body": "If decoupling from Alt-Svc, having an alternative to Alt-Used would be valuable.  This should take lessons from challenges with Alt-Used adoption and should minimize the privacy impact.\r\nSome options include:\r\n1) Send SvcDomainName \r\n2) Send SvcFieldPriority\r\n3) Send an (8? 16?) bit value specified in a new parameter\r\n4) Send a variable number of bits from a value specified in a new parameter.  (ie, client can zero-out as many MSB as it would like)\r\n\r\nI'm leaning towards (3) above as this bounds the amount of additional entropy to be significantly less than what could be done already by using an alternate port number or IP(v4/v6) address but still allows some level of signalling without requiring servers to have to go through the complexity of needing to use distinct ports/IPs (or ESNI key IDs), all of which are possible but which leak more to passive adversaries.\r\n",
      "createdAt": "2020-01-24T17:19:40Z",
      "updatedAt": "2020-07-09T21:16:17Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why does the server need this information when it already knows the IP the client connected to?",
          "createdAt": "2020-01-24T22:11:46Z",
          "updatedAt": "2020-01-24T22:11:46Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "It would be preferable to not have to burn IPv4 for this, plus this channel would only ever be sent encrypted in HTTPS requests whereas other options (different IPs, information in echconfig such as the public SNI or keyid) are all much worse in-terms of leaking information to passive network observers.\r\n\r\nIs there a version of this that browsers/clients would be willing to implement?  (ie, 1 bit?  4 bits? 8 bits? the SvcDomainName? an arbitrary string to avoid a privacy-theatre perspective?)",
          "createdAt": "2020-05-29T20:26:51Z",
          "updatedAt": "2020-05-29T20:27:18Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Proposed to defer this to a future draft (and perhaps as part of an alt-svc-bis).",
          "createdAt": "2020-07-09T21:16:17Z",
          "updatedAt": "2020-07-09T21:16:17Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "MDU6SXNzdWU1NjkwNzk1OTA=",
      "title": "Define default port when unspecified for _port records",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/111",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "We should reconsider the default port for:\r\n\r\n   _8443._foo.api.example.com. 7200 IN HTTPS 0 svc4.example.net.\r\n   svc4.example.net.  7200  IN HTTPS 3 . transport=\"tls\"\r\n\r\nie, where no port is specified.  In particular, should the port be 8443 (specified for the scheme) or 443 (default for https+transport).\r\nUsing the port from the scheme (8443) when no port is specified may be less confusing.\r\n",
      "createdAt": "2020-02-21T17:13:38Z",
      "updatedAt": "2020-06-11T02:14:01Z",
      "closedAt": "2020-06-11T02:14:01Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed and agreed that \"preserve weird ports\" as the default is cleaner and we should clarify (updating as-needed).",
          "createdAt": "2020-05-29T20:29:41Z",
          "updatedAt": "2020-05-29T20:29:41Z"
        }
      ]
    },
    {
      "number": 112,
      "id": "MDU6SXNzdWU1NzAxNTQ5NzQ=",
      "title": "Consider making transports into individual SvcParamKeys",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/112",
      "state": "CLOSED",
      "author": "ericorth",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Instead of an \"alpn\" or \"transports\" list, perhaps each transport should be its own SvcParamKey.  Then the transport is considered supported for a record if the parameter appears in the SvcFieldValue parameter list for the record.  Maybe h1/TLS is still considered supported by default unless there's a parameter saying to not use defaults.\r\n\r\nAdvantages:\r\n- Negates the recent debates over a wire format for the transport list.  Transports are now listed in the main SvcFieldValue parameters list using the wire format established for that list.  No need to decide between delimiter separation or length prefixing for a special sub-list.  No need to create a separate string list or value registry for the transport values, as it will just be entries from the SvcParamKey registry.  The parameters will be just as easy to deal with as any other parameters for people dealing with presentation format or text config files.\r\n- Solves recent debates over potential per-transport sub parameters such as port.  Instead of a single \"port\" parameter or encoding port in transport name, transports can allocate bytes to port in the SvcFieldValue value.  This would likely be the only thing in the value for transports defined by the initial RFC, maybe with a value of 0 meaning to use the port from the qname.  Any transports added in the future could define whatever sub parameters make sense for that new transport type (or remove port entirely if non-default ports are disallowed for the new transport).\r\n- Extensibility is consistent with the primary extensibility mechanism for SVCB, that is that adding new transports or changing sub parameters format means adding to the SvcParamKey registry.  New registry additions would have all the extensible flexibility as anything else added that way.",
      "createdAt": "2020-02-24T21:22:47Z",
      "updatedAt": "2020-05-29T20:31:30Z",
      "closedAt": "2020-05-29T20:31:30Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "That's an interesting proposal, and I agree with the advantages you've identified.  However, it does also have some disadvantages.\r\n* Each new protocol is allocated from a finite numeric space, so draft protocol versions during development probably can't be expressed in this form.  (We do have a private range reserved in the registry, which might suffice, but conflicts in the private space could also lead to bad outcomes, especially if parsers reject the whole RRSet when there's a conflict.)\r\n* Adding a new transport would require updating all the DNS-related components (authoritative and stub).  With \"transport=...\" new transports are opaque to the DNS-related components, so no updates are required.  (This can be hacked around using the `key1234` mechanism on the authoritative and possibly some escape hatch in SVCB client libraries, but it's ugly as heck.)\r\n* Sharing a namespace with all the other keys could be confusing.\r\n* If we want to add more sub-parameters to a transport later (e.g. QUIC versions), we likely can't, because its SvcParamValue format will already be fixed.\r\n\r\nTo match the current draft's behavior, we would need to define \"quic\", \"tls\", and \"no-tls\" keys.  However, I'm not sure that these keys actually make sense outside the context of a specific scheme (like HTTPS).  For example, can we really use the same \"tls\" key for all the different application-protocols that might be delivered over TLS?\r\n\r\n> maybe with a value of 0 meaning to use the port from the qname\r\n\r\nI would signal that using an empty SvcParamValue, and make \"0\" mean \"disabled\".  This would allow us to replace \"no-tls\" with \"tls=0\".\r\n\r\nOverall, I'm neutral on this change.  I'd be more inclined to support it if we decided to make the SvcFieldValue a string-keyed map (CBOR!), but that's a much bigger change.",
          "createdAt": "2020-02-24T22:32:11Z",
          "updatedAt": "2020-02-24T22:32:11Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "Regarding difficulty adding new transports or changing sub-parameters, I would say that adding a new key (or a replacement key in the case of changing the value format to add new sub parameters) to the registry and updating things to handle it is the appropriate bar of difficulty.  We don't expect to need completely new protocols very often, and the extensibility is appropriate for the rare occasions when it will happen.  Yes, it leads to private space conflict issues for experimental new transports/versions, which is not ideal, but I would argue that anything with unregistered values is going to have pains to work around (eg unregistered names means adding a new one, development or final, still has to ensure you have a unique name without conflict).",
          "createdAt": "2020-02-24T23:29:46Z",
          "updatedAt": "2020-02-24T23:29:46Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "After thinking this through a bit more, I think if we have any concerns over transport extensibility using SvcParamKeys, since this is SVCB's main extensibility mechanism and transports don't seem to be something that will need to change more frequently than anything else, that this points to a more general issue with extensibility of SvcParamKeys.  Opened issue #113 to discuss that point.",
          "createdAt": "2020-02-27T21:38:02Z",
          "updatedAt": "2020-02-27T21:38:02Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Some of this is a matter of getting DNS zone management software updated, as well as updating any software that needs to translate from presentation to/from wire form.  Having some bar there is unavoidable with any binary format (although CBOR continues to be vaguely attractive and was my first proposal, but is a big change).  But keeping transport as a list of strings seems cleaner.\r\n\r\nI continue to think we may wish to make transport a tightly constrained token (eg, /^[0-9a-z-]{1,8}$/ or similar) to avoid the mess ALPN creates. \r\n",
          "createdAt": "2020-02-27T22:30:30Z",
          "updatedAt": "2020-02-27T22:30:30Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue is obsolete, since we have switched to conveying ALPN (and specified that it is essentially advisory, with clients and servers still performing full ALPN negotiation via TLS).",
          "createdAt": "2020-05-29T20:31:30Z",
          "updatedAt": "2020-05-29T20:31:30Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "MDU6SXNzdWU1NzIzNzQ0MjU=",
      "title": "2 octet SvcParamKey may not be extensible enough",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/113",
      "state": "CLOSED",
      "author": "ericorth",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Inspired by the conversation in issue #112: If we're concerned about the ability to add and experiment with new transports if using SvcParamKey, that may mean SvcParamKey just has a more general issue because I wouldn't expect the transports to require change particularly more often than anything else.\r\n\r\nAt issue, it seems 1 octet worth of code points for \"private use\" may not be sufficient for experimentation with new fields (or new transports if we make transports into top-level fields).  Too much chance of conflict with other uncontrolled usage of the private use block.  Seems we wouldn't really be able to use the block at all for experimental new stuff unless we constantly grease with random values from that range and the spec encourages wonky practices like always checking for a checksum in the value to ensure it's actually the param type the client is looking for.  And 2 octets is probably not enough availability overall to let anybody claim large chunks in the registered blocks for multiple experimental code points.\r\n\r\nI suggest we increase to 4 octets, make the unregistered block much larger to reduce the chances of conflicts, and encourage temporary registration of experimental parameters.  Feels to me that 4 octets would be worth it for the main extensibility mechanism of SVCB.  We'd also be able to save a bit of those octets back when params like the EsniConfig could more reasonably create new parameters for new versions instead of spending octets to do versioning within the parameter value as is the current plan.",
      "createdAt": "2020-02-27T21:35:52Z",
      "updatedAt": "2020-05-29T19:44:11Z",
      "closedAt": "2020-05-29T19:44:10Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "One funny thing about going to 4-byte IDs is that it makes a straight encoding markedly less efficient than CBOR.\r\n\r\nI think we should try hard to avoid having separate ESNIConfig SvcParamKeys for different versions, because it would greatly complicate the interface between TLS and DNS (e.g. between OpenSSL and BIND).",
          "createdAt": "2020-03-03T23:13:59Z",
          "updatedAt": "2020-03-03T23:13:59Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "We should leave it at 2 octets and not go crazy.  We can always do an extended SvcParamKey type some year if this ever becomes an issue.\r\n\r\nUsing different SvcParamKeys for different versions is also going to slow roll-out due to the need to get those into more vendors (eg, DNS providers).",
          "createdAt": "2020-03-04T21:38:45Z",
          "updatedAt": "2020-03-04T21:38:45Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #154",
          "createdAt": "2020-05-29T19:44:10Z",
          "updatedAt": "2020-05-29T19:44:10Z"
        }
      ]
    },
    {
      "number": 115,
      "id": "MDU6SXNzdWU1NzU4MDIzMDU=",
      "title": "Consider switching back to ALPN",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/115",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on some feedback from @martinthomson we should consider switching back to ALPN rather than introducing \"transport\".  As part of this we'd want to clarify that:\r\n1) ALPN defines the whole stack  (eg, \"H2-over-TLS-over-TCP\" )\r\n2) The alpn thus implicitly specifies a transport protocol but also allows filtering of higher-level protocols (ie, to allow doh and dot on different endpoints).\r\n3) Secure in-band negotiation takes precedence, so if the alpn negotiated is different from one indicated in the record then the client MUST use it.\r\n\r\nWe'd then switch from having a default transport protocol to a default alpn (eg, \"http/1.1\" for HTTPSSVC) and have no-default-alpn as a param.",
      "createdAt": "2020-03-04T21:43:57Z",
      "updatedAt": "2020-05-29T20:30:55Z",
      "closedAt": "2020-05-29T20:30:54Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "Done in #116.",
          "createdAt": "2020-05-29T20:30:54Z",
          "updatedAt": "2020-05-29T20:30:54Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "MDU6SXNzdWU1NzgxNDc0MzA=",
      "title": "Clarify how clients select between multiple alpns in a set",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/117",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wontfix"
      ],
      "body": "It is ambiguous how a client selects which transport to use if multiple are provided in a set, all of which the client supports.  For example with:\r\n   alpn=h3,h2\r\nor:\r\n   alpn=h2,h3\r\n(with the implicit http/1.1).\r\n\r\nSince we don't want to make this a list, the best way to handle this may be to specify that clients should apply their own heuristics for selecting which underlying transport (eg, TLS or QUIC) to try connecting with first as well as whether to try racing to both.\r\n\r\nOperators wishing to force an ordering should then use different SVCB records at different priority levels.",
      "createdAt": "2020-03-09T19:42:57Z",
      "updatedAt": "2020-05-29T20:32:56Z",
      "closedAt": "2020-05-29T20:32:31Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ordering isn't necessarily a well-defined notion. Chrome doesn't try QUIC and then TCP. We race the two. (A network which is intolerant to QUIC may simply drop the packet and appear like a QUIC timeout.)",
          "createdAt": "2020-03-12T22:29:27Z",
          "updatedAt": "2020-03-12T22:29:27Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Won't fix for now.",
          "createdAt": "2020-05-29T20:32:31Z",
          "updatedAt": "2020-05-29T20:32:31Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "Client heuristics are sufficient.",
          "createdAt": "2020-05-29T20:32:56Z",
          "updatedAt": "2020-05-29T20:32:56Z"
        }
      ]
    },
    {
      "number": 120,
      "id": "MDU6SXNzdWU1NzgyMzgwNTc=",
      "title": "basic-visible vs line continuation in master files",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/120",
      "state": "CLOSED",
      "author": "marka63",
      "authorAssociation": "NONE",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "basic-visible fails to exclude 0x28  '('   and 0x29  ')' which are line continuation characters in master files.\r\n\r\nfoo=(1)  will parse as \"foo=\", \"1\" in master files.   For it to be a single token it needs to be foo=\"(1)\" or foo=\\\\(1\\\\) ",
      "createdAt": "2020-03-09T23:00:38Z",
      "updatedAt": "2020-06-11T14:37:30Z",
      "closedAt": "2020-06-11T14:37:30Z",
      "comments": []
    },
    {
      "number": 121,
      "id": "MDU6SXNzdWU1NzgyMzk5NzA=",
      "title": "Invalid HTTPSSVC example",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/121",
      "state": "CLOSED",
      "author": "marka63",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "www.example.com.  7200  IN HTTPSSVC svc.example.net.\r\n\r\nis not a valid record.",
      "createdAt": "2020-03-09T23:06:38Z",
      "updatedAt": "2020-04-13T20:48:01Z",
      "closedAt": "2020-04-13T20:48:01Z",
      "comments": []
    },
    {
      "number": 122,
      "id": "MDU6SXNzdWU1NzgyNjg1OTg=",
      "title": "Improve description of QNAME structure",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/122",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Currently, the QNAME structure is described as a _port._scheme.domain, except \"mappings for SVCB MAY remove the port\".  This is potentially confusing.  We should align the terminology with the URI (URL?) RFCs, and discuss ports only in the context of HTTPS.\r\n\r\n> section 1.1 \r\n> \r\n> \u00a0_8765._baz.api.example.com. 7200 IN SVCB 0 svc4-baz.example.net.\r\n> \u00a0\r\n> \r\n> In my opinion, the mechanism that derives QNAME needs to be refined or maybe\r\n> the terminology being clarified. \r\n> \r\n> a) The current document describes how to generate the QNAME from an URI. The\r\n> QNAME contains a port number while some scheme do not allow or specify port\r\n> subcomponent. Not having the port specified could be particularly useful to\r\n> provide secure transport for schemes that are not necessarily secure for\r\n> example. One the other hand, a scheme that specify a port, may not necessarily\r\n> need to have it specified twined in the QNAME. I would be rather inclined to\r\n> have the port optional maybe at the expense of an additional RRset, but need\r\n> more thoughts. \u00a0\r\n> \u00a0 \r\n> b) It is also unclear to me why HTTPS:443 or HTTP:80 has a specific convention.\r\n> The convention tales place for the DNS resolution of a authority as opposed to\r\n> the DNS resolution of a FQDN. One possible reason I see could would be to\r\n> prevent having a distinction between http and https (which could be done\r\n> otherwise for example using alpn), \u00a0but I am wondering if there are other\r\n> rationale. So far, I do not see the need for a exception for the derivation of\r\n> the QNAME (nor for using a specific RRtype). \u00a0 \u00a0\r\n> \r\n> c) The current document, mentions several time HTTP service. The term service\r\n> seems to me ambiguous as it has been defined for the DNS service based\r\n> discovery in which case it means a web page. It seems to me preferable we keep\r\n> the scope of URI scheme and port authority. As a side note, when scheme is\r\n> thought as a service, the convention adopted by the document slightly differs\r\n> from the DNS based service Discovery which would use _baz._udp or eventually\r\n> _baz._tcp. The current approach may be simpler.. I would think this is mostly a\r\n> terminology issue. \u00a0\r\n>\r\n> section 2.3 \r\n> \r\n> \"\"\"\r\n> Protocol mappings for SVCB MAY remove the port or replace it with\r\n> \u00a0 \u00a0other protocol-specific information, but MUST retain the scheme in\r\n> \u00a0 \u00a0the QNAME. \u00a0\r\n> \"\"\"\r\n> \r\n> I understand that for any scheme, a definition of how scheme and port should be\r\n> defined when using SVBC. If that is correct, I would rather see that the other\r\n> way around, that is SVBC defining from the scheme definition the QNAME\r\n> derivation. The term MAY also suggest different interpretation will be\r\n> permitted, which could affect interoperability. \r\n> ",
      "createdAt": "2020-03-10T00:44:54Z",
      "updatedAt": "2020-06-11T02:14:52Z",
      "closedAt": "2020-06-11T02:14:51Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in #157",
          "createdAt": "2020-06-11T02:14:51Z",
          "updatedAt": "2020-06-11T02:14:51Z"
        }
      ]
    },
    {
      "number": 123,
      "id": "MDU6SXNzdWU1NzgyNzM0MjM=",
      "title": "CNAME interaction clarification",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/123",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [
        "editorial"
      ],
      "body": "SVCB doesn't change anything about CNAME, or really have any interesting interaction with CNAME, but it's mentioned all over the text.  We might be able to simplify this.\r\n\r\n> \"\"\"\r\n> When a prior CNAME or SVCB record has aliased to an SVCB record, each\r\n> \u00a0 \u00a0RR shall be returned under its own owner name.\r\n> \"\"\"\r\n> \r\n> If I am not misinterpreting this, this seems to be the natural way CNAME works\r\n> and I am wondering if the text should not be removed from this section. My\r\n> general comment is that the text refers too much to CNAME. Probably only the\r\n> fall back function of CNAME should be mentioned in the main text and other\r\n> considerations may be moved to the appendix to ease the reading. This is\r\n> obviously just a comment. \r\n> \r\n\r\n> \"\"\"\r\n> \u00a0Note that the SVCB record's owner name MAY be the canonical name of a\r\n> \u00a0 \u00a0CNAME record, and the SvcDomainName MAY be the owner of a CNAME\r\n> \u00a0 \u00a0record.\u00a0 Clients and recursive resolvers MUST follow CNAMEs as\r\n> \u00a0 \u00a0normal.\r\n> \"\"\" \r\n> \r\n> I am not sure this is should be mentioned in the main part of the document and\r\n> maybe annex would be more appropriated. \r\n> ",
      "createdAt": "2020-03-10T01:04:12Z",
      "updatedAt": "2020-07-13T20:26:01Z",
      "closedAt": "2020-07-13T20:26:01Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Also, a reader requested clarification that the alias form does not redirect queries for any other QTYPEs (unlike CNAME).",
          "createdAt": "2020-04-10T18:56:24Z",
          "updatedAt": "2020-04-10T18:56:24Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Resolved by #209",
          "createdAt": "2020-07-13T20:25:54Z",
          "updatedAt": "2020-07-13T20:25:54Z"
        }
      ]
    },
    {
      "number": 124,
      "id": "MDU6SXNzdWU1NzgyNzQ4NTE=",
      "title": "Clarify non-HTTPS example",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/124",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "This example currently fuses two different zone files.  We can make it clearer that they are separate by adding a comment line above each RR.\r\n\r\n> \"\"\"\r\n> \u00a0As an example:\r\n> \r\n> \u00a0 \u00a0_8443._foo.api.example.com. 7200 IN SVCB 0 svc4.example.net.\r\n> \u00a0 \u00a0svc4..example.net. \u00a07200 \u00a0IN SVCB 3 ( svc4.example.net. alpn=\"bar\"\r\n> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 port=\"8004\" esniconfig=\"...\" )\r\n> \"\"\"\r\n> \r\n> While many examples are useful for the understanding, they often provide the\r\n> impression RRsets are in the same zone file. I am wondering if that would not\r\n> be clarifying to show and mention zone files are different. Note this is just a\r\n> feed back and your ar efree to ignore it. ",
      "createdAt": "2020-03-10T01:09:54Z",
      "updatedAt": "2020-04-13T20:56:50Z",
      "closedAt": "2020-04-13T20:56:50Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Merged PR #129 ",
          "createdAt": "2020-04-13T20:56:50Z",
          "updatedAt": "2020-04-13T20:56:50Z"
        }
      ]
    },
    {
      "number": 125,
      "id": "MDU6SXNzdWU1NzgyNzUwMTk=",
      "title": "Justify keeping AliasForm and ServiceForm in one RR type, or split them into two",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/125",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "We've gotten multiple comments asking why AliasForm and ServiceForm aren't separate RR types.  From a recursive resolver's perspective, this would simplify the processing logic.  However, it would also result in double the QPS for everyone, since clients would have to fire off simultaneous queries for _both_ Qtypes.\r\n\r\n> It seems strange to me to have a single RRset type associated to different\r\n> functionalities, i.e. Alias and Service. I suspect that it is more convenient\r\n> to have the same RRtype while requesting among different administrative\r\n> domains, but I would be happy to know the rationals for this design. I have the\r\n> impression that alias form is used to indicates the next RRtype (in our case,\r\n> SVCB) while service form indicates a terminal request. \u00a0 \u00a0 ",
      "createdAt": "2020-03-10T01:10:34Z",
      "updatedAt": "2020-04-13T20:56:32Z",
      "closedAt": "2020-04-13T20:56:31Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "We should make sure this rationale described in the appendix and then close this as WONTFIX.",
          "createdAt": "2020-03-10T01:13:06Z",
          "updatedAt": "2020-03-10T01:13:06Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, I think it's worse than double.  A client, not knowing whether its recursive will perform special-case handling of these queries, has to issue both queries immediately.  A recursive, upon seeing a ServiceForm query, would itself have to issue both ServiceForm and AliasForm queries, both at this point in the chain and subsequently at every point down the chain.  So it somewhat more than doubles the load of the whole design, and the recursive behavior is possibly even more complex.",
          "createdAt": "2020-03-10T01:14:47Z",
          "updatedAt": "2020-03-10T01:14:47Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Added a justification in PR #128 ",
          "createdAt": "2020-04-13T20:56:31Z",
          "updatedAt": "2020-04-13T20:56:31Z"
        }
      ]
    },
    {
      "number": 130,
      "id": "MDU6SXNzdWU1OTU3Mzk2OTI=",
      "title": "Unrecognized keys in presentation format",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/130",
      "state": "CLOSED",
      "author": "DesWurstes",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> Unrecognized keys are represented in presentation format as\r\n   \"keyNNNNN\" where NNNNN is the numeric value of the key type without\r\n   leading zeros.  In presentation format, values of unrecognized keys\r\n   SHALL be represented in wire format, using decimal escape codes (e.g.\r\n   \\255) when necessary.\r\n\r\nIsn't this self-contradictory?",
      "createdAt": "2020-04-07T09:50:17Z",
      "updatedAt": "2020-04-07T17:07:28Z",
      "closedAt": "2020-04-07T17:07:15Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "The intent is that, if you encountered (e.g.) the \"alpn\" key but didn't have support for it, you would present it as\r\n\r\n    key1=\\008http/1.1\r\n\r\nThe text is attempting to distinguish between \"unrecognized keys\" and \"value of unrecognized keys\".  If that's not clear, we can change the text -- suggestions welcome.",
          "createdAt": "2020-04-07T12:28:57Z",
          "updatedAt": "2020-04-07T12:28:57Z"
        },
        {
          "author": "DesWurstes",
          "authorAssociation": "NONE",
          "body": "Thanks! Maybe it needs distinction between numerical values of keys and their corresponding values.",
          "createdAt": "2020-04-07T12:36:09Z",
          "updatedAt": "2020-04-07T17:07:28Z"
        }
      ]
    },
    {
      "number": 132,
      "id": "MDU6SXNzdWU1OTk2MTQ0OTc=",
      "title": "Clarify how ALPN interacts with ECHO",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/132",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "With Encrypted Client Hello there is an ALPN on both the outer (exposed) and the inner (encrypted).  We should clarify how this interacts with the alpn= attribute.",
      "createdAt": "2020-04-14T14:25:46Z",
      "updatedAt": "2020-05-29T20:38:08Z",
      "closedAt": "2020-05-29T20:38:08Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "See related on ESNI/ECHO:  https://github.com/tlswg/draft-ietf-tls-esni/issues/216 ",
          "createdAt": "2020-04-14T14:30:11Z",
          "updatedAt": "2020-04-14T14:30:11Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "There are a couple of concepts implicated here:\r\n\r\n- What does the server advertise that it speaks?  That's the content of the SVCB record.  Note that this cannot be private information, since anyone could retrieve the DNS record.\r\n- What does the client want to admit that it speaks / is planning to speak?  That's the content of the public ClientHello.\r\n- What does the client actually want to speak?  That's the content of the encrypted ClientHello.\r\n\r\nIn most situations I can think of, it's the client that wants to conceal that it's using a particular protocol (e.g. a VPN tunnel), and so client policy would dictate when the public/private ALPN tokens differ.  Put something innocuous in the public ALPN extension, or even omit it.\r\n\r\nIf the server wants to conceal that it speaks a particular protocol, DNS is not the place to publish that information.  There might be value in a mechanism for the server to advertise \"secret\" ALPN tokens that it supports for the client's future use in encrypted ClientHellos, but I don't think SVCB is the venue for that.  It would need to be something it can provide only to already-authenticated clients -- perhaps something it could attach to an NST?  But regardless, out of this document's scope.",
          "createdAt": "2020-04-14T14:37:14Z",
          "updatedAt": "2020-04-14T14:39:33Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "\nHiya,\n\nOn 14/04/2020 15:37, Mike Bishop wrote:\n> There are a couple of concepts implicated here:\n> \n> - What does the server advertise that it speaks?  That's the content of the SVCB record.  Note that this cannot be private information, since anyone could retrieve the DNS record.\n> - What does the client want to admit that it speaks / is planning to speak?  That's the content of the public ClientHello.\n> - What does the client actually want to speak?  That's the content of the encrypted ClientHello.\n> \n\nThere's also an additional part - a server might be telling\nclients how to better not stick out or how to get interop\nif some other common choice might cause failures. I doubt\nwe can know for sure how to treat those for now.\n\n> In most situations I can think of, it's the client that wants to conceal that it's using a particular protocol (e.g. a VPN tunnel), and so client policy would dictate when the public/private ALPN tokens differ.  Put something innocuous in the public ALPN extension, or even omit it.\n> \n\nI doubt many clients will have such a rich policy. I'd\nexpect that client implementers will just pick something.\n\nI think the minimum we need to do is to say that\nHTTPSSVC.alpn is to be used in inner CH if ECHO is being\nused. It might also make sense to define a public_alpn\nfield either in ECHOConfig or HTTPSSVC and to then say\nthat if only one of those is present, then the same\nvalue SHOULD be used in inner and outer and if both are\npresent, then clients SHOULD follow what the server\nsaid. (And if we do do that, I'd argue to have the\npublic_alpn in the same structure as the public_name,\nwhether that's ECHOConfig or HTTPSSVC.)\n\n> If the server wants to conceal that it speaks a particular protocol, DNS is not the place to publish that information.\n\nWell... that same logic would call ESNI/ECHO into question\nentirely wouldn't it? So I don't find the argument below\nconvincing.\n\nS\n\n>  There might be value in a mechanism for the server to advertise \"secret\" ALPN tokens that it supports for the client's future use in encrypted ClientHellos, but I don't think SVCB is the venue for that.  It would need to be something it can provide only to already-authenticated clients -- perhaps something it could attack to an NST?\n> \n\n\n",
          "createdAt": "2020-04-14T15:02:40Z",
          "updatedAt": "2020-04-14T15:02:40Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "> > If the server wants to conceal that it speaks a particular protocol, DNS is not the place to publish that information.\r\n>\r\n> Well... that same logic would call ESNI/ECHO into question entirely wouldn't it? So I don't find the argument below convincing.\r\n\r\nNo, it wouldn't; the ESNI/ECHO keys are inherently public information.  They can (and should) be widely disseminated.  The fact that a server supports ECHO is similarly not private.  If you're assuming that the server's set of supported protocols *is* private information, then you need a private way to distribute that information.  ECHO, of course, only permits the transfer of private information from client to server.\r\n\r\nThat said, I don't object to ECHOConfig suggesting innocuous settings for other properties for use on the public side if the TLS WG wants to do that.  (@davidben makes a good point that the public name is less for innocuous value and more for delegating the authority to change config, though.)  I think that's orthogonal to SVCB telling you what the service supports and how to access it.",
          "createdAt": "2020-04-14T18:46:59Z",
          "updatedAt": "2020-04-14T18:47:09Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think discussion about which ALPN to use in TLS makes sense HTTPSSVC, except in so far as clarifying that the thing HTTPSSVC calls ALPN gets little to no on influence the TLS ALPN decision. (I.e. we must revert the Alt-Svc original sin.)\r\n\r\nBeyond that, for ECHO's semantics, the answer is clear: the inner ClientHello is the actual ClientHello. The client should put in the ALPN parameters it actually wants to negotiate. The outer ClientHello is to authenticate a key mismatch signal, so negotiated parameters only matter up to authenticating that signal. Thus, ECHO has opinions on the outer name because it selects the authenticating certificate. The outer ALPN doesn't seem very important.\r\n\r\nEither way, whether you got your ECHO config from HTTPSSVC or some hypothetical other channel, those same considerations hold, so any decisions here belong in ECHO, not HTTPSSVC.",
          "createdAt": "2020-04-14T20:36:44Z",
          "updatedAt": "2020-04-14T20:36:44Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Since it's been mentioned a few times, I want to clarify that the SVCB \"alpn=\" field does _not_ tell the client what to put in its ALPN field, at least not directly.  It tells the client about what ALPNs the _server_ supports, so that the client can choose transports that will work.  As the text (currently) notes\r\n\r\n> Clients SHOULD also include any other values that they support and could negotiate on that connection with equivalent or better security properties. For example, if the ALPN set only contains \"http/1.1\", the client could include \"http/1.1\" and \"h2\" in the ProtocolNameList.\r\n\r\nI agree that this text is talking about the inner ClientHello, and we need to make that clear in the drafts.",
          "createdAt": "2020-04-15T03:09:25Z",
          "updatedAt": "2020-04-15T03:09:25Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Is what we have there now good enough?\r\n(Or do we also want to mention ALPN on the outer?\r\nThe echo draft has:\r\n\r\n> It then constructs a new ClientHello (ClientHelloOuter) with an innocuous SNI\r\n>    (and potentially innocuous versions of other extensions such as ALPN\r\n>    [RFC7301]) and containing the encrypted ClientHelloInner as an\r\n>    extension.",
          "createdAt": "2020-05-14T02:50:19Z",
          "updatedAt": "2020-05-14T02:50:19Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "Addressed as part of #148.",
          "createdAt": "2020-05-29T20:38:05Z",
          "updatedAt": "2020-05-29T20:38:05Z"
        }
      ]
    },
    {
      "number": 133,
      "id": "MDU6SXNzdWU1OTk2MTQ5NDE=",
      "title": "Clarify Client DNS failure behaviour",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/133",
      "state": "CLOSED",
      "author": "fl1ger",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "question"
      ],
      "body": "Moin!\r\n\r\nReading the draft again in preparation for the dnsop interim I was confused by the Client behavior/Handling resolution failures section.\r\n\r\nThe client behaviour says that A/AAAA and SVCB/HTTPSVC should be run in parallel and the failure case says that if SVCB fails the client should not use A/AAAA. It think what we want here is that if the initial parallel query fails use A/AAAA as a lot of DNS devices fail in various forms when queried something not A/AAAA and the ENT or NXDomain handling also is questionable for a lot of DNS servers. \r\n\r\nIf the initial SVCB lookup give you something to follow you should fail on the final resolution, but not on the initial lookup as it will cause to much collateral damage.\r\n\r\nSo long\r\n-Ralf\r\n",
      "createdAt": "2020-04-14T14:26:19Z",
      "updatedAt": "2020-07-11T21:38:54Z",
      "closedAt": "2020-07-11T21:38:54Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's the full text\r\n>If an SVCB query results in a SERVFAIL error, transport error, or timeout, and DNS exchanges between the client and the recursive resolver are cryptographically protected (e.g. using TLS [RFC7858] or HTTPS [RFC8484]), the client MUST NOT fall back to non-SVCB connection establishment. This ensures that an active attacker cannot mount a downgrade attack by denying the user access to the SVCB information.\r\n\r\n> A SERVFAIL error can occur if the domain is DNSSEC-signed, the recursive resolver is DNSSEC-validating, and the attacker is between the recursive resolver and the authoritative DNS server. A transport error or timeout can occur if an active attacker between the client and the recursive resolver is selectively dropping SVCB queries or responses, based on their size or other observable patterns.\r\n\r\n> Similarly, if the client enforces DNSSEC validation on A/AAAA responses, it MUST NOT fall back to non-SVCB connection establishment if the SVCB response fails to validate.\r\n\r\nNote that these requirements are all restricted to DoT, DoH, or validating-stub.  I think this should exclude the buggy devices you're describing.  Also, I don't think we have a choice.  As the text notes, a less strict policy would open a downgrade attack on ECHO.",
          "createdAt": "2020-04-14T14:42:23Z",
          "updatedAt": "2020-04-14T14:42:23Z"
        },
        {
          "author": "fl1ger",
          "authorAssociation": "NONE",
          "body": "Ben when the authority SERVFAIL/NXDOMAIN/Timeouts for the SVCB question of the resolver the resolver has and will give back SERVFAIL or NXDomain. It does not matter if the stub connects over DoH, DoT or  regular DNS. What will the client do in that case?\r\n\r\n",
          "createdAt": "2020-04-14T14:48:26Z",
          "updatedAt": "2020-04-14T14:48:26Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "NXDOMAIN is fine, but SERVFAIL or timeout->SERVFAIL currently cannot be tolerated, and the client will not be able to access the domain until the buggy authoritative is fixed.  Suggestions welcome!",
          "createdAt": "2020-04-14T16:46:38Z",
          "updatedAt": "2020-04-14T16:46:38Z"
        },
        {
          "author": "fl1ger",
          "authorAssociation": "NONE",
          "body": "NXDOMAIN is not fine. NXDOMAIN for example.com SVCB means that example.com does not exists. The correct answer is Noerror/NOData. I have seen domains not responding properly to new qtypes (e.g AAAA/NS) more often than I wished. If we want to go down that way we at least have to put a warning sign in the text as sites will break if we see SERVFAIL or NXDOMAIN of SVCB request as a downgrade attack.",
          "createdAt": "2020-04-16T13:27:47Z",
          "updatedAt": "2020-04-16T13:27:47Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "I believe the primary security concern here is around a network attacker blocking some of the messages to try to prevent just the HTTPSSVC result and trick A/AAAA into being used without ESNI.  Thus clients need to be careful with anything that could have been the result of such an attack.\r\n\r\nNXDOMAIN, should in theory be sufficient for the client to trust that there really is not an HTTPSSVC result, whether because the domain doesn't exist or because an existing domain doesn't have HTTPSSVC and something is responding improperly.  Either way, it should be safe for the client to fallback to A/AAAA on receiving NXDOMAIN (or NOERROR/NODATA).  Compare to SERVFAIL which could signify that a resolver failed to get a result from upstream, which could be the result of a network attacker.\r\n\r\nOr is your concern that it may be too common for incorrectly-implemented resolvers to return NXDOMAIN in cases where an attacker is blocking things?",
          "createdAt": "2020-04-16T15:09:23Z",
          "updatedAt": "2020-04-16T15:09:23Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, @ericorth explained it better.  Returning NXDOMAIN is a bug, but the resulting user-visible behavior is fine.  It's SERVFAIL or timeout that would really be a problem.\r\n\r\nIf SERVFAIL turns out to be a real issue, implementors may be forced to back off slightly, e.g. by showing a click-through warning.  I tend to think that those behaviors don't need to be standardized, but feel free to suggest text.",
          "createdAt": "2020-04-16T18:32:27Z",
          "updatedAt": "2020-04-16T18:32:27Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "It would be good to do an experiment as to how many of the Alexa/Umbrella top-N names return NXDOMAIN rather NODATA for a SVCB query (but return a valid A or AAAA or CNAME response).  Even if a bug, if too common it could impact deployability.  Some authorities certainly had this bug in the early days of AAAA existence (and some may still do so).",
          "createdAt": "2020-04-16T19:06:56Z",
          "updatedAt": "2020-04-16T19:06:56Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@dmcardle I think this is one of the questions your experiment was looking to answer.",
          "createdAt": "2020-04-16T23:34:01Z",
          "updatedAt": "2020-04-16T23:34:01Z"
        },
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "It doesn't help when IESG members think that blocking DNS types is good security practice.\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/dnsop/BQwfAlTgqQf0X7HCFWE0ashFApU/\r\n\r\nThe following tool is already setup for bulk testing of known and unknown types (genreport -t).\r\n\r\nhttps://gitlab.isc.org/isc-projects/DNS-Compliance-Testing",
          "createdAt": "2020-04-17T01:13:53Z",
          "updatedAt": "2020-04-17T01:13:53Z"
        },
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "Note Alexa/Umbrella lists have a higher proportion of F5 servers some of which are misconfigured.\r\n",
          "createdAt": "2020-04-17T01:16:05Z",
          "updatedAt": "2020-04-17T01:16:05Z"
        },
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "And Google's servers return NOTIMP for unknown types.  Microsoft's outlook servers also return NOTIMP.  Unknown types outside of the reserver meta range are supposed to be treated as opaque blobs which RFC compliant server should return NOERROR or NXDOMAIN for depending upon whether the name exists or not.",
          "createdAt": "2020-04-17T08:31:10Z",
          "updatedAt": "2020-04-17T08:31:10Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "NONE",
          "body": "@enygren We're currently working on a [Chrome experiment](https://docs.google.com/document/u/1/d/14eCqVyT_3MSj7ydqNFl1Yl0yg1fs6g24qmYUUdi5V-k/edit) to measure how an arbitrary new record type propagates through the DNS ecosystem.",
          "createdAt": "2020-04-17T14:57:48Z",
          "updatedAt": "2020-04-17T14:57:48Z"
        },
        {
          "author": "fl1ger",
          "authorAssociation": "NONE",
          "body": "@dmcardle this experiment only checks the behaviour of recursive resolvers. \r\n\r\nMy concern is that authorities (of which we have a lot more) will answer incorrect and the poor resolver has to give back the client that incorrect answer. This will happen and as we know it we should maybe describe that if we want to be strict about that. What about:\r\n...\r\nThis ensures that an active attacker\r\n   cannot mount a downgrade attack by denying the user access to the\r\n   SVCB information.\r\n\"SERVFAIL answers potentially also can happen when the authoritative name server for a domain is broken or non standards compliant, e.g if it sends SERVFAIL, NXDOMAIN or NOTIMP back to the resolver instead of the correct empty response for an RRType it does not know or has no data for.\"\r\n\r\n",
          "createdAt": "2020-04-19T08:03:36Z",
          "updatedAt": "2020-04-19T08:03:36Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Could the experiment not query the experiment-domain directly as part of the test?  ",
          "createdAt": "2020-04-19T17:28:02Z",
          "updatedAt": "2020-04-19T17:28:02Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@fl1ger Are you saying that the recursive will convert NXDOMAIN or NOTIMP to SERVFAIL?  I've never heard of that.",
          "createdAt": "2020-04-19T18:29:11Z",
          "updatedAt": "2020-04-19T18:29:11Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe the concern is that authorities may return SERVFAIL or NXDOMAIN for SVCB (rather than NODATA NOERROR) for names with valid A/AAAA/CNAME records so treating this as a hard-fail rather than fallback will DoS these sites.\r\n\r\nOne approach would be to convert the \"MUST\" to a \"SHOULD\" with guidance that a downgrade attack may be possible between the recursive and authority, and that client authors may use the results of future research to determine when it is safe to enforce this behavior.",
          "createdAt": "2020-04-19T20:20:54Z",
          "updatedAt": "2020-04-19T20:20:54Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We may want to separate the error cases then. IIRC, the original feedback here was that an attacker between the client and recursive could try to recognize which packets contained SVCB vs A/AAAA (the responses are vastly different sizes) and drop one. Especially since they go on HTTP/3 streams, it's quite likely an attacker can cause problems here. This leg is, I think, mostly concerned with timeouts and transport errors.\r\n\r\n#104, however, generalized it to all kinds of errors. Hardening the error-handling is nice, but given the concerns around deployment risk, that was perhaps too large of a change.",
          "createdAt": "2020-04-19T20:34:59Z",
          "updatedAt": "2020-04-19T20:37:14Z"
        },
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "In reality there is one or two vendors holding the whole industry to ransom due to their negligence. \r\nLets not be held to ransom and actually say MUST NOT proceed to make a connection unless the SVCB returns a NOERROR response.  Vendors can fix this in under 24 hours as I have seen them do it that fast in the past multiple times.  Vendors can issue advisories to their clients that they should upgrade.\r\n\r\nRFC 1034 and RFC 1035 has the server returning SERVFAIL if it couldn't LOAD the master file (e.g. because it didn't implement a type present in the master file) and returning NOERROR or NXDOMAIN if the zone file loaded.\r\n\r\nRFC3597 further reinforced this by saying all type code other than the meta range (RFC2929) are to be treated as opaque blobs and providing a presentation format for unknown record types.\r\n\r\nWe also have draft-ietf-dnsop-no-response-issue-23 in the RFC editor queue pointing out the mis use of NOTIMP.\r\n\r\nGoogle have already indicated they they will fix their servers as a matter of urgency.  Google acknowledges that they correct rcodes are NOERROR or NXDOMAIN and not NOTIMP.  Microsoft have committed to fix their corporate authoritative servers as part of deploying TLSA support.   AFAIK the implementation in Windows is fine.",
          "createdAt": "2020-04-19T21:33:34Z",
          "updatedAt": "2020-04-19T21:33:34Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "Clients are very risk averse when it comes to making changes that could break accessing internet sites that worked fine (from the user perspective) before the change.  Ignoring what would have been perfectly good A/AAAA results because an SVCB returned NXDOMAIN or NOTIMP would be a tough sell.  The case would have to be made either that it is vital for safe functioning of SVCB queries (as is the case with timeout and maybe SERVFAIL) or that it would not currently be a significant issue and nothing would break.\r\n\r\nEven with timeout/SERVFAIL, while we're optimistic it'll be acceptable to treat those as fatal, there's enough skepticism to have started the experiments dmcardle mentioned above.",
          "createdAt": "2020-04-20T16:24:46Z",
          "updatedAt": "2020-04-20T16:24:46Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "We've adjusted the failure behavior requirements to give clients more leeway, and be more explicit about the rationale, in #210.",
          "createdAt": "2020-07-11T21:38:54Z",
          "updatedAt": "2020-07-11T21:38:54Z"
        }
      ]
    },
    {
      "number": 134,
      "id": "MDU6SXNzdWU1OTk2MTYyMzU=",
      "title": "Add warning about using non-default ports",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/134",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Paul Vixie recommends we add a warning that operators should avoid using non-default ports for general Internet use.  Non-default ports may be firewalled in client networks, so may appear to work in testing but may not work for some clients/users.",
      "createdAt": "2020-04-14T14:28:04Z",
      "updatedAt": "2020-05-13T03:53:50Z",
      "closedAt": "2020-05-13T03:53:50Z",
      "comments": []
    },
    {
      "number": 135,
      "id": "MDU6SXNzdWU2MDM1NDMxNzY=",
      "title": "Consider reordering examples",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/135",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, the examples come before the formal definition of the RR type.  It might be sensible to move them after instead.",
      "createdAt": "2020-04-20T21:20:50Z",
      "updatedAt": "2020-05-14T02:43:19Z",
      "closedAt": "2020-05-14T02:43:19Z",
      "comments": [
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1",
          "createdAt": "2020-04-20T22:29:44Z",
          "updatedAt": "2020-04-20T22:29:44Z"
        }
      ]
    },
    {
      "number": 136,
      "id": "MDU6SXNzdWU2MDM1NDY3ODg=",
      "title": "Clarify presentation format section",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/136",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The wording about key=value syntax is confusing.  It could be clearer, e.g.\r\n>    The presentation format for SvcFieldValue is a whitespace-separated list of\r\n> \u00a0 \u00a0key=value pairs (e.g. \"key123=value1 keys456=value2\"). When the value, or\r\n> \u00a0 \u00a0both the value and the \"=\" are omitted, the value should be interpreted as\r\n> \u00a0 \u00a0being empty.",
      "createdAt": "2020-04-20T21:27:21Z",
      "updatedAt": "2020-05-13T03:51:37Z",
      "closedAt": "2020-05-13T03:51:37Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Related clarification suggestion:\r\n\r\n> 6. In Section 2.2 it says (in reference to param field values):\r\n> \r\n> \u00a0 \u00a0o\u00a0 an octet string of the length defined by the previous field.\r\n> \r\n> It might be good to say here that the format of this octet string is defined\r\n> according to the corresponding SvcParamKey, and then reference section 6 for\r\n> ths currently defined keys. The same applies for section 2.1.1 for the\r\n> presentation format.",
          "createdAt": "2020-04-20T21:28:16Z",
          "updatedAt": "2020-04-20T21:28:16Z"
        }
      ]
    },
    {
      "number": 138,
      "id": "MDU6SXNzdWU2MDM1NTcwNDI=",
      "title": "Request: combine ABNF in one place",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/138",
      "state": "CLOSED",
      "author": "moonshiner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is more of a \"nice to have\" but would it be possible to have an appendix with all the ABNF in one place, along with the references to other documents where other definitions exist? \r\n\r\nBe glad to send a pull request. ",
      "createdAt": "2020-04-20T21:47:58Z",
      "updatedAt": "2020-04-30T18:46:39Z",
      "closedAt": "2020-04-30T18:46:39Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, PRs welcome!  EDIT: If you're looking at the ABNF, you might want to consider whether it's correct as stated.  Unfortunately, there's no definitive ABNF for zone file format, and some aspects seem ambiguous.",
          "createdAt": "2020-04-21T00:30:24Z",
          "updatedAt": "2020-04-21T00:31:38Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/MikeBishop/dns-alt-svc/pull/139  is to fix up minor validation issues. \r\n",
          "createdAt": "2020-04-21T03:00:11Z",
          "updatedAt": "2020-04-21T03:00:11Z"
        }
      ]
    },
    {
      "number": 147,
      "id": "MDU6SXNzdWU2MTM3MDc3Njk=",
      "title": "Clarify that transport proxies cannot issue SVCB queries",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/147",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2020-05-07T01:18:05Z",
      "updatedAt": "2020-06-11T02:05:30Z",
      "closedAt": "2020-06-11T02:05:29Z",
      "comments": []
    },
    {
      "number": 149,
      "id": "MDU6SXNzdWU2MTc3NzA2Njk=",
      "title": "Question about connection reuse",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/149",
      "state": "CLOSED",
      "author": "ddragana",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This is an example:\r\nThere are this 2 records for eampleA.com and exampleB.com:\r\nexampleA.com.  7200  IN HTTPSSVC  1 examples.com alpn=h2,h3 esniconfig=\"...\"\r\n\r\nexampleB.com.  7200  IN HTTPSSVC  1 examples.com alpn=h2,h3 esniconfig=\"...\"\r\n\r\nthey map to the same SvcDomainName.\r\nexamplea.com is requested first and there is already established connection to examples.com using sni examplea.com.\r\nNow request for exampleb.com should be made. The request cannot use already existing connection to examples.com unless it is permitted by Origin frame (RFC8336) or Section 9.1.1. in RFC7540 (this is not part of this spec)\r\nA connection can be reused only if ClientHello has not been send yet.\r\nI think this is a correct behavior. Maybe the spec should be more descriptive in Section \"Optimistic pre-connection and connection reuse\". There is this line:\r\n\r\n> If an SVCB record is consistent with an active or in-progress connection C\r\n\r\n`active` is not defining the needed state well, maybe it should be better define for HTTPSSVC case specifically.",
      "createdAt": "2020-05-13T21:36:14Z",
      "updatedAt": "2020-05-25T18:43:13Z",
      "closedAt": "2020-05-25T18:43:13Z",
      "comments": [
        {
          "author": "ddragana",
          "authorAssociation": "NONE",
          "body": "Also one more question: Should this draft extend a bit Section 9.1.1. in RFC7540? RFC7540 says that connection can be reuse if an origin host resolves to the the same IP address. Can this criteria be extended to \"the same SvcDomainName\"?",
          "createdAt": "2020-05-14T05:47:41Z",
          "updatedAt": "2020-05-14T05:47:50Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "I'm not sure that requires updating 7540.  If you're resolving the other hostname and it leads to the same SvcDomainName, then you likely have the remaining steps of the resolution cached.  It resolved to the same address.",
          "createdAt": "2020-05-14T14:48:34Z",
          "updatedAt": "2020-05-14T14:48:34Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@ddragana I agree with your analysis of the example you've posed, but I think the current text covers it, by defining \"consistent\" to mean \"the client would attempt an equivalent connection\".  Two connections with different SNI are not equivalent for HTTPS, given the conditions you identified in RFC 7540.\r\n\r\nIf you think it's unclear, we could add a sentence like \"For HTTPS, the criteria for a suitable connection are given in RFC 7540 Section 9.1.1.\".",
          "createdAt": "2020-05-15T01:55:42Z",
          "updatedAt": "2020-05-15T01:55:42Z"
        },
        {
          "author": "ddragana",
          "authorAssociation": "NONE",
          "body": "The current text is fine. ",
          "createdAt": "2020-05-25T18:43:13Z",
          "updatedAt": "2020-05-25T18:43:13Z"
        }
      ]
    },
    {
      "number": 154,
      "id": "MDU6SXNzdWU2Mjc0OTMwOTY=",
      "title": "Larger SvcParamKey space for experiments and first-come-first-served allocations",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/154",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wg"
      ],
      "body": "Having only 256 experimental SvcParamKeys may not be enough.\r\nProposed would be to leave the first 32k as expert review,\r\nmost of the next 32k as first-come-first-served, and some\r\nsubset (256) as experimental/private-use.",
      "createdAt": "2020-05-29T19:31:27Z",
      "updatedAt": "2020-06-11T02:55:45Z",
      "closedAt": "2020-06-11T02:55:45Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "See also #113 ",
          "createdAt": "2020-05-29T19:42:56Z",
          "updatedAt": "2020-05-29T19:42:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This seems like a pretty reasonable plan to me. Without a change like this, doing experiments seems like it'd be challenging.",
          "createdAt": "2020-06-04T21:33:20Z",
          "updatedAt": "2020-06-04T21:33:20Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since I requested this change, I'm clearly in favor of it too =)\r\n\r\nShould we bring this up with WG as a discussion item?",
          "createdAt": "2020-06-05T22:48:31Z",
          "updatedAt": "2020-06-05T22:48:31Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see this as terribly contentious.  I would just do it, and highlight it for discussion in the changelog we send to the WG.\r\n\r\nAlso, I'm tempted to make codes 1-255 \"RFC Required\".",
          "createdAt": "2020-06-07T16:37:46Z",
          "updatedAt": "2020-06-07T16:37:46Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That all sounds good to me",
          "createdAt": "2020-06-08T15:41:30Z",
          "updatedAt": "2020-06-08T15:41:30Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "I still prefer #113, but I recognize that I'm clearly biased (because I opened #113 and because I only deal with client-side where the additional bytes are mostly free).  This proposal seems to be a reasonable compromise that greatly mitigates the main issue of 256 keys being completely insufficient for experimentation.  So overall, SGTM!\r\n\r\nRe WG discussion: I wouldn't expect this to be contentious enough to require discussion before adding to the next draft.\r\n\r\nRe a small RFC-Required block: Assuming the primary motivation would be to save the \"good\" low numbers for the really important things (rather than concerns over running out of points), I would argue that we should make it even stricter (\"Standards Action\") since I see no reason for Informational or Experimental drafts to get the distinction.",
          "createdAt": "2020-06-08T16:54:51Z",
          "updatedAt": "2020-06-08T16:56:31Z"
        }
      ]
    },
    {
      "number": 166,
      "id": "MDU6SXNzdWU2Mzc0NDc4NzA=",
      "title": "Consider a way to indicate some keys as \"mandatory\"",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/166",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [
        "wg"
      ],
      "body": "@enygren has proposed identifying a key range as \"mandatory\".  A client encountering an unrecognized \"mandatory\" key would discard the entire RR.\r\n\r\nThe current draft already relies on mandatory understanding for the \"port\" and \"alpn\" keys.  Without a mandatory range, keys of this kind could not be defined in a future draft.\r\n\r\nPR #164 is an example of something that might make sense as a followup RFC, but currently can't be because of the lack of such a range.\r\n\r\nPreviously, this seemed somewhat artificial to me, but with the new partitioned key ranges it doesn't seem so strange.  Perhaps we could assign this meaning to the new 1-255 \"Standards Action\" range.\r\n\r\nEDIT: Alternatively, this could be its own SvcParamKey, e.g. `mandatory=port,alpn`.\r\nEDIT2: Using 1-255 seems like a very small range, but if we ever get close to running out, we can simply define a `mandatory` SvcParamKey in that range, and use it to extend the behavior indefinitely.  So if we choose a range, it can be small.",
      "createdAt": "2020-06-12T02:56:58Z",
      "updatedAt": "2020-07-03T02:54:46Z",
      "closedAt": "2020-07-03T02:54:46Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "We wouldn't want that meaning for all Standards Action values, though; certainly someone might define an optional-to-understand value in a standard.  Given than new values in each range might want to define either type of value, I'd be more inclined toward a `mandatory=` parameter which lists the parameters which must be understood to consider this entry.",
          "createdAt": "2020-06-17T19:26:34Z",
          "updatedAt": "2020-06-17T19:26:34Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @MikeBishop that we shouldn't necessarily tie the Standards Action range to being mandatory. I can see reasons to have mandatory keys that are in non-standard ranges, and reasons to have standardized values that aren't mandatory.\r\n\r\nBeyond that, I can see it being reasonable for the existing keys (ech) to be not supported by a client at first, while ALPN is, etc.\r\n\r\nI'd prefer to see a `mandatory=` parameter as well to allow the record to specify more clearly which parts it finds necessary. Right now, the value `0` is `Reserved for internal use`. Could this be used perhaps as the `mandatory` key? The value would be a list of other keys, and this would also have the nice benefit of being required to be first key in the list, so clients know up front if they support all the mandatory fields.",
          "createdAt": "2020-06-17T22:11:00Z",
          "updatedAt": "2020-06-17T22:11:00Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "I also like this idea of mandatory= parameter using SvcParamKey=0.\r\n\r\n(Would we want to also allow mandatory= to appear on Alias form but without any defined/allowed parameters.  That creates a future for parameters on Alias form but without needing to define any now?)",
          "createdAt": "2020-06-18T02:16:58Z",
          "updatedAt": "2020-06-18T02:16:58Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm OK with 0 -> `mandatory`, but I also like 1 -> `mandatory`, leaving 0 for use as some kind of null.\r\n\r\nI have some concerns about allowing it in AliasForm.  That would have several knock-on effects:\r\n* Recursive resolvers would have to parse the SvcFieldValue, to see if it contains an unrecognized mandatory key.\r\n* Multiple aliases in an RRSet would have to be allowed, to support recursive and clients that can't use one of the aliases due to a unsupported mandatory key.  This would then require some kind of preference ordering among multiple aliases, assuming that the new mandatory key is actually useful.\r\n\r\nThis proposal is already pretty complicated, and we don't have a use case for mandatory keys on aliases, so I think we're probably better off keeping `mandatory` ServiceForm-only, like the other keys.",
          "createdAt": "2020-06-22T18:53:43Z",
          "updatedAt": "2020-06-22T18:53:43Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "One problem with \"mandatory\" is how to deal with `alpn` and `port`.  These are both already mandatory: you can't connect if they are present and you don't understand and use them.  Some options:\r\n* Require every record that uses `port` or `alpn` to have a `mandatory` key.\r\n* Special-case these two keys as implicitly mandatory\r\n* Assign a range of mandatory keys (i.e. encode it as a flag in the key id)\r\n* Make keys mandatory by default, and define an `optional` key.\r\n\r\nI'm beginning to feel like the last option is the least error-prone and most comprehensible.  It would have some interesting side effects, such as allowing endpoints that not only support ECH but actually require it.",
          "createdAt": "2020-06-24T03:13:13Z",
          "updatedAt": "2020-06-24T03:13:13Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "I think optional is a saner default.  As such, I'd lean towards either allowing protocol bindings to specify a set of implicitly mandatory keys  (HTTPS would specify alpn and port.), or just special-casing those two in general. ",
          "createdAt": "2020-06-24T14:20:35Z",
          "updatedAt": "2020-06-24T14:20:35Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Optional is definitely the better default. Don't make keys mandatory in general.\r\n\r\nI'd say we can have those two keys implicitly mandatory if we really want (option 2)\u2014or just leave it to the deployment to mark what *they* think is mandatory (option 1). Yes, your use case for `port` is mandatory now, but that doesn't there couldn't be possible use cases in which you can have an alpn value that for some reason an implementation doesn't parse, but also have fields in the record that mean it shouldn't be thrown out.",
          "createdAt": "2020-06-24T15:44:02Z",
          "updatedAt": "2020-06-24T15:44:02Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree with \"don't make keys mandatory in general\" logic.  ",
          "createdAt": "2020-06-24T15:52:38Z",
          "updatedAt": "2020-06-24T15:52:38Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've written up a PR for \"mandatory\", #205, reflecting the input here.\r\n\r\nOne difference: I didn't reorder the list of IANA codepoints.  I'm happy to do that if people have feelings about which number should mean what.",
          "createdAt": "2020-07-01T02:49:26Z",
          "updatedAt": "2020-07-01T02:49:26Z"
        }
      ]
    },
    {
      "number": 167,
      "id": "MDU6SXNzdWU2Mzc5NTAyNzU=",
      "title": "Whether to include weight as a parameter",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/167",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "proposed to close"
      ],
      "body": "Moving this issue out of the text (even if we WONTFIX it for now):\r\n\r\n## Whether to include Weight\r\n\r\nSome other similar mechanisms such as SRV have a weight in addition\r\nto priority.  That is excluded here for simplicity.  It could always be\r\nadded as an optional SVCB parameter.",
      "createdAt": "2020-06-12T19:06:12Z",
      "updatedAt": "2020-06-18T03:27:44Z",
      "closedAt": "2020-06-18T03:27:44Z",
      "comments": [
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I argue for \"no\".  You are going down the slippery slope of SRV. \r\n\r\nThe only places I've seen usage of SRV is  by - SIP, Kerberos,  and XMPP",
          "createdAt": "2020-06-17T22:18:25Z",
          "updatedAt": "2020-06-17T22:18:25Z"
        }
      ]
    },
    {
      "number": 168,
      "id": "MDU6SXNzdWU2Mzc5NTQzMzg=",
      "title": "SVCB record include service name in RDATA?",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/168",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "proposed to close"
      ],
      "body": "Moving from the draft to an issue.\r\nProposing to WONTFIX this.\r\n\r\nAnother open question is whether SVCB records\r\nshould be self-descriptive and include the service name\r\n(eg, \"https\") in the RDATA section to avoid ambiguity.\r\nPerhaps this could be included as an svc=\"baz\" parameter\r\nfor protocols that are not the default for the RR type?\r\nCurrent inclination is to not do so.",
      "createdAt": "2020-06-12T19:15:11Z",
      "updatedAt": "2020-06-18T03:27:55Z",
      "closedAt": "2020-06-18T03:27:55Z",
      "comments": [
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree here",
          "createdAt": "2020-06-18T03:19:39Z",
          "updatedAt": "2020-06-18T03:19:39Z"
        }
      ]
    },
    {
      "number": 171,
      "id": "MDU6SXNzdWU2Mzg0NDU1ODM=",
      "title": "\"NOT REQUIRED\" not a legit 2119 keyword",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/171",
      "state": "CLOSED",
      "author": "moonshiner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\r\nIn the section \"Using SVCB with HTTPS and HTTP\" the text says \"NOT REQUIRED\" and while I agree the upper case adds the gravitas, it's not a legit 2119 keyword.\r\n\r\n",
      "createdAt": "2020-06-14T22:44:18Z",
      "updatedAt": "2020-06-22T18:41:31Z",
      "closedAt": "2020-06-22T18:41:31Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "Hm, I think that technically we want a \"MAY not implement Alt-Svc,\" but the naive reading of that is that you're not allowed to implement.  \"MAY choose not to implement Alt-Svc.\"\r\n\r\nAlternatively, do we need 2119 language here?  \"need not implement\" would communicate the right message.",
          "createdAt": "2020-06-16T22:38:35Z",
          "updatedAt": "2020-06-16T22:41:27Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My opinion is we don't need the 2119 language.  I was offering the option if the authors feel they want one. ",
          "createdAt": "2020-06-16T22:45:36Z",
          "updatedAt": "2020-06-16T22:45:36Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This can. be closed",
          "createdAt": "2020-06-18T03:27:12Z",
          "updatedAt": "2020-06-18T03:27:12Z"
        }
      ]
    },
    {
      "number": 172,
      "id": "MDU6SXNzdWU2Mzk5ODg4MTk=",
      "title": "We should change master to primary in Appendix A.3",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/172",
      "state": "CLOSED",
      "author": "moonshiner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "FYI, I was just thinking we should be ahead of this. ",
      "createdAt": "2020-06-16T21:38:48Z",
      "updatedAt": "2020-06-16T21:59:58Z",
      "closedAt": "2020-06-16T21:59:58Z",
      "comments": []
    },
    {
      "number": 177,
      "id": "MDU6SXNzdWU2NDA4ODAyMDQ=",
      "title": "Update document references",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/177",
      "state": "CLOSED",
      "author": "moonshiner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Per Nits, these documents have updated versions:\r\n\r\n {{!ECH=I-D.ietf-tls-esni-07}})\r\n {{!HTTP3=I-D.draft-ietf-quic-http-29}} \r\n {{?I-D.draft-ietf-dnsop-aname-04}}\r\n\r\nand {{!Attrleaf=I-D.ietf-dnsop-attrleaf}} is now RFC8552\r\n",
      "createdAt": "2020-06-18T03:33:08Z",
      "updatedAt": "2020-06-22T18:35:11Z",
      "closedAt": "2020-06-22T18:35:11Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "The doc just shouldn't reference specific version numbers at all unless we truly mean *that specific version and no other*; the build process will fetch the most current version of the document if not specified.",
          "createdAt": "2020-06-22T17:42:44Z",
          "updatedAt": "2020-06-22T17:42:44Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh that makes perfect sense actually.  I was wondering why some references had versions and another did not. \r\n\r\nand I've gotten my tooling worked out.  ",
          "createdAt": "2020-06-22T17:45:49Z",
          "updatedAt": "2020-06-22T17:45:49Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The we should remove the version numbers on those documents? ",
          "createdAt": "2020-06-22T18:04:42Z",
          "updatedAt": "2020-06-22T18:04:42Z"
        }
      ]
    },
    {
      "number": 180,
      "id": "MDU6SXNzdWU2NDM1Nzc3MjM=",
      "title": "SRV language is unnecesarily perjorative",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/180",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "> Address a set of long-standing issues due to HTTP(S) clients not implementing support for SRV records, as well as due to a limitation that a DNS name can not have both CNAME and NS RRs (as is the case for zone apex names)\r\n\r\nThis implies fault in clients for a refusal to implement, as opposed to SRV not providing sufficient advantages for HTTP(S) clients.\r\n\r\nRather than get into the why, it might be best to say which of the features of SRV are provided and why.  \r\n\r\nI might also separate out the point about NS and CNAME not playing well together.\r\n\r\n",
      "createdAt": "2020-06-23T06:46:21Z",
      "updatedAt": "2020-07-13T03:18:37Z",
      "closedAt": "2020-07-13T03:18:37Z",
      "comments": []
    },
    {
      "number": 181,
      "id": "MDU6SXNzdWU2NDM1NzgzNTM=",
      "title": "EOFU: HSTS",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/181",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "HSTS is mentioned in Section 1.1, but it is not expanded or a citation provided.",
      "createdAt": "2020-06-23T06:47:34Z",
      "updatedAt": "2020-07-13T17:26:31Z",
      "closedAt": "2020-07-13T17:26:31Z",
      "comments": []
    },
    {
      "number": 182,
      "id": "MDU6SXNzdWU2NDM1ODExMjU=",
      "title": "Non-normative normative language",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/182",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Seciton 1.2 is explicitly non-normative (whatever that means), but it uses some language that looks very much like normative requirements:\r\n\r\n> Clients must either use responses included in the additional section returned by the recursive resolver or perform necessary SVCB, A, and AAAA record resolutions.  DNS authoritative servers may attach in-bailiwick SVCB, A, AAAA, and CNAME records in the Additional Section to responses for a SVCB query.\r\n\r\nThe use of lowercase here means non-normative, but the choice of words is unfortunate.  Why not use different words:\r\n\r\n> Clients either use responses included in the additional section returned by the recursive resolver or perform necessary SVCB, A, and AAAA record resolutions.  DNS authoritative servers can attach in-bailiwick SVCB, A, AAAA, and CNAME records in the Additional Section to responses for a SVCB query.\r\n",
      "createdAt": "2020-06-23T06:52:41Z",
      "updatedAt": "2020-07-13T20:22:42Z",
      "closedAt": "2020-07-13T20:22:42Z",
      "comments": []
    },
    {
      "number": 183,
      "id": "MDU6SXNzdWU2NDM1ODM3ODc=",
      "title": "Definition of \"origin server\"",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/183",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "> The \"origin server\" is the server that the client would reach when accessing the origin in the absence of the SVCB record or an HTTPS Alt-Svc.\r\n\r\nHTTP has a definition of origin server that this is not compatible with.  In HTTP an \"origin server\" is a server that is authoritative.  As the goal of this document is to define alternative ways to reach a server that is authoritative, the definition this document uses is very confusing.\r\n\r\nI don't have a solid alternative at this point, but I might suggest that the notion of \"whatever you get when this record isn't used\" isn't a very useful distinction.  As a hypothetical, consider a protocol that only uses SVCB derivatives for discovery, which would obviously have no such concept.  It might be better to dispense with the notion of \"original server\" entirely.",
      "createdAt": "2020-06-23T06:57:28Z",
      "updatedAt": "2020-07-13T19:52:33Z",
      "closedAt": "2020-07-13T19:52:33Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One example of where this term is used:\r\n\r\n> The \"port\" SvcParamKey defines the TCP or UDP port that should be used to contact this alternative service.  If this key is not present, clients SHALL use the origin server's port number.",
          "createdAt": "2020-06-23T08:45:42Z",
          "updatedAt": "2020-06-23T08:45:42Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The only other place this is used is:\r\n```\r\nIf none of the options succeed, the\r\n       client SHOULD connect to the origin server directly.\r\n```\r\n\r\nIt seems like this term is used sparsely enough it can be dispensed with, and the sentences reworded.",
          "createdAt": "2020-06-23T16:41:47Z",
          "updatedAt": "2020-06-23T16:41:47Z"
        }
      ]
    },
    {
      "number": 184,
      "id": "MDU6SXNzdWU2NDM1ODUwMTY=",
      "title": "64k priorities!",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/184",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "proposed to close"
      ],
      "body": "I realize that this might be going against an established trend, but the notion that 65535 different values for priority might be useful is a little fanciful.  HTTP are proposing just 8, DSCP had 64, and neither has any real expectation that there will be any value in having all of those options.  Why not 255?",
      "createdAt": "2020-06-23T06:59:44Z",
      "updatedAt": "2021-01-15T21:22:01Z",
      "closedAt": "2021-01-15T21:22:01Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Mainly for consistency with existing DNS types.  MX, SRV, NAPTR, and URI all have a similar \"Priority\" or \"Preference\" field, and they are all 16-bit unsigned.\r\n\r\nI don't have a use case for more than 255 values, but I wouldn't want to break the pattern without a positive signal from the DNS experts.  I'm happy to solicit input from DNSOP if you think it's worth changing.",
          "createdAt": "2020-06-23T16:51:44Z",
          "updatedAt": "2020-06-23T16:51:44Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd argue for leaving this as-is. Is it more priorities than we need? Yes, but it also fits the existing DNS RR type implementations better.",
          "createdAt": "2020-06-23T16:58:02Z",
          "updatedAt": "2020-06-23T16:58:02Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's true that Priority/Preference fields are 16-bit unsigned, but based on 20yr old decisions. \r\nI don't think I have seen anyone using a value > 255, and this is from years of looking at DNS zone data. \r\nIf it is left as is, I'd mention it's to align with those DNS RR Types.  ",
          "createdAt": "2020-06-23T17:10:55Z",
          "updatedAt": "2020-06-23T17:10:55Z"
        },
        {
          "author": "andrewtj",
          "authorAssociation": "NONE",
          "body": "It's odd to want to retain this for consistency with other types and also have no qualms about changing the meaning of the name \".\".",
          "createdAt": "2020-06-28T03:43:48Z",
          "updatedAt": "2020-06-28T03:43:48Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "I propose leaving this as 64k for consistency and closing.",
          "createdAt": "2020-06-30T19:49:44Z",
          "updatedAt": "2020-06-30T19:49:44Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've made a note to mention this when we do a WGLC to see what the WG says",
          "createdAt": "2020-07-01T11:45:32Z",
          "updatedAt": "2020-07-01T11:45:32Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Given the code point assignment for the RR types and this being a wire-format change, we should either change this ASAP or leave it as-is.",
          "createdAt": "2020-07-01T14:44:41Z",
          "updatedAt": "2020-07-01T14:44:41Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Indeed. We can't really change this if we have the wire format stable. If we do anything, let's have editorial text explaining why it's a 16-bit field.",
          "createdAt": "2020-07-01T17:36:45Z",
          "updatedAt": "2020-07-01T17:36:45Z"
        }
      ]
    },
    {
      "number": 185,
      "id": "MDU6SXNzdWU2NDM1ODk2Nzk=",
      "title": "ABNF for values",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/185",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "The definition of values allows for quoting, but the ABNF doesn't capture that.\r\n\r\n```\r\n   escaped-char  = \"\\\" (VCHAR / WSP)\r\n```\r\n\r\nThis implies that \"\\3\" is valid, where it is not.  Capturing this is not so difficult.\r\n\r\n```\r\n   basic-visible = %x21 / %x23-27 / %x2A-3A / %x3C-5B / %x5D-7E\r\n   unescaped = %x21 / %x23-27 / %x2A-2F / %x3C-5B / %x5D-7E\r\n   escaped-number = (%x30-31 2DIGIT) / (%x32 (%x30-34 DIGIT) / (%x35 %x30-35))\r\n   escaped-char  = \"\\\" (unescaped / WSP / escaped-number)\r\n```",
      "createdAt": "2020-06-23T07:08:33Z",
      "updatedAt": "2020-07-13T20:11:12Z",
      "closedAt": "2020-07-13T20:11:12Z",
      "comments": [
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "should \"%2A-3A\" be \" %x2A-3A\" ?\r\nsame for \" %2A-2F \" ?",
          "createdAt": "2020-06-23T12:40:41Z",
          "updatedAt": "2020-06-23T12:40:41Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Edited to add the 'x'.  As I copied this, I hope that this wasn't something I copied in.",
          "createdAt": "2020-06-24T00:20:28Z",
          "updatedAt": "2020-06-24T00:20:28Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I put a copy of the (updated) extracted ABNF in https://gist.github.com/moonshiner/3aa994227226c9e5b33dc808a8937574\r\n\r\nThis does run through 'bap' w/out errors. \r\n",
          "createdAt": "2020-06-24T15:35:53Z",
          "updatedAt": "2020-06-24T15:35:53Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/MikeBishop/dns-alt-svc/pull/160 updates the ABNF slightly.\r\n\r\nAlso, we have \"key\" and \"display-key\" but currently only use \"display-key\"",
          "createdAt": "2020-07-07T01:26:10Z",
          "updatedAt": "2020-07-07T01:26:10Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "For this issue, the relevant PR is #202.  PR #160 also makes some colliding changes, but it's not directly relevant to this issue.  If one of those PRs is approved, I'll merge it and resolve the collisions in the other PRs.",
          "createdAt": "2020-07-07T20:41:58Z",
          "updatedAt": "2020-07-07T20:41:58Z"
        }
      ]
    },
    {
      "number": 186,
      "id": "MDU6SXNzdWU2NDM1OTM3OTg=",
      "title": "Use colons before examples",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/186",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Such as in:\r\n\r\n```\r\n   As an example, the owner of example.com could publish this record\r\n\r\n   _8443._foo.api.example.com. 7200 IN SVCB 0 svc4.example.net.\r\n```\r\n\r\nText forms don't have clear delineation of example and text and without a colon it is harder to read.",
      "createdAt": "2020-06-23T07:16:04Z",
      "updatedAt": "2020-06-28T17:10:34Z",
      "closedAt": "2020-06-28T17:10:34Z",
      "comments": [
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/MikeBishop/dns-alt-svc/pull/198\r\n\r\nShould catch all those missing colons.  A double check before merging would be apprecriated",
          "createdAt": "2020-06-23T12:53:59Z",
          "updatedAt": "2020-06-23T12:53:59Z"
        }
      ]
    },
    {
      "number": 187,
      "id": "MDU6SXNzdWU2NDM1OTQ2ODc=",
      "title": "Similar to CNAME",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/187",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "\"When SvcRecordType is AliasForm, the SVCB record is to be treated similar to a CNAME alias pointing to SvcDomainName.\"\r\n\r\nIs this normative?  Because it reads as being normative, then it uses squishy words.  I think that this sentence is for setting intent, and could be reworded.\r\n\r\n",
      "createdAt": "2020-06-23T07:17:41Z",
      "updatedAt": "2020-07-13T03:45:01Z",
      "closedAt": "2020-07-13T03:45:01Z",
      "comments": []
    },
    {
      "number": 188,
      "id": "MDU6SXNzdWU2NDM1OTY1NTk=",
      "title": "Aliases to A/AAAA records",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/188",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [
        "proposed to close"
      ],
      "body": "It's not clear why this is useful as opposed to having a ServiceForm SVCB at the target of an alias.  Some words on the subject would be greatly appreciated.",
      "createdAt": "2020-06-23T07:21:03Z",
      "updatedAt": "2021-01-15T21:21:38Z",
      "closedAt": "2021-01-15T21:21:38Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It also, as I understand things, means a client which sees a chain of HTTPS alias forms must, at each stage in the process, issue new parallel A/AAAA/HTTPS queries since we can't assume that the three will get stapled together.",
          "createdAt": "2020-06-23T20:36:41Z",
          "updatedAt": "2020-06-23T20:36:41Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Is the wording following #209 good enough for us to close this?",
          "createdAt": "2020-07-13T20:17:29Z",
          "updatedAt": "2020-07-13T20:17:29Z"
        }
      ]
    },
    {
      "number": 189,
      "id": "MDU6SXNzdWU2NDM1OTg5Mjg=",
      "title": "Step 3 of client algorithm, SHOULD?",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/189",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "> If one or more SVCB records of ServiceForm SvcRecordType are returned for HOST, clients should select the highest-priority option with acceptable parameters, \r\n\r\nIs this SHOULD select ?",
      "createdAt": "2020-06-23T07:25:02Z",
      "updatedAt": "2020-07-13T20:16:44Z",
      "closedAt": "2020-07-13T20:16:43Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, why not.  Added to #204.",
          "createdAt": "2020-07-11T21:36:18Z",
          "updatedAt": "2020-07-11T21:36:18Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #204 ",
          "createdAt": "2020-07-13T20:16:43Z",
          "updatedAt": "2020-07-13T20:16:43Z"
        }
      ]
    },
    {
      "number": 190,
      "id": "MDU6SXNzdWU2NDM2MDM0Nzc=",
      "title": "Privacy intent?",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/190",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "What does this mean (from S3.2)?\r\n\r\n> Clients using a domain-oriented transport proxy like HTTP CONNECT ([RFC7231] Section 4.3.6) or SOCKS5 ([RFC1928]) SHOULD disable SVCB support if performing SVCB queries would violate the client's privacy intent.\r\n\r\nIt's not clear what information is leaking and to whom here.  This likely needs more text that addresses assumptions about where the client is sending these SVCB queries.\r\n\r\nOf course, letting the proxy perform name resolution can improve privacy with respect to the resolver that a client chooses.  However, there are ways in which SVCB can enhance privacy in these configurations, especially if the proxy is not trusted with information about destinations.  It requires that you use DoT or DoH to a resolver that the client trusts to learn domain names.",
      "createdAt": "2020-06-23T07:32:32Z",
      "updatedAt": "2020-07-12T03:19:47Z",
      "closedAt": "2020-07-12T03:19:47Z",
      "comments": []
    },
    {
      "number": 191,
      "id": "MDU6SXNzdWU2NDM2MDU4MTk=",
      "title": "Mandating DoS",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/191",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "The text in Section 3.1 correctly identifies a number of ways in which a client might be denied access to a SVCB record.  I don't know if this is exhaustive, but it seems like a reasonable start.  It then mandates (using \"MUST NOT\") very specific behaviour.  That mandated behaviour ends up making the service effectively unreachable.\r\n\r\nIt is not appropriate for this document to set policy for clients in this way.  It is clear that this is biased toward ensuring that secured alternative methods for reaching a service are known to a client, but I don't think that this is the only way to achieve that goal.  All this does is make the system more likely to be brittle and prone to denial of service.",
      "createdAt": "2020-06-23T07:36:25Z",
      "updatedAt": "2020-07-10T16:14:59Z",
      "closedAt": "2020-07-10T16:14:59Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a \"MUST NOT\" because otherwise ECH is vulnerable to a downgrade attack: if a MITM between Firefox and the DoH server drops just the packets containing SVCB responses (likely identifiable by size or timing), they will eventually time out.  If the client falls back to ordinary connection, they'll lose the ECH protection.  (QUIC makes this attack especially easy.)\r\n\r\nIf ECH doesn't need to be downgrade-resistant in this way, then we can relax the requirement, but the ECH experts I've talked to seem to think that this threat type is in-scope.",
          "createdAt": "2020-06-23T17:05:56Z",
          "updatedAt": "2020-06-23T17:05:56Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why make the requirement generic though?  There is already text in Section 8.1 that addresses the problem of ECH downgrade (though it is not complete, see #196).",
          "createdAt": "2020-06-24T00:27:35Z",
          "updatedAt": "2020-06-24T00:27:35Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I remembered another reason: the downgrade protection also applies to the HTTPS upgrade functionality, so fallback-on-error would allow the MITM to disable HTTPS upgrade.\r\n\r\nAn alternative to the current spec would be: \"on error, the HTTPS upgrade still applies as if the record were present, and if the client supports ECH, it must abandon the connection entirely\".  That seems like more spec complexity for very limited gain (assuming most clients do implement ECH), but I think it would be safe.",
          "createdAt": "2020-06-24T02:34:18Z",
          "updatedAt": "2020-06-24T02:34:18Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should not place any weight on this mechanism when it comes to downgrades.\r\n\r\nI'm not suggesting that ECH advice needs to change (except as described in #196, perhaps), but instead suggesting that the generic advice not be so strong.",
          "createdAt": "2020-06-24T03:25:24Z",
          "updatedAt": "2020-06-24T03:25:24Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Proposal from discussion: change to SHOULD and then have text in security considerations saying why you REALLY OUGHT TO",
          "createdAt": "2020-07-09T20:45:11Z",
          "updatedAt": "2020-07-09T20:45:11Z"
        }
      ]
    },
    {
      "number": 192,
      "id": "MDU6SXNzdWU2NDM2NDI2OTM=",
      "title": "Presentation of ALPN",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/192",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "proposed to close"
      ],
      "body": "The presentation format for ALPN is not consistent with the generic presentation format.  It also includes unprintable characters.",
      "createdAt": "2020-06-23T08:35:08Z",
      "updatedAt": "2021-01-15T21:21:32Z",
      "closedAt": "2021-01-15T21:21:32Z",
      "comments": [
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "Apart from having to recognise \"\\\\,\" vs \",\" and having to remember which commas where escaped and which where not, APLN are still a optionally quoted string.  e.g. ALPN=\"x\\\\,y,z\" or ALPN=x\\\\,y,z",
          "createdAt": "2020-06-24T07:41:47Z",
          "updatedAt": "2020-06-24T07:42:51Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It is unnecessarily different.  And it's not clear that the same escaping rules apply.  In the presentation format I might include \\000 to include a literal NUL, but it appears to require the inclusion of a literal NUL preceded by a backslash in the ALPN format.\r\n\r\nIf the section said \"just like the presentation format, but you have to escape comma\" then it might be understandable, but the differences are inexplicable.",
          "createdAt": "2020-06-24T07:57:23Z",
          "updatedAt": "2020-06-24T07:57:23Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Larry Campbell (@lcampbel) also found this unclear in a thread on dnsop, so it does seem like we should clarify. ",
          "createdAt": "2020-06-24T14:24:59Z",
          "updatedAt": "2020-06-24T14:25:26Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How about a couple of examples? ",
          "createdAt": "2020-06-24T15:50:10Z",
          "updatedAt": "2020-06-24T15:50:10Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #202.  Good enough now?",
          "createdAt": "2020-07-13T20:12:43Z",
          "updatedAt": "2020-07-13T20:12:43Z"
        }
      ]
    },
    {
      "number": 193,
      "id": "MDU6SXNzdWU2NDM2NDUzMjQ=",
      "title": "Remove no-default-alpn",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/193",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "proposed to close"
      ],
      "body": "This is of no lasting value and it only represents a marginal gain in space for a non-trivial gain in complexity.  Having an ALPN field in every HTTPS record just isn't that many bytes (2+2+3=7 for just \"h2\", 2+2+3+9=16 for \"h2,http/1.1\").\r\n\r\nI've raised this a couple of times in the past, but I never received a satisfactory response.",
      "createdAt": "2020-06-23T08:39:10Z",
      "updatedAt": "2021-01-15T21:21:26Z",
      "closedAt": "2021-01-15T21:21:26Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "The goal here was not efficiency of encoding, it was to avoid a certain category of administrative mistakes.  Specifically, without this in place, it would be easy for a zone owner to add a single record with \"alpn=h3 echconfig=...\", test locally, see everything is working, and not realize that they just disabled their website for ~10% of users (who don't have UDP routability).\r\n\r\nThis represents something of a compromise between participants who wanted to be able to run QUIC and TCP on separate endpoints (or even QUIC-only services in unusual situations), and participants who wanted HTTPS-over-TCP to be required for every endpoint.",
          "createdAt": "2020-06-23T12:02:50Z",
          "updatedAt": "2020-06-23T12:02:50Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't find that sort of defensive design useful relative to the complexity it adds.  And it makes the configuration less transparent.",
          "createdAt": "2020-06-24T00:19:24Z",
          "updatedAt": "2020-06-24T00:19:24Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "The `no-default-alpn` business is the result of a Very Long Debate that I would prefer not to reopen, but it's not something anyone is particularly happy with.  Currently, getting rid of it would result in records being unusable in the default state.  To fix this, we would have to give `alpn` a default value of `http/1.1` (for the HTTPS RR) if the key is absent.\r\n\r\nIn the design you're proposing, `alpn=h2` means that you dropped support for HTTP/1.1-only clients.  (I believe even Chrome is sometimes HTTP/1.1-only, e.g. for WebSockets).  That strikes me as more likely to result in swearing sysadmins than the current design, and same for the `alpn=h3` case.\r\n\r\nTo put it another way, I think there are likely to be many orders of magnitude more zone owners configuring these RRs than software developers implementing them, so we should prioritize the ease of (working) configuration over the ease of implementation.",
          "createdAt": "2020-06-24T03:02:41Z",
          "updatedAt": "2020-06-24T03:02:41Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Would it be helpful to adjust the name of this parameter to make the effect more clear? For example, rather than `no-default-alpn`, you could call it `strict-alpn`, `restricted-alpn`, or something similar.\n\nMaking claims about what the default ALPN is might be causing some of the annoyance here. Instead, if we think of the list of ALPN values in the record as purely additive from the client\u2019s perspective (always just a hint to add capability and never restrict), this key becomes a way to disable \u2018additive\u2019 mode and tell clients that the list is actually a hint of the only ALPNs that are supported. ",
          "createdAt": "2020-07-06T04:00:43Z",
          "updatedAt": "2020-07-06T04:00:43Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Calling it strict-alpn or restricted-alpn would not be compatible with the changes in #201 .  Are there other names that might be less confusing?",
          "createdAt": "2020-07-09T20:53:24Z",
          "updatedAt": "2020-07-11T16:24:16Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In what way would those proposals not be compatible?",
          "createdAt": "2020-07-10T01:53:45Z",
          "updatedAt": "2020-07-10T01:53:45Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that should be #201.\r\n\r\n\"Strict\" or \"restricted\" would seem to indicate that the client must not send anything other than listed ALPNs, or that the server won't accept anything else.  Neither of those readings match the intent of the ALPN selection process, in the current draft or in #201.",
          "createdAt": "2020-07-10T02:15:56Z",
          "updatedAt": "2020-07-10T02:15:56Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#201 makes more sense =)\r\n\r\nYes, I agree that it's not \"strict\". It's mainly a hint that the old ALPNs won't work.\r\n\r\nWhat is the client behavior intention here? As a client, I'm honestly just ignoring it right now. I guess it's a way to say, if you think you can get rid of h1/h2, then delay trying those?",
          "createdAt": "2020-07-10T02:21:16Z",
          "updatedAt": "2020-07-10T02:21:16Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Example use-case would be having an RR set with two HTTPS records: one supports h1 and h2 and h3 and the other supports only h3.  The one with only h3 would have higher priority.  This would be to allow different service addresses (or different server pools) that are h3-only.  That may come in-hands as h3 opens up some interesting deployment possibilities. \r\nThe concern is that having alpn=h3 mean h3-only is that if that's the only record included that it could be a foot-gun.  Thus \"alpn=h3 no-default-alpn\" still alows for h3-only but for a safer default on alpn=h3.",
          "createdAt": "2020-07-10T02:29:48Z",
          "updatedAt": "2020-07-10T02:31:30Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on discussions, are there concerns about closing out this issue?\r\n(While not perfect, this still seems like a reasonable compromise.)",
          "createdAt": "2020-07-13T20:15:51Z",
          "updatedAt": "2020-07-13T20:15:51Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"No\" is hardly a compromise, but I can live with the outcome.",
          "createdAt": "2020-07-14T03:01:36Z",
          "updatedAt": "2020-07-14T03:01:36Z"
        }
      ]
    },
    {
      "number": 194,
      "id": "MDU6SXNzdWU2NDM2NDg2ODk=",
      "title": "Advice regarding construction of ALPN extension in TLS",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/194",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [
        "proposed to close"
      ],
      "body": ">    Clients MUST include an \"application_layer_protocol_negotiation\" extension in their ClientHello with a ProtocolNameList that includes at least one ID from the ALPN set.  Clients SHOULD also include any other values that they support and could negotiate on that connection with equivalent or better security properties.  For example, if the ALPN set only contains \"http/1.1\", the client could include \"http/1.1\" and \"h2\" in the ProtocolNameList.\r\n\r\nThis could be read to imply that a client conditions its choice of ALPN parameter in a TLS ClientHello based on what it learns from SVCB.  This is dangerous as it exposes the connection to potential downgrade attacks.  Though it tries to recommend that \"better\" options be chosen, this is a determination that the server makes in ALPN, not the client.  This document should instead mandate that clients construct an ALPN extension containing all protocols that they are willing to use.",
      "createdAt": "2020-06-23T08:44:13Z",
      "updatedAt": "2021-01-15T21:21:18Z",
      "closedAt": "2021-01-15T21:21:18Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "I think that depends on how you define \"downgrade.\"  The existing text says that the client includes:\r\n- At least one ALPN token from the SVCB record(s)\r\n- Any protocol the client supports which it considers \"better\" than the least-preferable selected token, even if not in the SVCB record\r\n\r\nBut the point that it leads to selection involving the client's definition of \"better\" versus the server's is certainly a fair point.",
          "createdAt": "2020-06-24T20:51:10Z",
          "updatedAt": "2020-06-24T20:51:10Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Wait, I remember this \"better\" formulation already came up and was rejected, for precisely this reason. The network does not get to influence the selected ALPN protocol. This notion of \"better\" breaks any formal notion of downgrade protection. It also has practical consequences beyond downgrades: even if client and server agree that h2 is better than http/1.1, the current draft text makes h2 SVCB into a deployment hazard if, say, the server needed to rollback h2.\r\n\r\nI agree with Martin that this text needs to change. Both http/1.1 and h2 SVCB records must result in the *exact* same ALPN advertisement, namely all the client's accepted protocols. The only acceptable filtering is that inherent to collections of compatible ALPNs. Beyond that, SVCB stays out of the TLS ALPN negotation.",
          "createdAt": "2020-06-25T05:19:10Z",
          "updatedAt": "2020-06-25T05:26:14Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Merged in #201.  Good enough to close?",
          "createdAt": "2020-07-13T20:14:25Z",
          "updatedAt": "2020-07-13T20:14:25Z"
        }
      ]
    },
    {
      "number": 195,
      "id": "MDU6SXNzdWU2NDM2NTIzMzg=",
      "title": "Dual use of references symbolic names as words",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/195",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "As an editorial convention, this is hard to follow because the words used to identify a reference also form part of the sentence.\r\n\r\ne.g., \"CNAME or [DNAME]\", \"By removing the [Attrleaf] labels used in SVCB\".",
      "createdAt": "2020-06-23T08:49:15Z",
      "updatedAt": "2020-07-13T04:05:59Z",
      "closedAt": "2020-07-13T04:05:59Z",
      "comments": [
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "does \"By removing the underscore-prefixed label used in SVCB\"  sound better? ",
          "createdAt": "2020-06-24T15:56:09Z",
          "updatedAt": "2020-06-24T15:56:09Z"
        }
      ]
    },
    {
      "number": 196,
      "id": "MDU6SXNzdWU2NDM2NjE0OTI=",
      "title": "Unclear precedence rules",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/196",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "proposed to close"
      ],
      "body": "At one level, the precedence rules for this specification could be simple: take the RRs with the lowest priority and select at random between them.  This is clearly the case for the 0/other split.\r\n\r\nBut it isn't that simple, because RRs with lower priority might not have options that the client supports.  So some configurations are eliminated.\r\n\r\nMoreover, there are cases where server/operator preference and client preference might be in tension.  Let's say that the client greatly prefers HTTP/3 over HTTP/1.1.  Is it required to use an HTTPS RR with HTTP/1.1 and a lower priority if a higher priority supports HTTP/3?\r\n\r\nMore difficult, what if the higher priority has echconfig and the lower priority one does not?  Section 8.1 might be read to imply that echconfig overrides other considerations, but it isn't very clear on that point.  Also, we have to consider an echconfig that the client does not support specially, as that does not imply that the RR lacks echconfig.",
      "createdAt": "2020-06-23T09:01:22Z",
      "updatedAt": "2021-01-15T21:21:11Z",
      "closedAt": "2021-01-15T21:21:11Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Change #204 includes some changes that might make this clearer.  However, I think precedence rules are pretty clear: clients shuffle, sort, and walk down the list.  If they run out, they fall back to normal connection.  (Special case: if all attempts had ECH, and all failed, don't fall back to non-ECH.)\r\n\r\nThe order of attempts is SHOULD and MAY, so sufficiently smart/opinionated clients can mess with it if they want.\r\n\r\n",
          "createdAt": "2020-07-11T19:45:18Z",
          "updatedAt": "2020-07-11T19:45:18Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Is this good enough now that #204 has been merged?",
          "createdAt": "2020-07-13T20:13:52Z",
          "updatedAt": "2020-07-13T20:13:52Z"
        }
      ]
    },
    {
      "number": 203,
      "id": "MDU6SXNzdWU2NDY1NzQyMzc=",
      "title": "Period is owner name for additional section processing is different to every other type.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/203",
      "state": "CLOSED",
      "author": "marka63",
      "authorAssociation": "NONE",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "For every other type the next name to be looked up is embedded in the rdata itself.  Additional \".\" often means \"no such service\".   For BIND adding \".\" is owner name meant touching 102 files as every other RR types method for processing additional data needed to changed as well as every place where additional data is added to the response.\r\n\r\nI'm wondering if making \".\" special like this is worth it? \r\n\r\nI'm also wondering if we should be giving up the ability to signal \"no such service\" as is done in SRV, MX is worth it?",
      "createdAt": "2020-06-27T00:40:30Z",
      "updatedAt": "2020-07-12T03:38:27Z",
      "closedAt": "2020-07-12T03:38:27Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> For BIND adding \".\" is owner name meant touching 102 files as every other RR types method for processing additional data needed to changed\r\n\r\nThat's definitely surprising!  We didn't think this would be complicated to implement.\r\n\r\n> I'm wondering if making \".\" special like this is worth it?\r\n\r\nThe most important thing to me is that we have a way to encourage SvcDomainName == owner name when editing the zone file, because this reduces latency under certain conditions.  Perhaps we could use `*` or `-` instead of `.` in the zone file.\r\n\r\nRepeating the owner name, without the benefit of name compression, is a bit annoying.  Can you think of a way to avoid the duplication that would be easier for BIND?  It's too bad we don't have a name-compression mode that works within an RR.\r\n\r\n> I'm also wondering if we should be giving up the ability to signal \"no such service\" as is done in SRV, MX is worth it?\r\n\r\nI haven't heard anyone ask for this, so I don't consider it a priority.  If there's an easy way to signal it I'd be OK with including it, but we'd have to think carefully about what it means.  (If there's no HTTPS service, does that mean there's no HTTP service either? What if there are multiple RRs, and only one has this flag?)",
          "createdAt": "2020-06-27T01:45:22Z",
          "updatedAt": "2020-06-27T01:45:45Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Keeping the wire format small and simple for having the name match is important, so I think that part should stay as is. I don\u2019t have much preference for the presentation format here. \u201c.\u201d makes sense by matching the normal interpretation of a zero-length label. However, some other presentation format symbol does as well here. \n\nFor BIND, it\u2019d be nice to hear more clarity for why this was complex. Can the parsing not easily be specialized per type?\n\nAs for communicating that there is no such service, I\u2019d be concerned to see that for things like HTTPS. These are hints that should help upgrade connections to more secure mechanisms (ECH, HTTP/3, etc), but being able to say \u201cdon\u2019t do https\u201d or similar sounds problematic. Unless there\u2019s a use case, I\u2019d argue to leave such functionality off for now. ",
          "createdAt": "2020-06-28T03:04:29Z",
          "updatedAt": "2020-06-28T03:04:29Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Would using something else with the same meaning help?  For example, \"=\" or \"~\" or \"^\" or something might avoid confusion with other uses of \".\"  (which would then just be a single label containing that character in the wire format).",
          "createdAt": "2020-06-28T04:03:52Z",
          "updatedAt": "2020-06-28T04:03:52Z"
        },
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "> > For BIND adding \".\" is owner name meant touching 102 files as every other RR types method for processing additional data needed to changed\r\n> \r\n> That's definitely surprising! We didn't think this would be complicated to implement.\r\n\r\nYou changed the additional section processing paradigm.  Most of those 102 files was saying \"the owner name is not used in this method\".  Part of it was actually passing the name from higher up in the calling stack.  When a nameserver looks up the addresses associates with a NS record it doesn't care about the owner name of the NS record.  It just looks at the RDATA of the record.  The same applies for every other record except these two proposed ones.\r\n\r\nhttps://gitlab.isc.org/isc-projects/bind9/-/merge_requests/2135/diffs?commit_id=232cb0d53bd3ba4f9b3fb0d80d903916b917627c\r\n\r\n> > I'm wondering if making \".\" special like this is worth it?\r\n> \r\n> The most important thing to me is that we have a way to encourage SvcDomainName == owner name when editing the zone file, because this reduces latency under certain conditions. Perhaps we could use `*` or `-` instead of `.` in the zone file.\r\n\r\nYou are assuming that it will take a lot of time for recursive servers to learn about these records.   That is not reality.\r\nSome nameservers do speculative lookups of records missed (no RRset, no cached no data, no cached nxdomain) when doing additional section processing.  BIND does one lookup but it could be made to do more.\r\n\r\n> Repeating the owner name, without the benefit of name compression, is a bit annoying. Can you think of a way to avoid the duplication that would be easier for BIND? It's too bad we don't have a name-compression mode that works within an RR.\r\n\r\nWell if you really want it you would need to signal that the client supports intra RR compress for these types.  That is easy enough to do with a EDNS option (option code + list of types the client supports intra RR compression for).  You would need to get a label type assigned for intra RR compression pointers.   IANA already maintains a registry.  The server would need to do case sensitive compression to preserve DNSSEC signatures for when the record was returned to canonical form for DNSSEC processing.\r\n\r\nhttps://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-10\r\n\r\n> > I'm also wondering if we should be giving up the ability to signal \"no such service\" as is done in SRV, MX is worth it?\r\n> \r\n>  I haven't heard anyone ask for this, so I don't consider it a priority. If there's an easy way to signal it I'd be OK with including it, but we'd have to think carefully about what it means. (If there's no HTTPS service, does that mean there's no HTTP service either? What if there are multiple RRs, and only one has this flag?)\r\n\r\n",
          "createdAt": "2020-06-29T00:03:38Z",
          "updatedAt": "2020-06-29T00:03:38Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> Most of those 102 files was saying \"the owner name is not used in this method\".\r\n\r\nThanks for clarifying.  I presume you're referring to [this change](https://gitlab.isc.org/isc-projects/bind9/-/commit/232cb0d53bd3ba4f9b3fb0d80d903916b917627c) in your experimental branch.\r\n\r\nI'm not familiar with the BIND code, but this seems like a reasonable implementation to me, and suggests that the current spec is not too bad.\r\n\r\n> You are assuming that it will take a lot of time for recursive servers to learn about these records.\r\n\r\nMostly I'm just counting roundtrips.  SVCB queries are always issued in parallel to A/AAAA queries, so if SvcDomainName == owner-name, then there are already queries in flight for the necessary addresses (0 extra roundtrips).  Anything that requires a followup query, whether by the recursive or by the client, adds some amount of latency.\r\n\r\n> Well if you really want it you would need to signal that the client supports intra RR compress for these types. That is easy enough to do with a EDNS option ...\r\n\r\nIf something like this already existed I think we would use it here, but inventing and standardizing it seems like a big project, not justified by the size of the problem.\r\n\r\nI was thinking of something to avoid special-casing \".\" in this way, e.g. \"The SvcDomainName is represented with a one-octet length prefix, followed by a buffer of that length.  The buffer contains a domain name that fills the buffer.  If the name is fully-qualified (ending in an empty label) then it is an absolute name; otherwise it is relative to the owner name.\".  However, I expect this would make your implementation more complex, not less, so I'm not suggesting this change.",
          "createdAt": "2020-06-29T01:08:10Z",
          "updatedAt": "2020-06-29T01:08:10Z"
        },
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "> > Most of those 102 files was saying \"the owner name is not used in this method\".\r\n> \r\n> Thanks for clarifying. I presume you're referring to [this change](https://gitlab.isc.org/isc-projects/bind9/-/commit/232cb0d53bd3ba4f9b3fb0d80d903916b917627c) in your experimental branch.\r\n> \r\n> I'm not familiar with the BIND code, but this seems like a reasonable implementation to me, and suggests that the current spec is not too bad.\r\n> \r\n> > You are assuming that it will take a lot of time for recursive servers to learn about these records.\r\n> \r\n> Mostly I'm just counting roundtrips. SVCB queries are always issued in parallel to A/AAAA queries, so if SvcDomainName == owner-name, then there are already queries in flight for the necessary addresses (0 extra roundtrips). Anything that requires a followup query, whether by the recursive or by the client, adds some amount of latency.\r\n\r\nWhich has to be weighed up against how often it would actually save a query once support for these records is reasonably well deployed.   The only time when the name must differ is when a wildcard record is in use and the looked up name doesn't match target name.   The authoritative servers will be returning the target data as additional records.  Recursive server will accept such records as they will be in bailiwick.  Those records will then be returned to the client.\r\n\r\nIt will also provide no benefit for anything that is using a underscore prefix label.   Which reminds me that I need to add code to detect and prevent such wasted queries.   That's additional code that will need to be added to every client.  \".\" should only be mapped to the owner name for LDH owner names. \r\n> > Well if you really want it you would need to signal that the client supports intra RR compress for these types. That is easy enough to do with a EDNS option ...\r\n> \r\n> If something like this already existed I think we would use it here, but inventing and standardizing it seems like a big project, not justified by the size of the problem.\r\n> \r\n> I was thinking of something to avoid special-casing \".\" in this way, e.g. \"The SvcDomainName is represented with a one-octet length prefix, followed by a buffer of that length. The buffer contains a domain name that fills the buffer. If the name is fully-qualified (ending in an empty label) then it is an absolute name; otherwise it is relative to the owner name.\". However, I expect this would make your implementation more complex, not less, so I'm not suggesting this change.\r\n\r\n",
          "createdAt": "2020-06-29T02:07:50Z",
          "updatedAt": "2020-06-29T02:07:50Z"
        }
      ]
    },
    {
      "number": 206,
      "id": "MDU6SXNzdWU2NTE5NDI2MjI=",
      "title": "The target of a HTTPS/SVCB record SHOULD NOT be below a DNAME",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/206",
      "state": "CLOSED",
      "author": "marka63",
      "authorAssociation": "NONE",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "While DNAMEs if present should be followed, the target of a HTTPS/SVCB records should not be below a DNAME.  All a DNAME does is introduce additional processing and records in the responses for no benefit.",
      "createdAt": "2020-07-07T02:29:04Z",
      "updatedAt": "2020-07-13T03:45:35Z",
      "closedAt": "2020-07-13T03:45:35Z",
      "comments": []
    },
    {
      "number": 211,
      "id": "MDU6SXNzdWU2NTQ5MDE5Njc=",
      "title": "Consistency for service/endpoint/origin naming",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/211",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In #204 there is a cleanup of \"origin\" for the non-HTTPS uses but it also highlights the need for consistent terminology and a terminology section (and terminology scrub).\r\nIt seems to land on:\r\n\r\n* Service = the thing a Service owner wished to delegate.  (\"Origin\" is an HTTPS-specific instance.)\r\n* (something? Endpoint Operator?  Service Operator Endpoint?) = the entity that operates a set of endpoints.\r\n* Endpoint = the thing that gets bound to by an individual SVCB RR   (ie, a set of IPs which share a set of common configuration)\r\n\r\nFrom this, AliasForm delegates a Service to an Endpoint Operator.\r\nIf we are consistent about this, ServiceForm would be better called EndpointForm.\r\n",
      "createdAt": "2020-07-10T16:38:29Z",
      "updatedAt": "2020-07-10T16:44:28Z",
      "closedAt": "2020-07-10T16:44:27Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "I should have finished reading #204 deeply as some of this is already covered there.",
          "createdAt": "2020-07-10T16:44:27Z",
          "updatedAt": "2020-07-10T16:44:27Z"
        }
      ]
    },
    {
      "number": 213,
      "id": "MDU6SXNzdWU2NTUwODAzMzY=",
      "title": "Limit key name length",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/213",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "Presentation format key names are not currently explicitly limited (although the IANA experts would surely reject an absurdly long name).  @marka63 has requested a name length limit.\r\n\r\nPlausible values include 255, 64, and 63.",
      "createdAt": "2020-07-10T23:12:14Z",
      "updatedAt": "2020-07-13T20:12:11Z",
      "closedAt": "2020-07-13T20:12:11Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Why not 63 (consistent with DNS label length limit)?  Can we put the limit in the IANA section?",
          "createdAt": "2020-07-11T15:57:45Z",
          "updatedAt": "2020-07-11T15:57:45Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I would want to update the ABNF so parsers can rely on the length limit.\n\nOn Sat, Jul 11, 2020, 11:57 AM Erik Nygren <notifications@github.com> wrote:\n\n> Why not 63 (consistent with DNS label length limit)? Can we put the limit\n> in the IANA section?\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/MikeBishop/dns-alt-svc/issues/213#issuecomment-657085607>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AABO3SOGGXALWUNGKI53PLTR3CDYJANCNFSM4OXAA4WA>\n> .\n>\n",
          "createdAt": "2020-07-11T16:26:56Z",
          "updatedAt": "2020-07-11T16:26:56Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I added a limit of 63 to #202.",
          "createdAt": "2020-07-11T18:07:40Z",
          "updatedAt": "2020-07-11T18:07:40Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #202 ",
          "createdAt": "2020-07-13T20:12:11Z",
          "updatedAt": "2020-07-13T20:12:11Z"
        }
      ]
    },
    {
      "number": 221,
      "id": "MDU6SXNzdWU2NTY2NDM3Njc=",
      "title": "Relax \"MUST NOT\" on  target equalling owner name",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/221",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From @marka63:\r\n\r\nSection 2.4.1.  AliasMode paragraph 2.  Why have \"MUST NOT\" here?                         \r\n\r\n   The primary purpose of AliasMode is to allow aliasing at the zone\r\n   apex, where CNAME is not allowed.  In AliasMode, TargetName MUST be\r\n   the name of a domain that has SVCB, AAAA, or A records.  It MUST NOT\r\n   be equal to the owner name, as this would cause a loop.\r\n\r\nNameservers and clients need to detect loops regardless of the number of\r\nrecords that form the loop.  All this does is force vendors to write additional\r\ncode to detect this one sub-case of a loop.  These are also the only RR types\r\nthat need to have their owner names available to parse them.\r\n",
      "createdAt": "2020-07-14T14:11:09Z",
      "updatedAt": "2020-10-02T14:26:26Z",
      "closedAt": "2020-10-02T14:26:26Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "What about using SHOULD NOT instead?",
          "createdAt": "2020-07-14T14:11:31Z",
          "updatedAt": "2020-07-14T14:11:31Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "How's the change in #224?",
          "createdAt": "2020-07-17T03:06:48Z",
          "updatedAt": "2020-07-17T03:06:48Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> All this does is force vendors to write additional\r\n> code to detect this one sub-case of a loop.\r\n\r\nI don't think this requirement binds BIND.  It's a requirement on the zone owner.  The user MUST comply; the software MAY enforce compliance.",
          "createdAt": "2020-10-01T02:33:01Z",
          "updatedAt": "2020-10-01T02:33:01Z"
        },
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "> > All this does is force vendors to write additional\r\n> > code to detect this one sub-case of a loop.\r\n> \r\n> I don't think this requirement binds BIND. It's a requirement on the zone owner. The user MUST comply; the software MAY enforce compliance.\r\n\r\nWell the way it is now, zone loading tools would need to check.  Anything a operator is required to do really needs to be checked by the zone parsing tools, because operators don't generally read RFCs.  Additionally it also adds requirements on UPDATE, either the tool sending the update and/or the server processing the update.",
          "createdAt": "2020-10-01T03:45:03Z",
          "updatedAt": "2020-10-01T03:45:03Z"
        },
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "We are in this place today because STD 13's instructions to not allow CNAME with other data where not uniformly enforced.",
          "createdAt": "2020-10-01T03:48:09Z",
          "updatedAt": "2020-10-01T03:48:09Z"
        }
      ]
    },
    {
      "number": 222,
      "id": "MDU6SXNzdWU2NTg3MjE2NzU=",
      "title": "mandatory also needs MUST NOT for escape processing.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/222",
      "state": "CLOSED",
      "author": "marka63",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "key names in the list are all LDH so there is never a need to perform escape processing.",
      "createdAt": "2020-07-17T01:12:36Z",
      "updatedAt": "2020-07-23T01:36:58Z",
      "closedAt": "2020-07-23T01:36:58Z",
      "comments": []
    },
    {
      "number": 225,
      "id": "MDU6SXNzdWU2NTg3OTkyNTA=",
      "title": "Do we allow \"mandatory\" to appear in the \"mandatory list\"?",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/225",
      "state": "CLOSED",
      "author": "marka63",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "My feeling is no as it simplifies processing of the record as you don't have to check for it just to skip it.   Also it is implicitly there just by the presence of the field.",
      "createdAt": "2020-07-17T03:18:06Z",
      "updatedAt": "2020-07-17T04:49:16Z",
      "closedAt": "2020-07-17T04:49:16Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed.  I believe this is already covered in the text:\r\n> This SvcParamKey is always automatically mandatory, and MUST NOT appear in its own value list.",
          "createdAt": "2020-07-17T03:27:49Z",
          "updatedAt": "2020-07-17T03:27:49Z"
        },
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "It's there with the \"also\" in \"MUST also appear\" but that is very subtle.  I suggest adding \"(This implies \"mandatory\" MUST NOT be a element of the list)\" or similar.",
          "createdAt": "2020-07-17T04:41:28Z",
          "updatedAt": "2020-07-17T04:41:28Z"
        }
      ]
    },
    {
      "number": 229,
      "id": "MDU6SXNzdWU2NjQ4MTI4OTk=",
      "title": "Add the expanded form of \"SVCB\" when it's first used",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/229",
      "state": "CLOSED",
      "author": "cbartle891",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Typically, when introducing an acronym, it's useful to include its expanded form with it. That doesn't seem to happen in this document for \"SVCB,\" nor does SVCB appear to be a common DNS term like RR. In fact, SVCB doesn't appear to be an acronym at all, but rather a shortened version of \"Service binding.\" Is this true? If so, indicating that would be helpful.",
      "createdAt": "2020-07-23T22:54:38Z",
      "updatedAt": "2020-09-22T02:24:41Z",
      "closedAt": "2020-09-22T02:24:41Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Isn't this covered in Section 1.4?\r\n\r\n```\r\nSVCB is a contraction of \"service binding\".  The SVCB RR, HTTPS RR,\r\n   and future RR types that share SVCB's format and registry are\r\n   collectively known as SVCB-compatible RR types.\r\n```",
          "createdAt": "2020-07-24T00:34:57Z",
          "updatedAt": "2020-07-24T00:34:57Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "NONE",
          "body": "Ah, that's good, but that's why I specified \"when introducing an acronym.\" It's very delayed to explain an acronym (or abbreviation) 6 pages after it's first used. I've changed the title of this issue accordingly.",
          "createdAt": "2020-07-24T03:48:18Z",
          "updatedAt": "2020-07-24T03:48:18Z"
        }
      ]
    },
    {
      "number": 232,
      "id": "MDU6SXNzdWU2NzE0MDAyNDQ=",
      "title": "Confirm IANA actions for  Service Parameters Registry",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/232",
      "state": "CLOSED",
      "author": "moonshiner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In discussing draft-schwartz-svcb-dns Draft, @bemasc and I were debating the need for \"Standards Action\" vs \"Expert Review\"\r\n\r\nI suggest changing it to \"Expert Review / Specification Required\"",
      "createdAt": "2020-08-02T02:08:06Z",
      "updatedAt": "2020-08-11T18:51:30Z",
      "closedAt": "2020-08-11T18:51:30Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@moonshiner I'm not sure I understand your proposal.  Currently we have 256 Standards Action, 32512 Expert Review, 32512 FCFS, and 255 Private Use.  What are you suggesting?",
          "createdAt": "2020-08-04T15:13:52Z",
          "updatedAt": "2020-08-04T15:13:52Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In talking with Ben, and some discussions during the working group, I was realizing that \"Standards Action\" is a higher bar than \"RFC Required\".  I just wanted to make sure that was good.  But \"Expert Review\" actually should be enough for the second group,and I'm good with that.   Closing. ",
          "createdAt": "2020-08-11T18:51:28Z",
          "updatedAt": "2020-08-11T18:51:28Z"
        }
      ]
    },
    {
      "number": 235,
      "id": "MDU6SXNzdWU2NzQ1MDk5Mjg=",
      "title": "Interpretations of Generic Parameters (Unrecognized Keys)",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/235",
      "state": "CLOSED",
      "author": "rthalley",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hi there!  I'm one of the maintainers of dnspython and have started implementing SVCB.  I'd like to verify a few aspects of my interpretation of generic parameters.\r\n\r\nHere are things I think are true from reading the spec (draft-ietf-dnsop-svcb-https-01), do the authors agree?\r\n\r\n1) The parameter\r\n\r\n   key1=\"\\002h2\"\r\n\r\nis the same as\r\n\r\n   alpn=\"h2\"\r\n\r\nThe clarification I'm looking for is that the wire format value is the format of JUST the value of the parameter, and does NOT include the 2-byte length-of-the-whole-value prefix from the wire encoding as well.  (This makes sense to me as the length would be redundant, but just checking!)\r\n\r\n2) The parameter\r\n\r\n   key2\r\n\r\n(i.e. the generic form of no-default-alpn) by itself is illegal, because a generic thing is always a \"single-valued\" param whose value is the wire format.  There is no value here, so it's an error.   (Section 2.1)\r\n\r\n3) The parameter\r\n\r\n   key2=\r\n\r\nis illegal because the EBNF doesn't allow \"=\" without something following it.  (Section 2.1)\r\n\r\n4) The parameter\r\n\r\n   key2=\"\"\r\n\r\nis the legal way of doing no-default-alpn generically, as it specifies an empty wire format.  (This assumes I'm right about item 1) above.)",
      "createdAt": "2020-08-06T18:17:52Z",
      "updatedAt": "2020-08-08T02:32:23Z",
      "closedAt": "2020-08-08T02:32:23Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "1. Correct!\r\n2. I disagree.  From the draft (\"When the \"=\" is omitted, the \"value\" or value list is interpreted as empty.\"), I would say that `keyN` and `keyN=\"\"` are always equivalent.\r\n3. I agree.",
          "createdAt": "2020-08-06T18:55:54Z",
          "updatedAt": "2020-08-06T18:55:54Z"
        },
        {
          "author": "bwelling",
          "authorAssociation": "NONE",
          "body": "The answer to (2) leads to a followup question - which of `keyN` and `keyN=\"\"` is the preferred form?  (the spec doesn\u2019t really mention canonical text form at all)",
          "createdAt": "2020-08-06T19:05:28Z",
          "updatedAt": "2020-08-06T19:05:28Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not aware of a concept of a \"canonical form\" for DNS zone files.  For a known key, I would probably follow the heuristic you mentioned, using \"\" if the key supports nonempty values, and omitting \"=\" if the key is purely a flag.  For an unknown key ... up to you.",
          "createdAt": "2020-08-06T19:10:34Z",
          "updatedAt": "2020-08-06T19:10:34Z"
        },
        {
          "author": "bwelling",
          "authorAssociation": "NONE",
          "body": "The DNS specifications don't require that all implementations generate the identical text form for all records, but most records are not nearly as complicated as SVCB/HTTPS, and it would be convenient for implementors if the spec provided as much guidance as possible.  The partial examples in the spec are inconsistent about quoting.",
          "createdAt": "2020-08-06T19:18:43Z",
          "updatedAt": "2020-08-06T19:18:43Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, they're deliberately inconsistent to remind the reader that quoting is allowed and optional.\r\n\r\nOne concern about providing too much guidance on formatting is that implementations might become intolerant of inputs that don't match the \"suggested\" form, especially if all the serializers produce similar output.\r\n\r\nPersonally, I view this as a question of aesthetics, and I'm happy to let each implementor make their own choices.",
          "createdAt": "2020-08-06T19:29:02Z",
          "updatedAt": "2020-08-06T19:29:02Z"
        }
      ]
    },
    {
      "number": 239,
      "id": "MDU6SXNzdWU2NzcxNzU3OTI=",
      "title": "Meta:  Why is the implementations list in the code repo?",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/239",
      "state": "OPEN",
      "author": "MikeBishop",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "proposed to close"
      ],
      "body": "This seems better suited to a Wiki page.",
      "createdAt": "2020-08-11T20:28:07Z",
      "updatedAt": "2021-01-15T21:20:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Laziness?  Feel free to move it.",
          "createdAt": "2020-08-11T21:15:00Z",
          "updatedAt": "2020-08-11T21:15:00Z"
        }
      ]
    },
    {
      "number": 240,
      "id": "MDU6SXNzdWU2OTQyODMyMTg=",
      "title": "Address open TODO in spec",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/240",
      "state": "CLOSED",
      "author": "moonshiner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\r\nCurrently in the spec:\r\n\r\nTODO: do we also want to reserve a range for greasing?\r\n\r\n",
      "createdAt": "2020-09-06T07:51:58Z",
      "updatedAt": "2020-10-29T15:10:56Z",
      "closedAt": "2020-10-29T15:10:56Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Removed in #233.  However, I would appreciate your review (@moonshiner) on #262, which attempts to simplify the IANA registry rules.",
          "createdAt": "2020-10-29T15:10:53Z",
          "updatedAt": "2020-10-29T15:10:53Z"
        }
      ]
    },
    {
      "number": 246,
      "id": "MDU6SXNzdWU3MDYwMzMxOTI=",
      "title": "Update Alt-Svc",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/246",
      "state": "OPEN",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "future draft"
      ],
      "body": "While not relevant here, opening up this to track this item for elsewhere...\r\n\r\nTO BE REMOVED: The ALPN semantics in {{AltSvc}} are ambiguous, and\r\nproblematic in some interpretations.  We should update {{AltSvc}}\r\nto give it well-defined semantics that match HTTPS RRs.",
      "createdAt": "2020-09-22T02:26:29Z",
      "updatedAt": "2020-09-22T02:26:29Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 247,
      "id": "MDU6SXNzdWU3MTE1MzEyOTk=",
      "title": "Clarify presentation format for unrecognized keys",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/247",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "NONE",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "\u00a7 2.1 says:\r\n\r\n```\r\nUnrecognized keys are represented in presentation format as\r\n\"keyNNNNN\" where NNNNN is the numeric value of the key type without\r\nleading zeros. SvcParams in this form are always treated as single-\r\nvalued, and the decoded \"value\" SHALL be used as its wire format\r\nencoding.\r\n```\r\n\r\nDoes this mean an unvalued key (empty value) would be presented as `keyNNNNN=`?",
      "createdAt": "2020-09-29T23:33:57Z",
      "updatedAt": "2020-10-26T20:22:05Z",
      "closedAt": "2020-10-26T20:22:05Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "It would be `keyNNNNN` or `keyNNNNN=\"\"`.",
          "createdAt": "2020-09-30T01:40:47Z",
          "updatedAt": "2020-09-30T01:40:47Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "NONE",
          "body": "It might be worth explicitly stating that single-valued with an empty value is equivalent to unvalued.",
          "createdAt": "2020-09-30T14:32:05Z",
          "updatedAt": "2020-09-30T14:32:05Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "The previous sentence says `When the \"=\" is omitted, the value or value list is interpreted as empty.`.",
          "createdAt": "2020-09-30T20:09:39Z",
          "updatedAt": "2020-09-30T20:09:59Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "NONE",
          "body": "The potential for confusion I'm pointing out is that between a zero-length string and no value. (E.g., in Python, the difference between `''` and `None`.) In this case there is no distinction. The reason this might be confusing to some is that there are three types described (empty, single-valued, and multi-valued), but only two in reality: a single string, and an encoded list of strings. That single string might be zero-length, which can be abbreviated by omitting the `=\"\"`.\r\n\r\nI also note there is an added constraint in A.1 that the list of strings in the multi-valued case may not include a zero-length string, which is not clearly simpler to me than simply allowing it, because it then requires special-casing in code that e.g. might want to represent a tuple this way and leave some values blank.",
          "createdAt": "2020-09-30T20:26:31Z",
          "updatedAt": "2020-09-30T20:26:31Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> I also note there is an added constraint in A.1 that the list of strings in the multi-valued case may not include a zero-length string, which is not clearly simpler to me than simply allowing it\r\n\r\nThis limitation is necessary in order for empty lists to be representable.  Otherwise `list-of-things=\"\"` is ambiguous: is it a single-element list containing the empty string, or a list of length zero?  Applying this limitation seemed easier than requiring all servers to implement a more complex syntax.\r\n\r\nNone of this actually restricts the syntax of any future key, which can declare itself \"single-valued\" and then specify any parsing logic that it wants.",
          "createdAt": "2020-09-30T21:28:05Z",
          "updatedAt": "2020-09-30T21:28:05Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Conclusion: Split the multi-value presentation syntax into a separate section (advisory-only), then refer to it normatively from the key definitions that require it.",
          "createdAt": "2020-10-02T14:11:53Z",
          "updatedAt": "2020-10-02T14:11:53Z"
        }
      ]
    },
    {
      "number": 248,
      "id": "MDU6SXNzdWU3MTE1MzI0OTc=",
      "title": "Malformed RRs",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/248",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "NONE",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "\u00a7 2.2 says\r\n\r\n```\r\nClients MUST consider an RR malformed if:\r\n * the parser reaches the end of the RDATA while parsing the\r\nSvcParams.\r\n```\r\n\r\nWon't this always be the case? I know what you mean, but it's probably worth being more precise here, e.g., if the parser reaches the end of the RDATA in a non-terminal state.",
      "createdAt": "2020-09-29T23:37:37Z",
      "updatedAt": "2020-10-01T20:54:34Z",
      "closedAt": "2020-10-01T20:54:34Z",
      "comments": []
    },
    {
      "number": 249,
      "id": "MDU6SXNzdWU3MTE1MzQ1ODA=",
      "title": "Upgrade breakage",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/249",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The behavior normatively specified in \u00a7 2.2 for malformed RRs can lead to upgraded clients failing to follow a SVCB chain accepted by an older client. It says:\r\n\r\n```\r\nClients MUST consider an RR malformed if:\r\n...\r\n* the SvcParamValue for an SvcParamKey does not have the expected\r\nformat.\r\n\r\nNote that the second condition implies that there are no duplicate\r\nSvcParamKeys.\r\n\r\nIf any RRs are malformed, the client MUST reject the entire RRSet and\r\nfall back to non-SVCB connection establishment.\r\n```\r\n\r\nA server that incorrectly specifies a new SvcParam=SvcParamValue will cause clients that can parse said SvcParam to fail, while older clients will ignore it and continue to follow the SVCB chain. Has the alternative of ignoring malformed SvcParamValues been considered? I am actually not sure which behavior produces better outcomes.",
      "createdAt": "2020-09-29T23:43:54Z",
      "updatedAt": "2020-09-30T14:26:27Z",
      "closedAt": "2020-09-30T14:26:27Z",
      "comments": [
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "If a RRset has a broken RR then rejecting the RRset will result in complaints be generated that should make there way back to the operator.   If you just ignore it will never be fixed everybody will have to deploy workaround for the broken record.   All the tools that look at the records then need to handle the broken record in some way.  You need to have different parser behaviour on primary and secondary DNS servers.  Just don't go there.",
          "createdAt": "2020-09-30T00:09:10Z",
          "updatedAt": "2020-09-30T00:09:10Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to the existing behavior. It's true that the transition for new features can be messy in general (if my server's HTTP/2 code is broken, only new clients break). This isn't great, but the alternative is *so* much worse.\r\n\r\nOnce most clients have deployed the new thing, the effect will largely go away. While the new thing is very new, the players are mostly early adopters and thus are more likely to be responsive to complaints of mistakes.",
          "createdAt": "2020-09-30T00:16:19Z",
          "updatedAt": "2020-09-30T00:16:19Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "NONE",
          "body": "Ok, seems fine.",
          "createdAt": "2020-09-30T14:26:27Z",
          "updatedAt": "2020-09-30T14:26:27Z"
        }
      ]
    },
    {
      "number": 250,
      "id": "MDU6SXNzdWU3MTE1MzcyNzY=",
      "title": "Owner name",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/250",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "NONE",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "Although defined in https://www.rfc-editor.org/rfc/rfc8499.html, the term \"owner name\" is used in several places in this document without even giving a clear example of what is meant. Somewhere this could be useful is as a new third paragraph in \u00a7 2.3, e.g.:\r\n\r\n```\r\nThe service name prepended with the sequence of labels appropriate to a protocol\r\nconstitutes the SVCB owner name.\r\n```\r\n\r\nIt seems like it would make sense to reference the Attrleaf pattern here rather than waiting until \u00a7 7.1 and assuming the reader has the context to put the two together.",
      "createdAt": "2020-09-29T23:51:50Z",
      "updatedAt": "2020-10-01T20:54:09Z",
      "closedAt": "2020-10-01T20:54:09Z",
      "comments": []
    },
    {
      "number": 251,
      "id": "MDU6SXNzdWU3MTE1MzkxMjc=",
      "title": "TargetName must match RRTYPE",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/251",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "NONE",
      "assignees": [
        "enygren"
      ],
      "labels": [],
      "body": "\u00a7 2.4.1 says:\r\n\r\n```\r\nThe primary purpose of AliasMode is to allow aliasing at the zone apex, where\r\nCNAME is not allowed. In AliasMode, TargetName MUST be the name of\r\na domain that has SVCB, AAAA, or A records. It MUST NOT be equal to\r\nthe owner name, as this would cause a loop.\r\n```\r\n\r\nFrom my reading, this should say that TargetName MUST be the name of a domain that has AAAA or A records, or records of the same RRTYPE as that of the source record. The intro says that\r\n\r\n```\r\nAll behaviors described as applying to the SVCB RR also apply to the\r\nHTTPS RR unless explicitly stated otherwise.\r\n```\r\n\r\nbut that does not (and should not) explicitly encourage readers to alpha-substitute HTTPS for SVCB in every normative statement.",
      "createdAt": "2020-09-29T23:57:42Z",
      "updatedAt": "2020-10-23T20:40:10Z",
      "closedAt": "2020-10-23T20:40:10Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Brian Dickson also found that line confusing, for a different reason (bottom of [this email](https://mailarchive.ietf.org/arch/msg/dnsop/_Qb7Hsn1NjTJx2UTkdS-KeYIpF0/)).  We should rephrase.",
          "createdAt": "2020-10-01T01:44:30Z",
          "updatedAt": "2020-10-01T01:44:30Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "This was fixed in #224 ",
          "createdAt": "2020-10-23T20:40:10Z",
          "updatedAt": "2020-10-23T20:40:10Z"
        }
      ]
    },
    {
      "number": 252,
      "id": "MDU6SXNzdWU3MTE1Mzk4NDM=",
      "title": "Self-target",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/252",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "proposed to close",
        "wg"
      ],
      "body": "\u00a7 2.5.2 says:\r\n\r\n```\r\nFor ServiceMode SVCB RRs, if TargetName has the value \".\", then the\r\nowner name of this record MUST be used as the effective TargetName.\r\n```\r\n\r\nThis makes sense for HTTPS and any future child RRTYPES that eschew Attrleafs, but it doesn't make a lot of sense for owner names with Attrleafs. Wouldn't it make sense for `.` to refer to the bare domain with the Attrleafs stripped?",
      "createdAt": "2020-09-30T00:00:03Z",
      "updatedAt": "2021-01-15T21:21:00Z",
      "closedAt": "2021-01-15T21:21:00Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is a plausible improvement.  I believe @marka63 previously suggested something similar.\r\n\r\nHowever, I think it may already be too late for this change.  iOS 14 has shipped an implementation of draft-01, and this change would break compatibility with those devices.",
          "createdAt": "2020-09-30T02:06:10Z",
          "updatedAt": "2020-09-30T02:06:10Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "NONE",
          "body": "What would be the downside? Fallback to authority? That seems like an acceptable outcome from shipping a draft implementation without a clean escape hatch.",
          "createdAt": "2020-09-30T02:11:08Z",
          "updatedAt": "2020-09-30T02:11:08Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "True, it's possible that this would be handled transparently via fallback.  ECH will remove the fallback, but (luckily?) ECH isn't defined yet.",
          "createdAt": "2020-09-30T02:15:13Z",
          "updatedAt": "2020-09-30T02:15:13Z"
        },
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "This will only become a issue for clients that are not aware of this expected behaviour and the operator uses \".\" for the target name.\r\n\r\nApple has implicitly committed to shipping a fix for this if it is changed by releasing code against a draft.  Additionally iOS users are relatively quick to apply updates.  I would not be worried about making a change like this.",
          "createdAt": "2020-09-30T02:31:05Z",
          "updatedAt": "2020-09-30T02:31:05Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Per discussion, we're proposing to close this as a wontfix.  It is a nice feature but adds complexity and corner cases and is not necessary.  (There was a little WG support, but only a little.)",
          "createdAt": "2020-10-26T20:23:54Z",
          "updatedAt": "2020-10-26T20:23:54Z"
        }
      ]
    },
    {
      "number": 253,
      "id": "MDU6SXNzdWU3MTE1NDEwNTI=",
      "title": "Attrleaf on HTTPS RRs",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/253",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It seems cleaner to say that the HTTPS RRTYPE always implies the http scheme, so that a non-standard port requires only one prepended label for the port. E.g., https://www.example.com:8443 would involve resolution of the name `_8443.www.example.com` rather than `_8443._https.www.example.com`.",
      "createdAt": "2020-09-30T00:03:41Z",
      "updatedAt": "2020-09-30T14:31:21Z",
      "closedAt": "2020-09-30T14:31:21Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "That would be more compact, but it is not compatible RFC 8552:\r\n\r\n> A global underscored node name is the one that is closest\r\n> to the root of the DNS hierarchy\r\n\r\n> If a public specification calls for use of an underscored node\r\n> name, the global underscored node name -- the underscored name\r\n> that is closest to the DNS root -- MUST be entered into this\r\n> registry.",
          "createdAt": "2020-09-30T01:47:21Z",
          "updatedAt": "2020-09-30T01:47:21Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "NONE",
          "body": "Ah, ok. Details abound. This makes complete sense now.",
          "createdAt": "2020-09-30T14:31:21Z",
          "updatedAt": "2020-09-30T14:31:21Z"
        }
      ]
    },
    {
      "number": 254,
      "id": "MDU6SXNzdWU3MTE1NDExMzI=",
      "title": "Separate TTL and granularity",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/254",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "NONE",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "Why are these in the same section?",
      "createdAt": "2020-09-30T00:03:59Z",
      "updatedAt": "2020-10-01T20:39:48Z",
      "closedAt": "2020-10-01T20:39:48Z",
      "comments": []
    },
    {
      "number": 255,
      "id": "MDU6SXNzdWU3MTE1NDIwMzQ=",
      "title": "HTTP-based protocols: Unclear language",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/255",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "NONE",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "\u00a7 7.6 says:\r\n\r\n```\r\nWe define an \"HTTP-based protocol\" as one that involves connecting to\r\nan \"http:\" or \"https:\" URL. When implementing an HTTP-based\r\nprotocol, clients that use HTTPS RRs for HTTP SHOULD also use it for\r\nthis URL.\r\n```\r\n\r\nI had to read this like 3 times. Why not something like:\r\n\r\n```\r\nAll protocols employing http or https schema URLs SHOULD respect HTTPS\r\nRRs.\r\n```\r\n",
      "createdAt": "2020-09-30T00:06:50Z",
      "updatedAt": "2020-10-01T20:38:20Z",
      "closedAt": "2020-10-01T20:38:20Z",
      "comments": []
    },
    {
      "number": 256,
      "id": "MDU6SXNzdWU3MTE1NDM5MDA=",
      "title": "Make a clean break with the past",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/256",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "NONE",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "To avoid the problem SSL/TLS had for years with ambiguity re: the CN in the presence of the SAN extension, you should clearly state somewhere that when SVCB is available for an authority endpoint, the legacy defaults (hostname on port 80/443) must never be used as a fallback or as part of a pool of options for the client. That, or explain clearly the justification for the current design choice.",
      "createdAt": "2020-09-30T00:12:27Z",
      "updatedAt": "2020-11-02T15:43:34Z",
      "closedAt": "2020-11-02T15:43:34Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "What's the concern here? The current design allows fallback when it is safe, but this is independent of the HTTPS upgrade, which applies regardless of connection fallback.",
          "createdAt": "2020-09-30T01:37:57Z",
          "updatedAt": "2020-09-30T01:37:57Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "NONE",
          "body": "My concern is with \u00a73 step 6.\r\n\r\nRealistically, there will always be legacy authority endpoints to handle the long tail of clients that don't support SVCB. But, this authority endpoint will expect less and less load over time, and at some point may fail to be adequately load balanced. If a problem appears with the SVCB chain that causes all clients to fall back to the authority record, you could get a stampeding herd all directed at the target of that record, effectively creating a DDoS.\r\n\r\nThe justification might be the need to support the type of spec change being discussed in #252. I'm not sure that eliminating fallback is doable, even if it might be a good idea in theory. But it seems like the reasoning should be spelled out somewhere.",
          "createdAt": "2020-09-30T14:51:22Z",
          "updatedAt": "2020-09-30T14:51:22Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> you could get a stampeding herd all directed at the target of that record, effectively creating a DDoS.\r\n\r\nOK, but the alternative would be that those users would have already failed to connect.  Why is that better?\r\n\r\nI think the main motivation for the current fallback logic is that more fallback means more resilience.  Ultimately, I think fallback behaviors are going to vary between clients: different clients have different design considerations, and the standard can't justify strict requirements on this topic.\r\n\r\nIf we did eliminate fallback in the way you describe, we would still probably have to allow it in cases where there are ServiceMode records but none are compatible with the client.  In other words, eliminating fallback would not reduce client complexity.",
          "createdAt": "2020-09-30T15:30:42Z",
          "updatedAt": "2020-09-30T21:38:11Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "NONE",
          "body": "I think I'm not going to be the only one with these questions, which suggests it might be worthwhile to explain the design choice in an appendix. I agree it doesn't belong in the main text along with normative protocol design.",
          "createdAt": "2020-09-30T20:28:39Z",
          "updatedAt": "2020-09-30T20:28:39Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think this is really a design choice.  It's a \"MAY\", documenting that there's no reason to forbid this behavior.  Forbidding the fallback would certainly require a justification (as in Section 8.1).",
          "createdAt": "2020-09-30T21:41:52Z",
          "updatedAt": "2020-09-30T21:41:52Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Conclusion: Remove the item number on this requirement.",
          "createdAt": "2020-10-02T14:48:20Z",
          "updatedAt": "2020-10-02T14:48:20Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Update: Step 5 should be updated so its purpose is clearer and it has normative strength.  Leaving the 4->5 fallback as SHOULD.",
          "createdAt": "2020-10-23T20:21:07Z",
          "updatedAt": "2020-10-23T20:21:07Z"
        }
      ]
    },
    {
      "number": 264,
      "id": "MDU6SXNzdWU3MTM3OTg2NjA=",
      "title": "Multi-CDN example",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/264",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "enygren"
      ],
      "labels": [],
      "body": "We need a good example of how to do multi-CDN without copying information into the customer zone.  It seems like the recommendation here will likely be phrased in terms of having multiple zone files.",
      "createdAt": "2020-10-02T17:51:14Z",
      "updatedAt": "2020-10-23T20:40:50Z",
      "closedAt": "2020-10-23T20:40:50Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #271 ",
          "createdAt": "2020-10-23T20:40:50Z",
          "updatedAt": "2020-10-23T20:40:50Z"
        }
      ]
    },
    {
      "number": 266,
      "id": "MDU6SXNzdWU3MTM4NDQ0NjY=",
      "title": "AliasMode clarification needed",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/266",
      "state": "CLOSED",
      "author": "brian-peter-dickson",
      "authorAssociation": "NONE",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "The specification for AliasMode does not explicitly specify that it **MUST NOT have any SvcParams**.\r\n\r\nThis should be added to the first paragraph of the AliasMode section (currently 2.4.1).\r\n\r\nAlso, the current published draft incorrectly references AliasMode as section 2.4.3 (in the list in the body of 1.2, bullet 1 for SvcPriority.\r\nEither that section (2.4.3) should explicitly indicate that priority=0 means AliasMode and point back to 2.4.1, or the section link for SvcPriority should be removed, or a separate link to the AliasMode section itself should be included in that bit of text (bullet 1 of 1.2).",
      "createdAt": "2020-10-02T19:11:43Z",
      "updatedAt": "2020-10-07T20:33:26Z",
      "closedAt": "2020-10-07T20:33:26Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "The current text is set up so that, while AliasMode currently doesn't have any params, it could have some in the future, and they would be ignored by all existing resolvers and clients.  I don't think an extension like that is likely to happen, but I also don't see a great need to explicitly rule it out.\r\n\r\nI agree that the referencing regarding SvcPriority is a bit unclear.  I've proposed an adjustment to the section structure to reduce confusion in #267.\r\n",
          "createdAt": "2020-10-02T21:29:30Z",
          "updatedAt": "2020-10-02T21:29:30Z"
        },
        {
          "author": "brian-peter-dickson",
          "authorAssociation": "NONE",
          "body": "I think the text would be better if the AliasMode params were distinguished on the \"publisher\" vs \"consumer\" side.\r\nI.e. that the current specification is, \"MUST NOT\" publish records with any SvcParams, but that the rules for handling AliasMode records SHOULD be prepared to handle AliasMode records with SvcParams (and that they should ignore them).\r\nThat would clarify what to publish (including what managed DNS providers need to support for their customers), while still accommodating future updates.\r\nClarity on the publishing side is NOT negotiable, honestly. The spec needs to be 100% complete and consistent on what is or is not in each type of record, as well as how those are to be handled.\r\n(Thanks.)",
          "createdAt": "2020-10-02T21:48:13Z",
          "updatedAt": "2020-10-02T21:48:13Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've opened a PR to clarify the requirements here (#269).",
          "createdAt": "2020-10-06T19:20:21Z",
          "updatedAt": "2020-10-06T19:20:21Z"
        }
      ]
    },
    {
      "number": 268,
      "id": "MDU6SXNzdWU3MTM5NjkzMzI=",
      "title": "Please PLEASE simplify alpn and list representations and encoding/decoding",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/268",
      "state": "CLOSED",
      "author": "brian-peter-dickson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "proposed to close"
      ],
      "body": "The stuff in Appendix A.1 is both moot and confusing.\r\n\r\nIf I understand correctly (after having to read and cross-reference many parts of this document, the ALPN RFC(s), and the IANA table for ALPN), the following is the case:\r\nNO ALPN IDs HAVE EMBEDDED COMMAS.\r\nThus, there is NO need for quoted commas in any ALPN.\r\nAnd, no other values (single or multi) have (or allow) embedded commas.\r\n\r\nCan we please dispense with all of the fancy things showing how to quote commas and how to interpret quoted commas?\r\nIf necessary, place a caveat into the IANA table that ALPN values MUST NOT contain commas in their ID.\r\n\r\nThis reduces ALPN to wire format of one or more <length>string (where length is a single octet), and the presentation format is simply a comma-separated list of strings, possibly enclosed in quotes, with no other quoting necessary.\r\n\r\nThe SvcParameters object itself is, in presentation format, a list separated with whitespace, so there is no ambiguity between the list within an ALPN, and the list of SvcParameters. \r\n\r\nPlease?\r\n\r\nIt would be nice to have a much simpler document, and much easier task for implementing things.",
      "createdAt": "2020-10-03T00:46:21Z",
      "updatedAt": "2021-01-12T15:57:49Z",
      "closedAt": "2021-01-05T20:15:42Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "You're correct: there are no defined ALPN IDs with embedded commas, and adopting that as an assumption would simplify the parsing considerably.  However, ALPN is defined as an \"8-bit clean\" field that can hold anything, so we would presumably have to \"Update\" RFC 7301 to introduce such a restriction.  I'm not convinced that we will find consensus in the TLS WG for that change.\r\n\r\nI'm not really happy about where this has ended up, but I don't have an alternative that seems more likely to get consensus.",
          "createdAt": "2020-10-06T17:16:12Z",
          "updatedAt": "2020-10-06T17:16:12Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "This is similar in spirit to RFC 7838; while all ALPN tokens currently defined can be expressed as `tchar` for use in HTTP headers, that RFC still has to define how to percent-encode bytes which are not `tchar`s because they remain legal bytes for ALPN.  While modifying the ALPN registry would simplify that, I doubt that's something that should be driven through dnsop.\r\n\r\nIf you bring a draft to the TLS WG adding such restrictions to ALPN and it is adopted and progressed, we will happily update this draft to rely on that simplification, though.",
          "createdAt": "2020-10-06T17:29:39Z",
          "updatedAt": "2020-10-06T17:29:39Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed with @MikeBishop and @bemasc .  I've never been a fan of this, but we're stuck with it unless we want to restrict to only support a subset of ALPNs.",
          "createdAt": "2020-10-23T16:04:09Z",
          "updatedAt": "2020-10-23T16:04:09Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "As I proceed with implementation, I'm increasingly leaning toward changing the delimeter from `\\,` to `\\\\,`.  That would allow parsing with a universal first pass (converts `\\\\,` to `\\,`), followed by a second pass that splits on all unescaped commas.  @marka63, would you be OK with that change?  The current text is written to match the code in your branch, but I'm finding that other implementations can't easily match that behavior (e.g. because they do unescaping before checking the RR type).",
          "createdAt": "2020-11-18T18:59:17Z",
          "updatedAt": "2020-11-18T18:59:17Z"
        },
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "Then how do you encode a APLN name that contains \u2018\\,\u2019?  '\\\\,\u2019 and '\\\\\\,\u2019 both become \u2018\\,\u2019 after the first pass.  The current solution is like it is because APLN names can be anything. \n\n> On 19 Nov 2020, at 05:59, Benjamin M. Schwartz <notifications@github.com> wrote:\n> \n> \n> As I proceed with implementation, I'm increasingly leaning toward changing the delimeter from \\, to \\\\,. That would allow parsing with a universal first pass (converts \\\\, to \\,), followed by a second pass that splits on all unescaped commas. @marka63, would you be OK with that change? The current text is written to match the code in your branch, but I'm finding that other implementations can't easily match that behavior (e.g. because they do unescaping before checking the RR type).\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n> \n\n-- \nMark Andrews, ISC\n1 Seymour St., Dundas Valley, NSW 2117, Australia\nPHONE: +61 2 9871 4742              INTERNET: marka@isc.org\n\n",
          "createdAt": "2020-11-18T20:02:54Z",
          "updatedAt": "2020-11-18T20:02:54Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, actual `\\` in the ALPN would presumably need to be double-escaped (`\\\\\\\\` -> `\\\\` -> `\\`).",
          "createdAt": "2020-11-18T20:06:06Z",
          "updatedAt": "2020-11-18T20:06:06Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I've added a PR for this change in #282.  This doesn't eliminate the weirdness of ALPN, but it makes it considerably more contained.  I've now encountered multiple implementations where the draft-02 text would require totally restructuring the parser, so I think something like this change is necessary.",
          "createdAt": "2020-12-16T19:14:55Z",
          "updatedAt": "2020-12-16T19:14:55Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I've merged #282.  This should substantially simplify the implementation of the ALPN zone file syntax, while still enabling representation of arbitrary ALPNs if necessary.  It should make life easier for everyone except @marka63, who has already implemented the previous behavior.  Sorry, Mark.\r\n\r\nThis is not set in stone, but we are approaching WGLC, so please speak now if you can't live with this version.",
          "createdAt": "2021-01-05T20:15:42Z",
          "updatedAt": "2021-01-05T20:15:42Z"
        },
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "Part of the problem here is the assumption that all valid inputs to alpn can be parsed by the existing parser.  I would argue that they can't be.  The behaviour when parsing `alpn=\"a b,c\"` is not defined by the existing specification.  character-string defines double-quote, content, double-quote.  It doesn't define keyname, equals, double-quote, content including space, double-quote.  I can't tell you if `alpn=\"a b,c\"` would be come one or two tokens (`alpn=\"a` and `b,c\"`) because the behaviour of double quote in that position is ill defined.  Is it a literal double quote or does it open up a double quoted string that continues the token?  We had to change our parser just to accept it.\r\n\r\nBTW #282 has `\\2\\` which is illegal.  It is \\DDD not '\\D'.  `\\050\\`",
          "createdAt": "2021-01-12T06:04:48Z",
          "updatedAt": "2021-01-12T06:06:44Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, `SvcParam` is not a `<character-string>`, and cannot necessarily be parsed by an existing character-string parser.  However, I do think that the latest draft is easier to implement and more compatible.  I just updated two zone file implementations whose character-string parsers are able to handle the `key=\"a b,c\"` syntax, but which would have been difficult to update for the previous value-list-char-string syntax.\r\n\r\nThanks for pointing out the `\\2`.  Fix is in #286.",
          "createdAt": "2021-01-12T15:57:49Z",
          "updatedAt": "2021-01-12T15:57:49Z"
        }
      ]
    },
    {
      "number": 273,
      "id": "MDU6SXNzdWU3Mjk4OTE5NTA=",
      "title": "Update acknowledgements",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/273",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We should take a pass through Acknowledgments and add in people who have been commenting and involved but who are not yet listed.  Partial list:\r\n\r\n* Mark Andrews\r\n* Emily Stark\r\n* Eric Orth\r\n* Kyle Rose\r\n* Craig Taylor\r\n* Dan McArdle\r\n\r\nWho else am I mising?  (Feel free to add yourself to this list.)",
      "createdAt": "2020-10-26T20:43:33Z",
      "updatedAt": "2020-10-30T15:34:46Z",
      "closedAt": "2020-10-30T15:34:46Z",
      "comments": []
    },
    {
      "number": 275,
      "id": "MDU6SXNzdWU3MzI0NzM0Mjc=",
      "title": "Document additional information leak in Security Considerations",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/275",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "Looking at components of a URL, today the DNS resolver only learns the hostname component. It does not learn the scheme, port, or path. SVCB changes this and now additionally leaks the scheme and port to the DNS resolver.\r\n\r\nI don't think this is a big deal (ports are uncommon and scheme+port is visible to the network anyway). Also we arguably don't leak the scheme for http vs https since http still needs to do a query to evaluate the upgrade. But we probably should mention this in Security Considerations for completeness.",
      "createdAt": "2020-10-29T16:35:36Z",
      "updatedAt": "2020-10-30T03:15:16Z",
      "closedAt": "2020-10-30T03:15:16Z",
      "comments": []
    },
    {
      "number": 279,
      "id": "MDU6SXNzdWU3NTczMzA0MzU=",
      "title": "Port redirection introduces new cross-protocol attack vector",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/279",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "Port numbers are a mess. :-( They are part protocol distinguisher (both sides agree on the protocol) and part endpoint virtualizer (multiple services on one IP). The virtualizer use case has all but eroded the distinguisher, but some corners still depend on the distinguisher.\r\n\r\nSVCB and HTTPS allows the DNS to replace port numbers, adding a new instance of this. A network attacker can already swap ports and more, but not where the client is in a privileged position on the network. Consider services listening on localhost or a private network. Messing with the ports then means the attacker can direct the client to speak one protocol to a service that's expecting another protocol, mounting a cross-protocol attack. This is especially a concern for non-browser scenarios that may not be used to following URLs everywhere.\r\n\r\nAs a concrete example, consider a production network, with internal services on private addresses. This network does not run user-facing software like browsers, so it hasn't been forced into the browser threat model where anything can fetch any URL. This network runs a service, such as a CDN or web crawler, that fetches externally-controlled URLs. Provided those services only fetch URLs with standard ports, the network can assume a separation between internal non-HTTP services. (And if any internal HTTP services use 80 or 443, we're not cross-protocol and HTTP-based mechanisms like headers work.) Once folks implement SVCB, this assumption breaks and that external URL can direct a TLS ClientHello to any internal service by specifying a private IP and listening port. Combine this with DNS rebinding and TLS session resumption, and the attacker can even include arbitrary data in the middle of the ClientHello.\r\n\r\nIn the browser threat model, this kind of thing is hopeless in general. Even so, we maintain a list of [blocked ports](https://fetch.spec.whatwg.org/#bad-port) for some existing protocols and had to introduce [new ones](https://groups.google.com/a/chromium.org/g/blink-dev/c/tTGznHWRB9U/m/5h2nMRsoAQAJ) recently. ([That attack](https://samy.pl/slipstream/) confused a middlebox rather than an endpoint, but the general issue applies.) The web browser fix for this attack in SVBC/HTTPS is \"obvious\": rerun the bad port check deep in the HTTP stack. However, this only works because browsers usually have bespoke HTTP stacks, and we're already very used to following URLs everywhere. This may not be as simple for other applications. Even in browsers, not the Fetch spec only applies this check at the entry to HTTP, and on redirects. There is no spec infrastructure for extra bad port checks. (The bad port check \"authenticates\" that the port is not a blocked one. SVCB/HTTPS bypasses that authentication.)\r\n\r\nAlt-Svc had this problem too. However:\r\n\r\n* It seems Alt-Svc forgot to document this. A browser implementing Alt-Svc needs to, like SVCB/HTTPS, replicate the bad port check after Alt-Svc. A non-browser HTTP client needs to do... something.\r\n* Alt-Svc requires state to be useful, so it is less likely non-browser HTTP clients implemented it. SVCB/HTTPS does not, which means we're more likely to trip the issue in those clients.\r\n* Not all browsers implemented Alt-Svc, since Alt-Svc had a mistake in its handling of ALPN.\r\n* SVCB supports even more protocols beyond HTTP. Those protocols may not have HTTP's history of following random URLs, so applications may be even more unprepared for this.\r\n\r\nOne mitigating factor is that, for http: and https: URLs, this SVCB/HTTPS records only work for HTTPS. An attack would have to collide a TLS ClientHello against the target protocol, which less likely than plaintext to plaintext. That said, TLS may still intersect with other protocols. The target protocol could happen to use a TLS code point as a delimiter and be too lax to notice other bits. And then there's the ticket issue above.\r\n\r\nAnd then with SVCB, there's no guarantee the source protocol uses TLS, so all bets are off. If I'm reading it right, SVCB is defined for ftp: and other schemes.\r\n\r\nWhat to do about this mess, I'm not sure. Removing port redirection would avoid this problem, and it indeed seems not worth it for most HTTP use cases over TCP. However, over UDP, QUIC benefits from port redirection, and protocol confusion is possible over UDP too.\r\n\r\nWe could go the security considerations route and punt to the application. But with what guidance? What's the right behavior for a general-purpose HTTP library? Should it import the WHATWG bad port list, despite that being browser-specific? That may not be enough for the production network example. Should it expose a callback? What if the application didn't know about the callback and the library is updated... should SVCB/HTTPS records be opt-in? Do we just handwaive and assume TLS won't collide with much? What about tickets? If we assume TLS, what do we tell other protocols? Do we ban SVCB for schemes by default and expect each scheme to opt-in after analyzing its protocol collision risk? How does one even avoid collision with an arbitrary, potentially very lax, protocol?",
      "createdAt": "2020-12-04T18:59:47Z",
      "updatedAt": "2021-01-05T03:25:40Z",
      "closedAt": "2021-01-05T03:25:40Z",
      "comments": [
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "Summarizing the scenario to make sure I understand correctly:\r\nSome client is making URL requests, and to meet some security assumptions/expectations, it is deliberately only making those requests for a specific port or at least blocking requests for some denylist of ports.  The client then hands it off to some library to handle the protocol (eg a general purpose HTTP library).  That library supports SVCB, and could follow port redirection, thereby breaking the client's security assumptions if the request then goes to a port the client would have blocked.\r\n\r\nDid I get that right?",
          "createdAt": "2020-12-04T19:25:22Z",
          "updatedAt": "2020-12-04T19:25:22Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, that's what's going on in terms of mechanism. And in terms of security expectations, we *do* in practice care about what ports get used where. Browsers have that list of bad ports. And any server listening on a private address for some kind of access control is implicitly assuming that folks connecting to that private address are doing so intentionally.\r\n\r\nThe whole expectation is questionably sound at this point given how browsers handle URLs, but it hasn't completely eroded away even in browsers. I suspect there are environments which would care even more, though I'm mostly a browser person.",
          "createdAt": "2020-12-04T21:16:22Z",
          "updatedAt": "2020-12-04T21:16:22Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Lots to think about here, but to your last point:\r\n> Do we ban SVCB for schemes by default and expect each scheme to opt-in after analyzing its protocol collision risk?\r\n\r\n[Section 2.4.3](https://tools.ietf.org/html/draft-ietf-dnsop-svcb-https-02#section-2.4.3) currently says\r\n>   Each protocol scheme that uses SVCB MUST define a protocol mapping\r\n>   that explains how SvcParams are applied for connections of that\r\n>   scheme.\r\n\r\nso ostensibly we are already in that regime.",
          "createdAt": "2020-12-04T21:27:50Z",
          "updatedAt": "2020-12-04T21:27:50Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "My initial inclination is to say that this is an issue between the client and its libraries and just write it up as security considerations.  With or without SVCB, the client as a whole is always still in power over what ports it will allow connections to to be compliant and safe for whatever protocol the client is using.\r\n\r\nAnd for protocols that are only safe over certain defined ports, even if their SVCB scheme definition doesn't ban use of `port`, presumably any well-written library for that protocol should be responsible for ensuring only the safe ports are used regardless of whether or not SVCB is supported.  Even for open-to-most-ports protocols like HTTP, I would argue it would be best for the library to maintain its own bad-port list and enforce such things, but I'm guessing many HTTP libraries don't currently do that.",
          "createdAt": "2020-12-04T21:39:13Z",
          "updatedAt": "2020-12-04T21:39:13Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What's a safe port? The Fetch list is just some standard ports that may collide with HTTP. It doesn't cover, say, a random service running on some random port. For instance, we had a report somewhere about TLS with attacker-controlled session tickets colliding with someone's local development memcached instance. In the browser threat model, this is sadly hopeless anyway (POSTs over cleartext HTTP provide too much attacker control and URLs have had custom ports for a loooong time). In a production environment with a production memcached, it may be more meaningful.",
          "createdAt": "2020-12-05T01:47:50Z",
          "updatedAt": "2020-12-05T01:48:33Z"
        },
        {
          "author": "brian-peter-dickson",
          "authorAssociation": "NONE",
          "body": "This thread raises a separate but related issue.\r\nWhat is being discussed currently references the client, the server, and the DNS authority server(s).\r\nHowever, there are other relevant parties, at least in some very important environments: the networks involved.\r\nSpecifically, in any Enterprise environment (typically using RFC1918 space and NAT to the public internet), the existing mechanisms used for monitoring/alerting, filtering, and (regardless of the perceived legitimacy thereof) MITM TLS (decrypt/re-encrypt), generally assume that HTTPS is on port 443, and ONLY on port 443.\r\n\r\nThe port redirection aspect of HTTPS and SVCB is thorny, in several regards:\r\n- Use of port redirection on public DNS endpoints facilitate evasion of this sort of monitoring\r\n- If significantly abused, the reaction may be to block these new RRTYPEs at the DNS level blindly (regardless of port number used)\r\n- This also impacts the AliasMode use case, since the same RRTYPE is used for AliasMode and ServiceMode\r\n- Blocking would thus impact AliasMode, and basically make the whole SVCB/HTTPS development/deployment a wasted effort\r\n\r\nHow substantial is the likelihood that non-standard ports will be used in a meaningful way outside of private environments?\r\nIs there any realistic way to decouple the port change from the rest of the SVCB/HTTPS design, maybe with additional RRTYPEs?\r\nFor the use cases that require non-standard ports, is the extra round-trip requirement to obtain the extra record (perhaps only by the resolver to populate the cache) a huge obstacle, if an extra RRTYPE is employed for this? Assume the standard port usage would not require the extra lookup.\r\n\r\nE.g. instead of the actual port number in the current field, have a flag (1 or 0) for \"look up the port number\". That would facilitate blocking the other RRTYPE on enterprise firewalls (or DNS firewalls), without affecting standard port usage.",
          "createdAt": "2020-12-05T19:20:03Z",
          "updatedAt": "2020-12-05T19:20:03Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The assumption that HTTPS is only on port 443 has _long_ been broken for those environments and any others where users run web browsers. We'll need spec text to support rerunning the Fetch bad ports check, but otherwise that one should be fairly straightforward.",
          "createdAt": "2020-12-05T19:25:53Z",
          "updatedAt": "2020-12-05T19:25:53Z"
        },
        {
          "author": "brian-peter-dickson",
          "authorAssociation": "NONE",
          "body": "I think you are rejecting this prematurely, as my concern isn't that non-443 might be used, but rather that non-browser people operating these firewalls (or implementing firewall software) might overreact in a way that is harmful to HTTPS/SVCB generally.\r\n\r\nI am not arguing whether the assumption is valid.\r\n\r\nHowever, the question I asked is definitely pertinent.\r\nWould you please answer it, if you know, or if anyone asking for the port number to be included in the core spec has articulated this as a requirement?\r\nThe question is:\r\nHow likely is it that non-standard ports are going to be used?\r\n\r\nAnd the followup question is:\r\nHow critical is that to the use case for HTTPS/SVCB, or that the port be obtained on the same RRTYPE as the other element(s)?",
          "createdAt": "2020-12-05T19:35:24Z",
          "updatedAt": "2020-12-05T19:35:24Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Practically, there are a number of QUIC HTTP/3 endpoints that run on ports other than 443. Since Alt-Svc lets you do this already, it's certainly possible and will happen. \n\nI'd agree with David that this just needs documentation in the security considerations.\n\nIf a network wants to firewall a port, it is far better off blocking that port than trying to do so indirectly by blocking SVCB records.",
          "createdAt": "2020-12-06T19:37:05Z",
          "updatedAt": "2020-12-06T19:37:05Z"
        },
        {
          "author": "brian-peter-dickson",
          "authorAssociation": "NONE",
          "body": "There are 65535 possible ports.\r\nWhich ports would a network want to firewall? They would need to block ALL of the ports EXCEPT the ones they allow.\r\nI.e. you're suggesting reversing the semantics on firewalling of ports.\r\n\r\nThe larger question is about implementing security AT SCALE, not whether it is possible to respond on an instance-by-instance mechanism.\r\nIf it is easier for a network operator to block SVCB/HTTPS records than it is to block ports, I guarantee that at least some of them will do it this way.\r\nThis would be BAD for the usability of SVCB/HTTPS, which is why I am asking for clarification on the usage of non-standard ports.\r\nCould you please point me to the specific documented QUIC HTTP/3 endpoints? Is that a particular operator's choice, or is it part of a standard of some sort? Are they using a specific (small) set of ports, or is it either a large set or an unspecified set? Is that use case mandatory and what depends on that?\r\n\r\nPlus, these are DNS records, which are subject to change without notice, which really makes the whack-a-mole nature of attempting to block ports a terrible idea.\r\n\r\nMy biggest concern is using this as a method to back-door use of DoH if/when networks decide to implement anti-DoH mechanisms, which could lead to the blocking of SVCB records, which is an anti-goal for everyone participating here. Specifically, without regard to the DoH thing, I want there to be no reason for anyone to ever want or need to block SVCB records, so that SVCB/HTTPS can be used for the main thing for which it is the ONLY solution: standardized, interoperable CNAME-at-DNS-zone-apex implementation.\r\n",
          "createdAt": "2020-12-06T20:06:15Z",
          "updatedAt": "2020-12-06T20:06:35Z"
        },
        {
          "author": "brian-peter-dickson",
          "authorAssociation": "NONE",
          "body": "And just to clarify, I'm not proposing blocking alternate ports, nor specifically wanting to make it easy to block alternate ports. However, I do think the alternate ports needs to be functionally \"severable\", so that those who do want to block alternate ports, such as the Great Firewall of China (GFC), have a way that doesn't require disabling SVCB in its entirety.\r\n\r\nFor context, GFC have taken to blocking TLS 1.3 and ESNI, which is a terrible outcome for those who liked other aspects of TLS 1.3 (e.g. session resumption via tickets). Having severable parts might have resulted in GFC allowing through the parts it didn't object to, and thus would have kept the good new functionality available in TLS 1.3.\r\n\r\nThis may be not be easy to reach consensus on, but if the only time an extra DNS query were required was WHEN an alternate port was needed, I don't think the consequences are substantial.\r\n\r\nRight now, today, ALPN works via the ALPN HTTP header stuff, and the ALT-SVC stuff works via the HTTP header stuff. Learning the alternate port requires the initial TLS connection. That is a LOT more expensive than an extra DNS lookup, and yet may require an extra DNS look in addition, if the ALT-SVC is on a different hostname.\r\n\r\nRight now, it also means that for ALT-SVC to even work, the initial connection MUST be on a standard port, OR reached via a URI that includes the \":port\" specifier (which is visible to the browser itself).\r\n\r\nI'm not suggesting keeping the \":port\" in the URI at all, only the use of an extra RRTYPE at the target name, and a flag in the main SVCB or HTTPS record to trigger the lookup (thus avoiding the extra lookup EXCEPT when an actual alternate port is required).\r\n\r\nSo, in the current spec, replace \"port=NNNN\" with \"alt-port\" (flag), and then querying some particular RRTYPE at the owner name (pick a name, maybe SVCBPORT or HTTPSPORT or something like that, or even just ALTPORT). So, not entirely removing the alternate port, only turning the alternate port into a single extra de-reference lookup (whose RR would be cached at a resolver, so extra round trips on DNS queries would be minimized, and where the extra record could even be put in the Additional section, perhaps as part of the handling by the Resolver.)",
          "createdAt": "2020-12-06T21:13:40Z",
          "updatedAt": "2020-12-06T21:13:58Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@brian-peter-dickson TLS 1.3 is a finalized, widely deployed standard that empirically continues to work well in every country.  ESNI is a draft extension that is still under development.  They are indeed entirely \"severable\".\r\n\r\nFor entities who (1) can intermediate the DNS, and (2) are interested in observing or restricting which protocols are used on their network segment, SVCB actually makes life much easier, by encoding the protocol into the QNAME of each query. \r\n This provides a far more direct and reliable protocol indicator than the observed port number.  Also, any \"port=...\" SvcParam in the response is of course plainly visible to a DNS intermediary.  Thus, there is no rational basis for blocking the SVCB QTYPE in pursuit of a port-oriented control scheme.\r\n\r\nI'd like to keep this issue focused on @davidben's concern about guidance for cross-protocol port confusion problems.",
          "createdAt": "2020-12-07T00:37:48Z",
          "updatedAt": "2020-12-07T00:37:48Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I've added text to highlight this concern in #280.  Please review.",
          "createdAt": "2020-12-07T15:52:41Z",
          "updatedAt": "2020-12-07T15:52:41Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "This should now be resolved by the change in #279.",
          "createdAt": "2021-01-05T03:25:40Z",
          "updatedAt": "2021-01-05T03:25:40Z"
        }
      ]
    },
    {
      "number": 283,
      "id": "MDU6SXNzdWU3Nzk0NDI4MTc=",
      "title": "Clarify behavior when no-default-alpn is specified but without alpn specified",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/283",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "enygren"
      ],
      "labels": [],
      "body": "See discussion:  https://github.com/MikeBishop/dns-alt-svc/pull/281/files#r551698492",
      "createdAt": "2021-01-05T19:08:58Z",
      "updatedAt": "2021-01-15T21:31:55Z",
      "closedAt": "2021-01-15T21:31:55Z",
      "comments": []
    },
    {
      "number": 287,
      "id": "MDU6SXNzdWU3ODU2NDI3NDY=",
      "title": "Can you use SVCB without A/AAAA?",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/287",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "It does not look like the draft considers the possibility that a protocol might depend on SVCB exclusively.\r\n\r\nI think that it should be possible to deploy a protocol that only uses SVCB and not A/AAAA to find services.\r\n\r\nThe changes are fairly simple, you go from this text in Section 3:\r\n\r\n>   2.  In parallel, issue AAAA/A queries for $ADDR_QNAME and a SVCB query for $SVCB_QNAME.  The answers for these may or may not include CNAME pointers before reaching one or more of these records.\r\n\r\nTo something like:\r\n\r\n>   2.  If the service allows the use of address records, issue AAAA/A queries for $ADDR_QNAME and a SVCB query for $SVCB_QNAME in parallel.  Otherwise, issue a SVCB query for $SVCB_QNAME.  The answers for these may or may not include CNAME pointers before reaching one or more of these records.\r\n\r\n... and\r\n\r\n> Accordingly, clients SHALL connect to the endpoint consisting of $ADDR_QNAME, the authority endpoint's port number, and no SvcParams.\r\n\r\n... becomes:\r\n\r\n> Accordingly, if the service allows the use of address records, clients connect to the endpoint consisting of $ADDR_QNAME, the authority endpoint's port number, and no SvcParams.\r\n\r\nEdit to note: The reason you might want to do this is that you have a service name (like \"example.com\"), but you don't want the A/AAAA records you use for another protocol (like HTTPS) being used for your fancy new protocol.",
      "createdAt": "2021-01-14T04:34:14Z",
      "updatedAt": "2021-02-18T15:39:55Z",
      "closedAt": "2021-02-18T15:39:55Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I've proposed a paragraph on this in #288; please review.\r\n\r\nI don't think the change proposed here is quite right.  Even if some new protocol relies on SVCB, I think it still makes sense for clients to issue address queries in parallel to the most likely TargetName, for latency hiding.  Issuing those queries doesn't mean they'll be used, even if they resolve, because the TargetName has precedence (if the prediction was wrong).\r\n\r\nUltimately, almost everything about SVCB can be modified by the protocol mapping specification for any protocol, so we don't need to enumerate every plausible behavior here, but I do think it's useful to mention the \"SVCB-reliant\" case.",
          "createdAt": "2021-01-14T15:22:34Z",
          "updatedAt": "2021-01-14T15:22:34Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "To clarify, is the scenario that:\r\n\r\n1) the A/AAAA on the same name as the record would never get used (unless the SvcDomainName was \".\" or otherwise pointed to the record)\r\nor\r\n2) The scenario that this is a protocol for which no address records are involved at all (eg, saying \"use non-IP ansible protocol via a subspace network for a service located by some identifier specified as a SvcParam\", or \"connect via a non-IP unix-domain-socket via some namespace identified in a SvcParam\") ",
          "createdAt": "2021-01-14T17:31:08Z",
          "updatedAt": "2021-01-14T17:31:08Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "\nFWIW, to me, this really really looks like a discussion\nthat ought not be held only as a github issue.\n\nS.\n\nOn 14/01/2021 04:34, Martin Thomson wrote:\n> It does not look like the draft considers the possibility that a protocol might depend on SVCB exclusively.\n> \n> I think that it should be possible to deploy a protocol that only uses SVCB and not A/AAAA to find services.\n> \n> The changes are fairly simple, you go from this text in Section 3:\n> \n>>    2.  In parallel, issue AAAA/A queries for $ADDR_QNAME and a SVCB query for $SVCB_QNAME.  The answers for these may or may not include CNAME pointers before reaching one or more of these records.\n> \n> To something like:\n> \n>>    2.  If the service allows the use of address records, issue AAAA/A queries for $ADDR_QNAME and a SVCB query for $SVCB_QNAME in parallel.  Otherwise, issue a SVCB query for $SVCB_QNAME.  The answers for these may or may not include CNAME pointers before reaching one or more of these records.\n> \n> ... and\n> \n>>         Accordingly, clients SHALL connect to the endpoint consisting of $ADDR_QNAME, the authority endpoint's port number, and no SvcParams.\n> \n> ... becomes:\n> \n>>       Accordingly, if the service allows the use of address records, clients connect to the endpoint consisting of $ADDR_QNAME, the authority endpoint's port number, and no SvcParams.\n> \n",
          "createdAt": "2021-01-14T20:56:17Z",
          "updatedAt": "2021-01-14T20:56:17Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #291",
          "createdAt": "2021-02-18T15:39:55Z",
          "updatedAt": "2021-02-18T15:39:55Z"
        }
      ]
    },
    {
      "number": 293,
      "id": "MDU6SXNzdWU4MTAyOTk3NDE=",
      "title": "Evaluate where else we need to mention SVCB-optional protocols ",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/293",
      "state": "OPEN",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "proposed to close"
      ],
      "body": "There may be a few other places we need to mention the implications of SVCB-optional vs mandatory protocols.  For example:\r\n\r\n* We should clarify that HTTPS is SVCB-optional by default (although that future specifications may build SVCB-required services on top of HTTPS)\r\n* We may wish to add this optional/mandatory status to the non-normative table on protocols\r\n* We should cover the implications on Proxies.  In-particular, for a SVCB-mandatory protocol a client MUST get a SVCB record prior to initiating a CONNECT (if only because this is needed to get the SvcDomainName), at least absent optimizations that may be defined in the future.\r\n\r\nThere may be others that jump out with a read for this in-mind.",
      "createdAt": "2021-02-17T15:44:15Z",
      "updatedAt": "2021-03-18T01:37:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> * We should clarify that HTTPS is SVCB-optional by default (although that future specifications may build SVCB-required services on top of HTTPS)\r\n\r\nI think this is already pretty clear (e.g. [here](https://github.com/MikeBishop/dns-alt-svc/blame/317384a8964912b849aafdc825cd5fa251d8b424/draft-ietf-dnsop-svcb-https.md#L529)).\r\n\r\n> * We may wish to add this optional/mandatory status to the non-normative table on protocols\r\n\r\nThe current text speaks about this as a property of the client, not the protocol or mapping.  While most HTTPS clients should be SVCB-optional, I think it's conceivable that in green-field contexts, SVCB-reliant behavior may be permissible.\r\n\r\n> * We should cover the implications on Proxies.  In-particular, for a SVCB-mandatory protocol a client MUST get a SVCB record prior to initiating a CONNECT (if only because this is needed to get the SvcDomainName), at least absent optimizations that may be defined in the future.\r\n\r\nDo you think there's potential for confusion here?  This seems pretty straightforward to me.  The current text says \"If these concerns apply, the client SHOULD disable SVCB resolution.\", which seems unambiguous, even if the effect is different for SVCB-reliant and SVCB-optional clients.",
          "createdAt": "2021-02-18T14:42:55Z",
          "updatedAt": "2021-02-18T14:42:55Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "I think #295 may be adequate to address this.\r\nThere is no way to implement a SVCB-reliant client as the proxy text currently stands.\r\n(I suspect various forms of privacy proxies will want to use DoH or ODoH or similar lookups\r\nvia a proxy to get SVCB records prior to making CONNECT requests.)",
          "createdAt": "2021-02-18T20:01:59Z",
          "updatedAt": "2021-02-18T20:03:30Z"
        }
      ]
    },
    {
      "number": 296,
      "id": "MDU6SXNzdWU4MTQ0NzI4Mzg=",
      "title": "TargetName presentation format clarity",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/296",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "Is the TargetName supposed to be a FQDN (with trailing dot) in presentation format? The text doesn't seems to [say so](https://tools.ietf.org/html/draft-ietf-dnsop-svcb-https-02#section-2.1) (unless I'm looking at the wrong thing or overlooking something entirely), but the examples seem to suggest it:\r\n\r\n```\r\n   example.com.      7200  IN HTTPS 0 svc.example.net.\r\n   svc.example.net.  7200  IN CNAME svc2.example.net.\r\n```",
      "createdAt": "2021-02-23T13:38:02Z",
      "updatedAt": "2021-02-24T16:36:18Z",
      "closedAt": "2021-02-24T16:36:18Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "TargetName is supposed to be a \"domain name\", which is a specific thing in zone files.  In a zone file, a domain name can be fully-qualified, zone-relative, or even use special syntax like `@`.",
          "createdAt": "2021-02-23T15:00:45Z",
          "updatedAt": "2021-02-23T15:00:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Could we clarify that in the text? I can send a PR if it helps. (I realize this may probably be obvious to DNS experts, but I tripped over it.)",
          "createdAt": "2021-02-23T15:08:30Z",
          "updatedAt": "2021-02-23T15:08:30Z"
        }
      ]
    },
    {
      "number": 298,
      "id": "MDU6SXNzdWU4MTY4NjgxNzM=",
      "title": "\"echconfig\" is an \"ECHConfigs\" struct in ECH",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/298",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "NONE",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "> The SvcParamKey to enable Encrypted ClientHello (ECH) is \"echconfig\".\r\n\r\nThe ECH draft says this is a list of \"ECHConfig\" structs: \"ECHConfigs\".\r\n\r\n> The client-facing server advertises a sequence of ECH configurations to clients, serialized as follows.\r\n> ECHConfig ECHConfigs<1..2^16-1>;\r\n\r\nThis pluralization mismatch tripped me up testing ECH draft-09. ",
      "createdAt": "2021-02-25T22:43:10Z",
      "updatedAt": "2021-08-02T23:38:03Z",
      "closedAt": "2021-08-02T23:38:03Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh oops, I guess this slipped through while this was going through some churn on the ECH side. I'd support renaming the SVCB name to match.",
          "createdAt": "2021-02-26T01:43:30Z",
          "updatedAt": "2021-02-26T01:43:30Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "This was deliberate.  From the DNS perspective, this key contains a unitary base64 blob.  Also, even the list-valued keys here have singular names (alpn=..., mandatory=..., ipv4hint=...).",
          "createdAt": "2021-02-26T01:59:12Z",
          "updatedAt": "2021-02-26T01:59:12Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "The draft does clarify this distinction in Section 9.\r\n\r\nMaybe Section 6.3 could say\r\n> The SvcParamKey to enable Encrypted ClientHello (ECH) is \"echconfig\". Its value, an ECHConfigs vector [ECH], is defined in Section 9.  It is applicable to most TLS-based protocols.\r\n\r\nA little bit of redundancy, but the naming is confusing, imo. Alternatively, perhaps the SVCB key could be \"ech\", just to avoid the clash.",
          "createdAt": "2021-02-26T02:05:23Z",
          "updatedAt": "2021-02-26T02:08:21Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The singular \"echonfig\" name seems likely to confuse things. Plain \"ech\" seems reasonable. (Perhaps we should also re-re-re-reconsider the names in ECH. \"ECHConfigs\" may have been too clever... ECHConfigList?)",
          "createdAt": "2021-02-26T02:12:50Z",
          "updatedAt": "2021-02-26T02:12:50Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "Now would be the right time to do either of those changes. It looks like ECH will need to be revised for the newest HPKE draft, and the wire format of the DNS data will change at that time, too. See https://tools.ietf.org/rfcdiff?url1=https://tools.ietf.org/id/draft-ietf-tls-esni-09.txt&url2=https://tlswg.github.io/draft-ietf-tls-esni/draft-ietf-tls-esni.txt",
          "createdAt": "2021-02-26T02:19:35Z",
          "updatedAt": "2021-02-26T02:19:35Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, there are a lot of revisions we know we need for ECH. :-P",
          "createdAt": "2021-02-26T02:21:30Z",
          "updatedAt": "2021-02-26T02:21:30Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "from a DNS implementer/operator point of view, I would like to +1 this small bit of redundancy.  \r\n\r\n",
          "createdAt": "2021-02-26T14:37:46Z",
          "updatedAt": "2021-02-26T14:37:46Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "The original context for singular/plural is in #127.\r\n\r\nI would prefer to change the name in draft-ietf-tls-esni.  In my view, having structs there named for both the plural and the singular is the main source of confusion.  However, changing the name here is certainly still possible, if increasingly annoying.\r\n\r\nWhile we're talking about changing the name and format, I would also like to revisit the redundant length field.  It seems inelegant, but the main question is what's easiest for TLS library APIs.",
          "createdAt": "2021-02-26T14:55:59Z",
          "updatedAt": "2021-02-26T14:55:59Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "NONE",
          "body": "100% agree that ECHConfigs ending with an S is a source of confusion.  Attempting to summarize the various options:\r\n\r\n| Name of SvcParamKey  | Name for a list of ECHConfig | General sentiment |\r\n| ------------- | ------------- | ----|\r\n| echconfig  | ECHConfigs  | Confusing! |\r\n| echconfigs  | ECHConfigs  | For consistency, it's desirable for the SvcParamKey name to be singular. |\r\n| ech  | ECHConfigs  | Perhaps undesirable because SvcParamKey name does not hint at a type. |\r\n| echconfiglist  | ECHConfigList  | (I'm personally supportive of this one) |\r\n\r\nAlso agree that the redundant length prefix is inelegant, but I'd rather keep it. It's really a coincidence that the length prefixes are the same size, and ECH does not prescribe a delivery mechanism.",
          "createdAt": "2021-02-26T15:24:06Z",
          "updatedAt": "2021-02-26T15:24:06Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I think my favorite pairing is probably \"ech=\" and \"ECHConfigList\"",
          "createdAt": "2021-02-26T15:27:04Z",
          "updatedAt": "2021-02-26T15:27:04Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If I may have a say, I'd go with ECHConfigList also.   \r\n\r\nWonderful table @dmcardle ",
          "createdAt": "2021-02-26T21:05:18Z",
          "updatedAt": "2021-02-26T21:05:18Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "How in-flux is ECH at this point, and how many implementations are out there?  Should we also rev the codepoint for the param when ECH stablizes, or is there no implementations/usage out there that matter yet?",
          "createdAt": "2021-02-26T21:43:35Z",
          "updatedAt": "2021-02-26T21:43:35Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think cloudflare is the primary deployed implementation.  Most others are branches to stable deployed code. ",
          "createdAt": "2021-02-26T21:51:01Z",
          "updatedAt": "2021-02-26T21:51:01Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't believe Cloudflare has deployed ECH with SVCB, so they're not yet creating pressure on this codepoint.\r\n\r\nECH is internally versioned, so as long as ECH doesn't break its own internal format (simple TLV just like SVCB), it can rev versions without creating a problem.",
          "createdAt": "2021-02-26T22:00:30Z",
          "updatedAt": "2021-02-26T22:00:30Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks and that is the best answer.  I don't want to start off throwing away a code point, ",
          "createdAt": "2021-02-26T22:02:09Z",
          "updatedAt": "2021-02-26T22:02:09Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "\n\nOn 26/02/2021 22:00, Benjamin M. Schwartz wrote:\n> I don't believe Cloudflare has deployed ECH with SVCB, \n\nDepends what you call \"deployed\" I guess:\n\n$  dig +short -t TYPE65 crypto.cloudflare.com\n\\# 135 0001000001000302683200040008A29F874FA29F884F000500490047 \nFE0900430013636C6F7564666C6172652D65736E692E636F6D0020C4 \n57457B9DEEC27C7F17A1E90F283FC89DF3B7BB31BEAAB8E91CDEB490 \nA0284000200004000100010000000000060020260647000007000000 \n000000A29F874F260647000007000000000000A29F884F\n\nI don't know of anyone other than developers testing\nECH interop who're using that but you might want to\ncheck with CF.\n\nCheers,\nS.\n\n> so they're not\n> yet creating pressure on this codepoint.\n> \n> ECH is internally versioned, so as long as ECH doesn't break its own\n> internal format (simple TLV just like SVCB), it can rev versions\n> without creating a problem.\n> \n",
          "createdAt": "2021-02-26T22:25:53Z",
          "updatedAt": "2021-02-26T22:25:53Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "The crypto.cloudflare.com server is what lead me to file this issue, and it is sending an obsolete wire format (ECH draft-09) which uses an obsolete HPKE algorithm (draft-irtf-cfrg-hpke-07). I think it's fine to revise all of these things.",
          "createdAt": "2021-02-26T22:57:28Z",
          "updatedAt": "2021-02-26T22:57:28Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't believe Cloudflare has deployed ECH with SVCB, so they're not yet creating pressure on this codepoint.\r\n\r\nAs @sftcd points out, this isn't quite true. Our interop endpoint for -09 is live and is using SVCB to mint ECHConfigLists. But we can easily move to something new as needed. ",
          "createdAt": "2021-02-26T23:03:36Z",
          "updatedAt": "2021-02-26T23:04:28Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "This looks done to me.",
          "createdAt": "2021-08-02T23:38:03Z",
          "updatedAt": "2021-08-02T23:38:03Z"
        }
      ]
    },
    {
      "number": 300,
      "id": "MDU6SXNzdWU4MTc3NTY2OTI=",
      "title": "Decide which reference type you want for Attrleaf",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/300",
      "state": "CLOSED",
      "author": "moonshiner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Normative or Informative? there are both here.\r\n\r\nLine Numbers included. \r\n\r\n92:({{https}}) by avoiding the need for an Attrleaf label {{?Attrleaf=RFC8552}}\r\n332:follows the Attrleaf naming pattern {{Attrleaf}}, so the scheme MUST be\r\n981:By removing the Attrleaf labels {{?Attrleaf}}\r\n1366:For services other than HTTPS, the SVCB RR and an Attrleaf label {{?Attrleaf}}\r\n1394:Registry {{!Attrleaf}}.  The scheme SHOULD have an entry in the IANA URI Schemes\r\n1540:Per {{?Attrleaf}}, please add the following entry to the DNS Underscore",
      "createdAt": "2021-02-26T23:53:11Z",
      "updatedAt": "2021-10-06T19:51:48Z",
      "closedAt": "2021-10-06T19:51:48Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #351",
          "createdAt": "2021-10-06T19:51:48Z",
          "updatedAt": "2021-10-06T19:51:48Z"
        }
      ]
    },
    {
      "number": 305,
      "id": "MDU6SXNzdWU4MzM0MjgxNjE=",
      "title": "Why is the reserved key (65535) called \"invalid\"?",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/305",
      "state": "CLOSED",
      "author": "marka63",
      "authorAssociation": "NONE",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "If the reserved key ever gets used having it be called \"invalid\" will cause interoperability problems because \"invalid\" doesn't have a well defined parsing method.  When you give a key a name it also requires a format definition to be specified otherwise you will have different parsers producing different results.\r\n\r\nI'm presuming if we ever get to the point where we need more named keys that these will end up being encoded, on the wire, inside this key.  If that happens we will need this key be printed out as key65535 whenever there is a unsupported named type inside this key and if they are all known they will be printed out individually.  The name \"invalid\" will never be used.",
      "createdAt": "2021-03-17T05:53:58Z",
      "updatedAt": "2021-03-17T16:19:29Z",
      "closedAt": "2021-03-17T16:19:29Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I've posted #306 to remove this name.\r\n\r\nPersonally, I've found the \"invalid\" name to be somewhat useful when writing test cases, as a reserved name that is syntactically allowed but guaranteed not to collide with any future key.  However, it's true that it could introduce a special case in pretty-printing code, as you describe.  I've tried to split the difference by reserving the name \"invalid\" but not mapping it to any codepoint.\r\n\r\nIn case it's unclear, the purpose of the reservation is to allow code like\r\n```C\r\nuint16 get_key_code(const char* key_name) {\r\n    ...\r\n    return -1;  // Unrecognized or invalid key name\r\n}\r\n```\r\n\r\nOverloading it for extensibility might be safe, but it seems more confusing than allocating an ordinary codepoint for that purpose.",
          "createdAt": "2021-03-17T14:58:38Z",
          "updatedAt": "2021-03-17T14:58:38Z"
        }
      ]
    },
    {
      "number": 310,
      "id": "MDU6SXNzdWU4NDM4Nzk0NDc=",
      "title": "Initial SvcParamKeys is missing mandatory",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/310",
      "state": "CLOSED",
      "author": "marka63",
      "authorAssociation": "NONE",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "While `ServiceMode RR compatibility and mandatory keys` immediately follows `Initial SvcParamKeys`, `mandatory` should be listed in the previous section.",
      "createdAt": "2021-03-29T22:40:16Z",
      "updatedAt": "2021-10-06T19:14:18Z",
      "closedAt": "2021-10-06T19:14:18Z",
      "comments": []
    },
    {
      "number": 315,
      "id": "MDU6SXNzdWU4NTk4OTM3NjM=",
      "title": "Test the Test Vectors",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/315",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We added test vectors in PR #312 .  Now that those are merged, it would be preferable for at least two implementors to test and confirm the test vectors.",
      "createdAt": "2021-04-16T14:59:36Z",
      "updatedAt": "2021-08-17T18:05:49Z",
      "closedAt": "2021-08-17T18:05:49Z",
      "comments": [
        {
          "author": "wtoorop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@enygren The test vectors are part of the [SVCB and HTTPS PR for NSD](https://github.com/NLnetLabs/nsd/pull/167) and used to test the implementation. The PR is currently being reviewed (internally). The test package with the test vectors for NSD can be found here:\r\nhttps://github.com/NLnetLabs/nsd/tree/features/draft-ietf-dnsop-svcb-https/tpkg/svcb.tdir",
          "createdAt": "2021-04-17T09:56:19Z",
          "updatedAt": "2021-04-17T09:56:43Z"
        },
        {
          "author": "pieterlexis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Many of the vectors came from the PowerDNS unit tests, the newest ones have also been added [here](https://github.com/PowerDNS/pdns/pull/10342/files)",
          "createdAt": "2021-05-25T11:33:38Z",
          "updatedAt": "2021-05-25T11:33:38Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!  It sounds like these are confirmed.",
          "createdAt": "2021-08-17T18:05:49Z",
          "updatedAt": "2021-08-17T18:05:49Z"
        }
      ]
    },
    {
      "number": 324,
      "id": "MDU6SXNzdWU4OTU3Mjc1NzI=",
      "title": "Explore constraints that could decrease presentation format parser complexity",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/324",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There has feedback that the current specification introduces significant parser complexity\r\nfor some DNS authorities.  We should explore SvcParamValue presentation format\r\nsimplifications that don't significant usability but would simplify parser corner cases and escaping.\r\nPreferably this would be done by adding limitations so as to not require major changes to existing implementations.\r\n\r\nFor example, for ALPN can we limit the allowed presentation format characters for the SvcParamValue\r\nand require any alpn values wanting characters outside of that set to use base64 encoding (with some way\r\nto indicate this).",
      "createdAt": "2021-05-19T17:58:22Z",
      "updatedAt": "2021-08-17T15:27:36Z",
      "closedAt": "2021-08-17T15:27:36Z",
      "comments": [
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "Would it be reasonable to add any such ALPN character restrictions back to the ALPN identification sequence registry itself? Looking through all the current values (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids), everything seems to currently be a reasonably limited [a-z./-].  Assuming the TLS WG doesn't object, any downside to just formalizing that restriction for all of ALPN?",
          "createdAt": "2021-05-19T19:01:07Z",
          "updatedAt": "2021-05-19T19:01:07Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd be interested in hearing what the TLS folks think of this",
          "createdAt": "2021-05-19T19:05:08Z",
          "updatedAt": "2021-05-19T19:05:08Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Worth considering as well is whether supporting URI templates (a likely common use-case for SvcParamValues) would require complex escaping in the presentation format or whether requiring URI-encoding is good enough.\r\n\r\nIt would be great if we could:\r\n* Get ALPN scope limited at the registry\r\n* Ensure we can handle URI-encoding without complex escaping/encoding\r\n* Use base64 for anything needing binary encoding\r\n* Drop out lots of the complex escaping/encoding rules for SvcParam values and require new SvcParams to not require them escaping or complex encoding in ways that complicate parsing.\r\n",
          "createdAt": "2021-05-19T19:10:37Z",
          "updatedAt": "2021-05-19T19:10:37Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben for input on TLS implications if ALPN is not \"8-bit clean\" in SVCB.  My impression is that this is not appealing from a TLS perspective.\r\n\r\nI have reservations about the idea to \"use base64 sometimes\".  Whether to use base64 would need to be signalled explicitly by another reserved character, resulting in a novel syntax that's substantially more complicated than the current draft.\r\n\r\nAn alternative would be to replace the draft's backslash-escaped CSV with RFC 4180 CSV.  RFC 4180 escaping is more complicated, and less DNS-like, but it might reduce implementation complexity for zone file authors who are able to reuse an existing implementation.  I believe this should be acceptable within the early allocation, as it does not affect the representation of any existing valid ALPN, but I don't know that it would satisfy critics of the current syntax.\r\n\r\nIn principle, we could punt on this question until someone actually tries to register an ALPN with a weird character in it, but that seems likely to create a bunch of headaches, especially related to pretty-printing of wire-format data.  I think we probably need to resolve this now, at least for ALPN.",
          "createdAt": "2021-05-19T20:38:11Z",
          "updatedAt": "2021-05-19T20:38:11Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "This topic was [discussed](https://mailarchive.ietf.org/arch/msg/tls/JqhlkWX0H1F4Hi4pjMOcn1tkm-I/) on the TLS mailing list.  I think it's clear that there is not consensus to narrow the allowed characters in ALPN IDs.  Narrowing the allowed range at the registry level also seemed controversial.\r\n\r\nFor now, I think we need to proceed on the assumption that TLS will not reduce the allowed range.  However, I don't think that means every zone file implementation must be obligated to support the use of characters that no registered ALPN actually uses.  I've proposed #325 as a simplification along that line.",
          "createdAt": "2021-05-24T15:16:21Z",
          "updatedAt": "2021-05-24T15:16:21Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this is resolved by #325.",
          "createdAt": "2021-08-17T15:27:36Z",
          "updatedAt": "2021-08-17T15:27:36Z"
        }
      ]
    },
    {
      "number": 326,
      "id": "MDU6SXNzdWU4OTYxOTEyNzA=",
      "title": "ECH and AltSvc",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/326",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I find the text in the current draft a little too light when it comes to ECH and AltSvc.  I find that I can't work out exactly what to do based on the text that is present.\r\n\r\nEach is fine in isolation:\r\n\r\n* Section 9.1 makes it clear that when a client supports ECH it makes SVC queries always.  If it *requires* ECH then it will insist on receiving an ECH config.  In either case, if there is an ECH config, not getting ECH results in hard failure.\r\n\r\n* Section 8.3 makes it clear that for AltSvc, you just use A/AAAA to find the server.  But that means that you won't have an ECH config.\r\n\r\nThe only text about the combination is this text in Section 8.3:\r\n\r\n> Clients that implement support for ECH MUST perform the HTTPS RR query first, and MUST only make use of Alt-Svc when operating in SVCB-optional mode (see Section 9.1).\r\n\r\nSo, what name is queried for?  I *think* that this refers to the origin.  That is, the client needs to confirm whether the origin has an ECH config in SVCB.  If the ECH config exists, then the client needs to use it (and so it can't use AltSvc).  If the ECH config doesn't exist, then it is free to use AltSvc.\r\n\r\nThis is a valid conclusion, but I haven't seen any real discussion on this point (to be fair, I could have missed it, the volume of messages on this draft means that I've not read all of them).\r\n\r\nI can see why you would prohibit the use of AltSvc if ECH is enabled for the origin.  AltSvc requires that the SNI indicate the origin in the TLS handshake, the origin has indicated (using SVCB) that it wants that information protected, and no means has been provided to protect that information.  I can see other options:\r\n\r\n1. We might allow the origin to indicate that its ECH config applies to alternative services.  That could be a sign that the ECH config at the origin equally applies to all alternatives.  This would be a good outcome in my opinion, but I would need to walk through the implications for distributed deployments.  I think that it's OK because you only get AltSvc after successfully talking to a server and presumably one that has used the ECH config successfully.\r\n\r\n2. We might allow the alternative service to offer its own ECH config and so offer that up through SVCB.  This might need some sort of indication from the origin (as part of AltSvc perhaps, as part of SVCB, or as part of its own ECH config) to delegate this.  In this case, the client requests SVCB for the alternative.  I have some reservations about taking this path; I haven't considered all the implications fully and it seems like there might be a lot of them.\r\n\r\nWhatever the outcome is here, I'm uncomfortable with the level of treatment of this problem in the draft.  It needs more text and - ideally - more debate.\r\n\r\nThe current design has the effect of disabling alternative services in their current form if you deploy ECH.  You might argue that SVCB is largely a replacement for AltSvc, but I would disagree on the basis that AltSvc provides more precise and timely control over how requests are distributed.",
      "createdAt": "2021-05-20T02:21:59Z",
      "updatedAt": "2021-08-17T15:27:14Z",
      "closedAt": "2021-08-17T15:27:13Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "At least for some of this our thinking was that it would be preferable to do an AltSvc-bis that covered these topics.  As we got into them they started getting too deep into details of AltSvc and updating AltSvc in this draft seemed out-of-scope.  We opened #246 to track some AltSvc-related future updates, although that only has one item in it.  (I've started a notes file with potential things to consider for AltSvc-bis).\r\n\r\nIn particular, it seems like most of the ways to do ECH and AltSvc in combination require a draft that updates AltSvc.   We should make sure to not preclude that here, and perhaps we should be more clear in the text that the Section 8.3 text may be modified by a future AltSvc draft.  I'm not sure what the best way to handle this is?",
          "createdAt": "2021-05-20T02:36:58Z",
          "updatedAt": "2021-05-20T02:36:58Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the context @enygren.  I think that no matter what outcome this has, it needs to be better documented than it currently is.  I don't *like* deferral much as it effectively renders AltSvc useless until it is fixed, or at least means that servers need to choose between AltSvc and ECH in that period.  I might be convinced to accept that if we knew approximately the shape of the thing we wanted and we just split the work out so that we can make progress.",
          "createdAt": "2021-05-20T03:38:54Z",
          "updatedAt": "2021-05-20T03:38:54Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "I must have missed this implication in my previous reads through the draft...\r\n\r\nWhat is the logic behind not querying HTTPS when connecting to an AltSvc-provided hostname? If it's some concern around avoiding redirection cycles, I don't think that would be an issue in practice, no more so than a pure AltSvc redirection cycle.  At least in our implementation, once we start attempting a connection to an AltSvc-provided hostname, any new AltSvc is at worst just going to change the hostname used for the next request.\r\n\r\nUntil this thread, my plan for Chrome was that when we had AltSvc info with a different hostname, we would start an h3 connection attempt against it (Chrome only supports connecting to AltSvc hostnames via h3), query A/AAAA/HTTPS, and follow any HTTPS redirection to h3-supporting endpoints, or if no such endpoints, fallback to h3 connection to the A/AAAA.  Then if all that takes too long (or fails), start a racing fallback to attempt an h3 connection attempt against any h3-supporting endpoints found via HTTPS queries for the request hostname.  Maybe I'm missing something reason this is bad, because this still seems like the best plan to me.",
          "createdAt": "2021-05-20T16:29:23Z",
          "updatedAt": "2021-05-20T16:29:23Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> Whatever the outcome is here, I'm uncomfortable with the level of treatment of this problem in the draft.\r\n\r\nOK, let's expand the discussion of that interaction.\r\n\r\n> I don't like deferral much as it effectively renders AltSvc useless until it is fixed, or at least means that servers need to choose between AltSvc and ECH in that period.\r\n\r\nI would quibble with this.  Servers can safely publish both; it's clients that make the choice to use ECH (and thus lose support for Alt-Svc).  Making ECH secure without impairing Alt-Svc for non-ECH clients was a key design goal.\r\n\r\n> What is the logic behind not querying HTTPS when connecting to an AltSvc-provided hostname?\r\n\r\nIntuitively, that would seem weird to me.  SVCB is meant to parallel Alt-Svc, providing an alternative endpoint for the origin with relevant connection metadata.  Stacking them raises a lot of questions, like what is the client supposed to do with conflicting metadata?  The Alt-Svc metadata is better targeted, but there some things (like ECH support) that it currently can't express, and divergence is likely to grow over time as new parameters are defined.  However, this does seem like a behavior that could be defined by a future draft.\r\n\r\nFor background, early versions of this draft solved this by putting an ECHConfig in Alt-Svc as well as SVCB, but that proved controversial so we took it out.  We could revisit this in a revision of Alt-Svc ... or perhaps some experience with SVCB will show that Alt-Svc is not needed when SVCB is in use.",
          "createdAt": "2021-05-20T22:56:05Z",
          "updatedAt": "2021-05-20T22:56:05Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "One approach is to treat the Alt-Svc record the same an AliasMode entry, either defined as such or if an Alt-Svc parameter is present.  This gets the behavior Eric describes.  This is good as it reduces duplication between Alt-Svc and HTTPS RRs.   A question would be how to handle conflicts between the two, specifically around alpn and port.  Do the Alt-Svc alpn and port just get ignored in this case, or are they used to filter the HTTPS RRs?",
          "createdAt": "2021-05-20T23:27:07Z",
          "updatedAt": "2021-05-20T23:27:07Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that the draft is past DNSOP WGLC, I would prefer to avoid substantial revisions to the normative behavior.  I think we can settle this for now with an improved description of the intended behavior, with a clear path to revisions based on operational experience.",
          "createdAt": "2021-05-20T23:43:09Z",
          "updatedAt": "2021-05-20T23:43:09Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So I think that I like @enygren's suggestion to treat AltSvc as AliasMode, but I also agree with @bemasc about the unfortunate nature of the timing (and the potential for this to never finish if we start pulling on these strings).\r\n\r\n> I would quibble with this. Servers can safely publish both; it's clients that make the choice to use ECH (and thus lose support for Alt-Svc). Making ECH secure without impairing Alt-Svc for non-ECH clients was a key design goal.\r\n\r\nSo servers don't make the decision alone: but they will make a decision based on what their clients do.  And there's a really bad outcome here where neither can be used if important clients make different decisions.\r\n\r\nIn any case, I'd really appreciate some text.  Maybe a) explain why you can't use AltSvc when you have an ECH config and b) make a soft promise that some future work will improve the situation.",
          "createdAt": "2021-05-21T02:09:46Z",
          "updatedAt": "2021-05-21T02:09:46Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Please review proposed text at #327.",
          "createdAt": "2021-05-21T04:34:23Z",
          "updatedAt": "2021-05-21T04:34:23Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "That text still isn't convincing, to my perspective, that it would be a bad idea to query A/AAAA/HTTPS when we are making a connection attempt based on Alt-Svc, or that it would be worth the massive complexity to create such different DNS query behaviors.  And if HTTPS records on the Alt-Svc given host/port give us an ECH config, no reason not to use it.\r\n\r\nIf we have a \"remote Alt-Svc\" (that is one with a different host/port) for h3 (note that Chrome ignores Alt-Svc for anything but h3), we really only have two choices, whether to try to connect to that first, or to ignore it for a while as we first start a connection attempt against the original host/port and back out if we don't find an h3 endpoint in DNS.  Ignoring that Alt-Svc seems super silly to me because it's info that's been given to us via a fairly secure mechanism (unlike DoH, it's secure all the way to the server), it's the most likely fastest route to an h3 connection compared to the original host/port that we don't know whether or not it has h3 available until, and unless we skip the HTTPS queries when attempting the connection (which still seems silly to me), ECH can still work just fine if the domain publishes an HTTPS record at that domain, so all these arguments that we can't do this because it breaks ECH are just wrong.\r\n\r\n(Worth noting, that if we have h3 Alt-Svc without a different host/port, we'll just make one h3 connection attempt that first tries to find h3 endpoints in HTTPS records, and if not, falls back to attempting h3 against the A/AAAA records, per traditional Alt-Svc behavior.  That seems consistent with both my current plans and the relevant rules in the current draft.)\r\n\r\nHow about \"Clients that implement support for ECH MUST perform the HTTPS RR query first, and MUST only make use of Alt-Svc when operating in SVCB-optional mode (see {{ech-client-behavior}})\" -> \"... unless the client queries HTTPS and supports ECH when querying Alt-Svc names.\"",
          "createdAt": "2021-05-21T05:40:21Z",
          "updatedAt": "2021-05-21T05:40:49Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "I suppose one could argue that the current draft would even require us to attempt h2/http1.1 connections on HTTPS records before considering Alt-Svc.  That sounds even worse.  All the h3 logic is too tied up into a separate connection path.  We'd have to make an h3 connection attempt that backs out on not finding any h3-supporting HTTPS records.  Then a non-h3 connection attempt that backs out on not finding HTTPS records.  Then a connection attempt using the Alt-Svc info to attempt h3 against the A/AAAA records (after probably checking HTTPS records again).  (And then if the Alt-Svc-backed connection attempt fails or takes too long, another connection attempt to go back to non-h3 and continue even without HTTPS records.)",
          "createdAt": "2021-05-21T05:53:03Z",
          "updatedAt": "2021-05-21T05:53:03Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "I think @ericorth has a good point that the current draft is dangerously underspecified.\r\nThe text:\r\n\r\n> This specification does not alter the DNS records used when connecting \r\n> to an Alt-Svc hostname (typically A and/or AAAA only).\r\n\r\nis vague enough to too much open to interpretation which risks interoperability challenges.\r\nIf we are seeing different clients interpreting it differently now, it may be better clarifying\r\nnow and confirming with the HTTP WG on desired behavior.  (This is in some ways\r\nan IETF Last-Call topic as the issues are interactions with a spec from HTTP WG.)\r\n\r\nOpen questions we seem to land now seem to be:\r\n- Can Alt-Svc be used at all with HTTPS RRs?  The desired answer seems to be yes for SVCB-optional at least.\r\n- Should we do an HTTPS RR lookup for the name included in the Alt-Svc entry?  The desired answer seems to be yes (effectively looking at the Alt-Svc as an AliasMode record)\r\n- What happens with the port in the Alt-Svc entry for the DNS lookup?  Does it impact the name being resolved?  I'd propose that it should be ignored for the purpose of the HTTPS RR name to lookup.\r\n- What happens with the port in the Alt-Svc entry?  Either: 1) any port in the HTTPS RR should take precedence, but the one from the Alt-Svc gets used if none exists;  2) any port in the HTTPS RR takes precedence and the Alt-Svc one is always ignored even if the HTTPS RR lacks one; 3) the Alt-Svc record port is used as a filter\r\n- What happens with the alpn in the Alt-Svc entry?  This is similar to the port with the same options (precedence; alt-svc alpn always ignored; acts as a filter)\r\n- Does this draft need to \"Update\" the Alt-Svc RFC?  Answer depends on the above.\r\n\r\nFor port and ALPN, acting as a filter might have the cleanest semantics but I can see arguments both ways.\r\n\r\nOther issues around Alt-Svc would make sense to defer to an Alt-Svc update, unless there's an import one that I missed.  @ericorth and @martinthomson , do these cover your areas of ambiguity?  Do you think we need to answer the above here and now?\r\n\r\n\r\n\r\n",
          "createdAt": "2021-05-21T13:57:16Z",
          "updatedAt": "2021-05-21T13:57:16Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "As a process matter, I don't think we should Update Alt-Svc, and should avoid any normative language that triggers such an Update.\r\n\r\nAs a technical matter, I don't think we can simply say that Alt-Svc triggers an HTTPS query, for several reasons:\r\n* Security: Alt-Svc values are delivered securely, but the HTTPS RR is not.  Replacing a received Alt-Svc value with data from an HTTPS query could enable a network intermediary to override secure instructions in the Alt-Svc value.\r\n* Targeting: Alt-Svc values are targeted to a single client, but the HTTPS RR is universal.  Overriding it would undo all the Alt-Svc targeting.\r\n* Control/consistency: The Alt-Svc specification does not demand that the origin have full control or ownership of the Alt-host's DNS zone.  In some cases, the appropriate SvcParams for the origin and the Alt-host zones may be different and irreconcilable, especially if the Alt-host name is also used as its own origin or is shared by various origins with different requirements.\r\n\r\nI also think it's counterintuitive: the Alt-Svc field value is logically parallel to a ServiceMode record, so there is no need for further service resolution.\r\n\r\nThese issues are likely surmountable, but solving them will require imposing new limits on how Alt-Svc can be configured, and what kinds of parameters are allowed to be defined in Alt-Svc, or perhaps defining some new Alt-Svc parameters.  I don't think we should try to figure out, and get consensus on, those modifications in this draft.\r\n\r\n> I suppose one could argue that the current draft would even require us to attempt h2/http1.1 connections on HTTPS records before considering Alt-Svc.\r\n\r\nI don't see any requirement for that ... except if ECH is in use, in which case Alt-Svc can't be considered at all.  In general, the priority ordering of connection attempts has little or no normative force.  We can certainly clarify if there is misleading text on this point.",
          "createdAt": "2021-05-21T14:48:24Z",
          "updatedAt": "2021-05-21T14:48:24Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "A lot of this likely comes down to intricacies that are unique to Chrome's processes and our only-partial support for Alt-Svc.  For us, Alt-Svc is just a pointer in triggering connection processes.  We use Alt-Svc to initiate an h3 connection attempt against a given host/port.  It's not really a sensible thing to \"treat it like\" any kind of DNS record because it is controlling different things at a different part of the process.  Any concerns around dealing with conflicting information between Alt-Svc and DNS are not a real concern for us because we do not use Alt-Svc that way and probably never will.  Any attempt to fully define how Alt-Svc and DNS are supposed to work together is probably going to be way too over-specified to meet our specific scenario.\r\n\r\nCan we come up with a simple \"MAY\" addition to let Chrome do what it needs to do here without trying to come up with some complicated scheme to try to create fully-specified algorithm around it?\r\n\r\nOr I suppose the alternative is that we argue that Chrome's Alt-Svc behavior is a unique not-fully-standard thing, and thus not actually making \"use of Alt-Svc\", and thus these HTTPS restrictions don't actually apply, and then I just implement what I need to implement and argue back if anybody ever tries to open a bug saying Chrome shouldn't be doing it.\r\n\r\n> Can Alt-Svc be used at all with HTTPS RRs? The desired answer seems to be yes for SVCB-optional at least.\r\n> Should we do an HTTPS RR lookup for the name included in the Alt-Svc entry? The desired answer seems to be yes (effectively looking at the Alt-Svc as an AliasMode record)\r\n\r\nAt least for Chrome's usage of Alt-Svc, I see no reason not to do this.  All Alt-Svc currently is is a pointer to some other host/port for an h3 connection attempt.  Completely different part of the process from DNS, so that's not really looking at it as an AliasMode record, but that might be the closest analogy when looking at the end result of Chrome behavior.\r\n\r\n> What happens with the port in the Alt-Svc entry for the DNS lookup? Does it impact the name being resolved? I'd propose that it should be ignored for the purpose of the HTTPS RR name to lookup.\r\n\r\nIf Alt-Svc gave us a port, that is now part of the request.  Natural behavior is to use it the same as if the original request contained a port in the URL.  That is that if the port is not 443, initial HTTPS queries are made with a prefix to specify the port.  E.g., if Alt-Svc told us to attempt a connection to example.com:661, we then do a normal connection attempt for that host/port, including asking DNS if there's any HTTPS information for example.com:661.  Anything else would take a bunch of special-case complications to allow a connection attempt to use a port for everything except DNS.  This feels like a case that the HTTPS spec already has reasonable rules to deal with.\r\n\r\n> What happens with the port in the Alt-Svc entry? Either: 1) any port in the HTTPS RR should take precedence, but the one from the Alt-Svc gets used if none exists; 2) any port in the HTTPS RR takes precedence and the Alt-Svc one is always ignored even if the HTTPS RR lacks one; 3) the Alt-Svc record port is used as a filter\r\n\r\nSame thing as if a user typed in a URL with a port or if DNS aliases us to a name with a port.  We already have rules and algorithms to deal with this and don't need anything special.  If an HTTPS record at that port then tells us to connect to a different port, that's what we'll do.\r\n\r\n> What happens with the alpn in the Alt-Svc entry? This is similar to the port with the same options (precedence; alt-svc alpn always ignored; acts as a filter)\r\n\r\nWith or without Alt-Svc, Chrome already has to do this filtering.  Due to complexities around connection sharing, h3 and non-h3 are separate connection flows with separate calls to DNS (but note that due to local caching, we'll generally only make the actual DNS queries once).  If we're in an h3 connection job, whether or not there was an Alt-Svc at the start of the process, we need to look through the results and only consider h3-supporting endpoints.  So while such filtering seems like an extra complication, for Chrome's needs, it's actually the simpler natural behavior.\r\n\r\n> Does this draft need to \"Update\" the Alt-Svc RFC? Answer depends on the above.\r\n\r\nHaven't read the Alt-Svc RFC recently enough to know if anything here completely violates its rules, but my guess would be that no such update is needed.  We're just talking about how DNS is handled as part of a connection attempt after using Alt-Svc to decide to make an h3 connection against some host/port.  Different not-actually-conflicting parts of the overall process.\r\n\r\n> > I suppose one could argue that the current draft would even require us to attempt h2/http1.1 connections on HTTPS records before considering Alt-Svc.\r\n> \r\n> I don't see any requirement for that ... except if ECH is in use, in which case Alt-Svc can't be considered at all. In general, the priority ordering of connection attempts has little or no normative force. We can certainly clarify if there is misleading text on this point.\r\n\r\nWe do not get DNS and know what names will have ECH configs until after we have started connection jobs.  We simply do not know if ECH will be in use until after we have set quite a bit of connection priority ordering.\r\n\r\nI think there's an assumption that clients can always just do all the DNS and then can look at that together with Alt-Svc info and decide what to do.  Seems simple and reasonable, but when you consider all the complications of socket/connection pooling (especially with QUIC), that simply isn't how it works.",
          "createdAt": "2021-05-21T16:25:46Z",
          "updatedAt": "2021-05-21T16:25:46Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Ideally we'd define a behavior that clients can implement reasonably and in a well-defined manner.\r\nIf a major client like Chrome implements something different that Alt-Svc in response to the Alt-Svc header,\r\nthat breaks the ability of servers/operators to deploy Alt-Svc in a standard compliant manner without\r\nalso worrying about how Chrome uses that header but does something differently.\r\n\r\nIf www.example.com has an Alt-Svc which specifies svc.example.com:661 then:\r\n\r\n* I hope/assume that Chrome still treats the origin host as \"www.example.com\" and validates certificates against www.example.com  (as anything other than this would badly break anyone trying to deploy Alt-Svc as specified).\r\n* For HTTPS RR lookups, does it make sense to lookup \"svc.example.com\" or \"_661._https.svc.example.com\" ?   We need to pick one and specify either way or things become dangerously underspecified and hard to deploy.\r\n\r\nAs specified currently for HTTPS, it is always the origin that is used for HTTPS RR lookups, so the current specification doesn't really allow Alt-Svc to lookup an HTTPS RR for \"svc.example.com\" or \"_661._https.svc.example.com\" in the above case.\r\n\r\nOn the topic of \"filtering\" by ALPN, it sounds like this is effectively approach Chrome already takes?\r\nie, if an Alt-Svc is for \"h3\" then HTTPS RRs for \"http/1.1\" and \"h2\" will be ignored?\r\nIf an Alt-Svc is for \"h2\" then will HTTPS RRs for \"h3\" also be ignored?\r\n",
          "createdAt": "2021-05-21T17:13:19Z",
          "updatedAt": "2021-05-21T17:13:19Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "> I hope/assume that Chrome still treats the origin host as \"www.example.com\" and validates certificates against www.example.com (as anything other than this would badly break anyone trying to deploy Alt-Svc as specified).\r\n\r\nCorrect.\r\n\r\n> For HTTPS RR lookups, does it make sense to lookup \"svc.example.com\" or \"_661._https.svc.example.com\" ? We need to pick one and specify either way or things become dangerously underspecified and hard to deploy.\r\n\r\nGood point.  To me \"_661._https.svc.example.com\" is the obvious choice, and what I assumed was intended from the draft until this thread pointed out this situation to me.  \"https://svc.example.com:661\" is the full name for which you are looking up DNS information, and \"_661._https.svc.example.com\" is how you translate that to an HTTPS query.\r\n\r\n> if an Alt-Svc is for \"h3\" then HTTPS RRs for \"http/1.1\" and \"h2\" will be ignored?\r\n\r\nFor the logic handling the h3 connection flow, yes, because that logic is already locked in and only capable of moving on to h3 connections after DNS.  So unless we completely rearchitect all Chrome connection logic (not a practical option), the only way to handle HTTPS info coming from the DNS stack is for the h3 connection logic to look through the results and pick the h3-supporting endpoints.\r\n\r\n(But note that this connection flow might be running in parallel with non-h3 connection flows, typically with a headstart to the h3 flow to make that the preference.  The non-h3 flows are similarly already locked in and only capable of moving on to h1/h2 connections after DNS.)\r\n\r\n> If an Alt-Svc is for \"h2\" then will HTTPS RRs for \"h3\" also be ignored?\r\n\r\nIn theory, that is what we'd likely have to do if we supported h2 Alt-Svc.  (But Chrome ignores Alt-Svc unless h3.)",
          "createdAt": "2021-05-21T17:49:12Z",
          "updatedAt": "2021-05-21T17:49:12Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "If we allow an HTTPS query for the Alt-host, that automatically imposes the following requirements:\r\n* Clients that make such queries cannot rely on any security properties of securely delivered Alt-Svc information, since it can be overridden by a network intermediary.\r\n* Servers that use both must not rely on client-targeting of any parameters other than the Alt-host, since they will be overridden by the untargeted SvcParams.\r\n* Whoever writes the origin's HTTPS record must also control the Alt-host zone contents, to avoid conflicting SvcParams.  This could be difficult to support in current CDNs.\r\n\r\nThe first two considerations may not apply to Chrome's partial implementation, but for this draft we cannot ignore any of them.\r\n\r\nI think HTTPS RRs and Alt-Svc overlap enough in their capabilities that doing both at once may not be worth the complexity and overhead.  I would prefer to avoid creating a lot of complexity in this draft trying to spell out how to integrate them, especially if operational experience may tell us that the wisest course is simply to disable Alt-Svc when HTTPS RRs are in use.\r\n\r\nAn Alt-Svc-bis could be specified with better alignment to HTTPS RRs, perhaps avoiding these issues.",
          "createdAt": "2021-05-21T18:37:00Z",
          "updatedAt": "2021-05-21T18:37:00Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "Keep researching/thinking this through, and I do not think we can make it work without exploding implementation complexity if we strictly comply with the current draft.  We simply cannot make all HTTPS queries before considering Alt-Svc unless we really overcomplicate the behavior around connection jobs, and it leads to silly stuff like having to attempt non-h3 before h3 Alt-Svc, just in case there are HTTPS records with ECH on the non-h3 endpoints when there wasn't anything usable for h3 (seems like a silly scenario to worry about).\r\n\r\nAnd if we have Alt-Svc data, that's a strong enough signal that that host/port supports h3, that it'll only lead to performance issues to run through a whole bunch of other connection logic before attempting to consider the Alt-Svc, so we really need to be able to try it first, and we therefore need a mechanism to get ECH for those endpoints.\r\n\r\nIf we make HTTPS usable with Alt-Svc, that solves all these problems because Alt-Svc-based connections can reasonably get ECH or other HTTPS-only stuff from HTTPS records before any potential updates to Alt-Svc or additions to client support of Alt-Svc (which let's face it, might be an even bigger barrier than Alt-Svc updates), and therefore we don't need to restrict using Alt-Svc.\r\n\r\nMy proposal:\r\n\r\n- HTTPS-supporting clients SHOULD (MAY?) query Alt-Svc host/portss alongside the A/AAAA queries when attempting to use Alt-Svc info (and query the entire Alt-Svc host including the port if different from default port).  MAY be skipped if all supported information was already read from the Alt-Svc.\r\n- Clients querying HTTPS for an Alt-Svc host/ports different from the origin host/port MUST only consider endpoints compatible with any information the client supports using from Alt-Svc and that were read from the specific Alt-Svc info, other than the host/port name where redirects and such are still followed because DNS naturally owns the \"where to go\" question.  (Or maybe we say port must be compatible too and only host is special because host is the one thing that doesn't affect anything except DNS and is already mostly overridable through CNAME.)  In the Chrome case, this compatible endpoints stuff just means only considering h3 endpoints, as our implementation is naturally going to do anyway.  But I think this would also be sufficient for clients making more use of Alt-Svc including Alt-Svc features added in the future.  E.g., if some clients start accepting ECH keys read from Alt-Svc, if such an entry were provided in the Alt-Svc, the client would only be able to use HTTPS endpoints with a matching ECH config.\r\n- Domains/servers/whatever that support ECH and have Alt-Svc with different hosts/ports from the origin SHOULD publish an HTTPS record on the Alt-Svc host/port with the ECH config.\r\n\r\nI think that solves all the concerns and can be added to the draft without too much complexity.\r\n\r\n> - Clients that make such queries cannot rely on any security properties of securely delivered Alt-Svc information, since it can be overridden by a network intermediary.\r\n\r\nThey can rely on it if we only allow compatible HTTPS rather than overriding HTTPS.\r\n\r\n> - Servers that use both must not rely on client-targeting of any parameters other than the Alt-host, since they will be overridden by the untargeted SvcParams.\r\n\r\nAgain, not a problem for compatible merging instead of override merging.\r\n\r\n> - Whoever writes the origin's HTTPS record must also control the Alt-host zone contents, to avoid conflicting SvcParams. This could be difficult to support in current CDNs.\r\n\r\nIf we go with compatible merging, I think the worst-case here is that there are no compatible HTTPS records, and thus it is no worse off than your proposal where HTTPS is not even queried.",
          "createdAt": "2021-05-21T20:31:52Z",
          "updatedAt": "2021-05-21T20:31:52Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "And thinking further through the implications of my proposal, as long as we add the last point (servers publishing HTTPS records with ECH config for the Alt-Svc host) into the current draft, I think it would then be fairly reasonable to leave the rest specifying all the override vs compatible etc behavior for a separate RFC, and Chrome would just be querying HTTPS as pre-standardized behavior in the meantime.  Goes a long way towards the goal of not changing things any more than absolutely necessary now in this draft.",
          "createdAt": "2021-05-21T22:05:44Z",
          "updatedAt": "2021-05-21T22:05:44Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Clients querying HTTPS for an Alt-Svc host/ports different from the origin host/port MUST only consider endpoints compatible with any information the client supports using from Alt-Svc and that were read from the specific Alt-Svc info, other than the host/port name where redirects and such are still followed because DNS naturally owns the \"where to go\" question. \r\n\r\nI don't think that this is necessary.  We need to treat Alt-Svc and DNS both in the same way: as hints.\r\n\r\nYes, the information provided with Alt-Svc is authenticated, so it is arguably more trustworthy than what the DNS says (DNSSEC disclaimer, etc...).  However, I don't think that it helps.  It makes the system more complicated and brittle though.  Let's say that you learn that an ALPN of only \"http/1.1\" is supported for this alternative.  What then if the DNS says that \"h2\" is an option?  Maybe HTTP/2 was just added.  Does the client attempt HTTP/2 anyway?  How does it treat evidence that there was a downgrade?  Of course, ALPN is robust against that particular downgrade, but follow the logic with h3 instead of h2.\r\n\r\nIf you plot out the downgrade protection mechanisms you need here, I think you will find that this works better if you treat information about ALPN and protocol versions as informational.  No matter whether they come from Alt-Svc or DNS.  If the client needs to filter at each stage, you might find that nothing connects.  But if the hints are treated as just that, then the only things that matter are the final HTTPS/SVCB record (which determines what is attempted) and the authenticated connection (which is the ultimate source of authentic information that the client can use to work out if it was attacked).\r\n\r\n> Domains/servers/whatever that support ECH and have Alt-Svc with different hosts/ports from the origin SHOULD publish an HTTPS record on the Alt-Svc host/port with the ECH config.\r\n\r\nI think that is the right answer; it just means modeling Alt-Svc as equivalent to AliasMode.  So the same rationale for parallel A/AAAA and HTTPS queries applies as when Alt-Svc isn't in the mix.",
          "createdAt": "2021-05-24T00:25:24Z",
          "updatedAt": "2021-05-24T00:25:24Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "I think there's a fundamental flaw with treating Alt-Svc as an alias mode record, which is that the server name provided in Alt-Svc could have resources published under its own origin.  Alt-Svc provides an alternative network endpoint to contact the _original_ origin, and doesn't tell you anything about origins with the new hostname in the URL; an HTTPS lookup of the new hostname is talking about origins with that hostname.  Now, hopefully they overlap on things like ECH keys and supported protocols, but I'm not confident they are guaranteed to overlap.\r\n\r\nPerhaps the right integration would be:\r\n\r\n- Do an HTTPS lookup for the origin you intend to connect to (not the alternative).\r\n- If you learn anything about the alternative host (such as ECH keys or additional supported protocols) from the HTTPS lookup, you can use that information.\r\n- Prefer the host(s) indicated in the Alt-Svc, assuming they meet your criteria for use.  Specifically, if you require ECH for your connections and did not find ECH keys for a host, don't use it.\r\n\r\nThat allows servers to use Alt-Svc to indicate preferred alternatives to clients, but leaves the HTTPS path intact for providing information about the alternatives.",
          "createdAt": "2021-05-24T16:33:08Z",
          "updatedAt": "2021-05-24T16:33:08Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> * If you learn anything about the alternative host (such as ECH keys or additional supported protocols) from the HTTPS lookup, you can use that information.\r\n\r\nThis seems like it creates a really weird interaction between Alt-Svc and DNS TTLs.\r\n\r\n> if you require ECH for your connections\r\n\r\nYes, but should clients require ECH for Alt-Svc connections if they used ECH for the initial connection?",
          "createdAt": "2021-05-24T17:20:49Z",
          "updatedAt": "2021-05-24T17:20:49Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think there's a fundamental flaw with treating Alt-Svc as an alias mode record, which is that the server name provided in Alt-Svc could have resources published under its own origin. Alt-Svc provides an alternative network endpoint to contact the _original_ origin, and doesn't tell you anything about origins with the new hostname in the URL; an HTTPS lookup of the new hostname is talking about origins with that hostname. Now, hopefully they overlap on things like ECH keys and supported protocols, but I'm not confident they are guaranteed to overlap.\r\n>\r\n>     * Do an HTTPS lookup for the origin you intend to connect to (not the alternative).\r\n\r\nThis is an operational consideration.  The server configurations specified by both Alt-Svc alternative endpoints\r\nand HTTPS records are decoupled from origin hosts.  There is no reason why a single alternative\r\nendpoint couldn't handle quite a few different origins all sharing the same configuration.\r\n(In fact, I could see this being common for some hosting providers with millions\r\nof virtual sites to point the HTTPS records for all of those sites to the same HTTPS SvcMode \r\nrecord via a mixture of AliasMode and Alt-Svc records.)\r\n\r\n>     * If you learn anything about the alternative host (such as ECH keys or additional supported protocols) from the HTTPS lookup, you can use that information.\r\n\r\nYou can't mix-and-match like this.  You really need to keep the alternative server name in the HTTPS record tied to the SvcParams in that exact same HTTPS record.\r\n\r\n> Targeting: Alt-Svc values are targeted to a single client, but the HTTPS RR is universal. Overriding it would undo all the Alt-Svc targeting.\r\n\r\nThe targeting happens by returning different names.  If we treat the Alt-Svc similar to the target of an AliasMode record then the server can still use the client to decide which HTTPS SvcMode record it wants to name.  The difference is that the name may now point to an HTTPS record rather than just A/AAAA records.\r\n\r\n\r\n\r\n",
          "createdAt": "2021-05-24T17:43:39Z",
          "updatedAt": "2021-05-24T17:43:39Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "There are a ton of options here.\r\n1. Current draft: No change to Alt-Svc.  Alt-Svc doesn't support ECH, so clients don't use Alt-Svc if ECH is on.\r\n2. Alt-Svc as Alias-ish: Clients do an HTTPS query for the Alt-host.  Any ServiceMode record received overrides the Alt-Svc params.\r\n3. Alt-Svc as Filter (@ericorth): Clients do an HTTPS query for the Alt-Host, but restrict any received ServiceMode records to be consistent with the Alt-Svc params before use (according to some criteria specified here).\r\n4. Alt-host Overlap (@mikebishop).  Clients do an HTTPS query for the Origin, but only connect to the Alt-host.  If the Origin's SVCB chain crosses the Alt-host, you're in luck: go to Option 2.\r\n5. New param: Add an Alt-Svc param of some sort to tell the client what to do (e.g. `ech=...`, `svcb-mode=...`).\r\n\r\nA key consideration is whether server operators and origins who want working ECH (for clients who support it) have to worry about their Alt-Svc configuration.  AFAICT, only Option 1 allows server operators to enable ECH without thinking about Alt-Svc.  The other options make ECH insecure with some allowed Alt-Svc configurations.  In other words, they make ECH's security dependent not only on the origin zone, but also on the Alt-host zones.\r\n\r\nEDIT: Paragraph removed.",
          "createdAt": "2021-05-24T18:53:54Z",
          "updatedAt": "2021-05-24T18:55:27Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "> A key consideration is whether server operators and origins who want working ECH (for clients who support it) have to worry about their Alt-Svc configuration. AFAICT, only Option 1 allows server operators to enable ECH without thinking about Alt-Svc. The other options make ECH insecure with some allowed Alt-Svc configurations.\r\n\r\nNot sure I'd agree with that.  I think the starting point for any of these is that a client configured for ECH MUST disregard alternatives (regardless of provenance) for which it doesn't have ECH keys, provided there exists any endpoint for which it does possess ECH keys.  If it has ECH keys for the origin but hasn't found them for an alt-host, however we decide it should do so, then it should ignore its Alt-Svc entry and go with the contents of the HTTPS record.\r\n\r\nIf there's no way to combine info from one to the other, that means Alt-Svc always gets ignored if the origin publishes any options in HTTPS records with ECH keys.  I think that's an acceptable outcome for now.  It would be nice to define (in an updated Alt-Svc draft) how data from HTTPS records can be consumed while using an Alt-Svc entry to connect.",
          "createdAt": "2021-05-24T19:32:06Z",
          "updatedAt": "2021-05-24T19:32:06Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@MikeBishop, think of it as a chain or maybe a ratchet.  Where you enter the ratchet matters, because that is the name you will be using (in SNI and to authenticate the server).  Using AliasMode means that you can enter at any point (CNAME too, just to be complete).  \r\n\r\nIf you have A->B->C, then looking for B will have you connect to C and send B as an SNI.  Looking for A means sending an SNI of A to C instead.  If C has its own resources then you might enter at the chain and send an SNI of C to C.\r\n\r\nAs @enygren says, this chaining is likely to be a common configuration in practice (at least for small numbers of indirections).  \r\n\r\nECH is funny here only in that what C has to say determines whether you expect the alternative service D to have an ECH record.  If C has ECH, then you won't talk to D unless D (or anything it refers to) has ECH.  Alt-Svc is funny in that it doesn't really change the entrypoint.  So if you started with A and you are talking to C, then Alt-Svc to D (which might refer to E) still means that you are using A as the name.  And as you are using the same name, you should use the same ECH posture.  So even though you have been A->B->C->D->E, E still needs to provide ECH and answer correctly when addressed as A.\r\n\r\nSeems fairly straightforward to me.  Of course, that doesn't mean changing the draft under discussion at all.  It just means amending Alt-Svc to use HTTPS.",
          "createdAt": "2021-05-24T22:26:55Z",
          "updatedAt": "2021-05-24T22:47:27Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I've expanded the proposal in #327 based on the feedback.  While it hasn't substantively changed, the new description relaxes some of the language, with the result that it resembles @MikeBishop's proposal.  (When strict ECH is enabled, clients can't escape the Service Bindings, but they can use Alt-Svc to steer within those bindings.)  I think the new text is also more amenable to updates that define how to do ECH with Alt-Svc.",
          "createdAt": "2021-05-25T18:34:10Z",
          "updatedAt": "2021-05-25T18:34:10Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Apologies, I forgot to push my updated text.  #327 is now updated.\r\n\r\nThe key line in this proposed text (similar to the current draft) is \"Origins can publish HTTPS records without any need to modify their existing Alt-Svc arrangements.\".  In my view, there is essentially one alternative, which is to say \"Clients MAY use HTTPS records from the Alt-Svc hostname, so servers SHOULD ensure that those records are consistent with the origin's\".  We cannot delay this decision: once clients and servers are deployed on either assumption, it is locked in.\r\n\r\nThe second option makes it unsafe for multiple origins to share an Alt-Svc hostname if their HTTPS records might differ (even in the future, due to long Alt-Svc cache lifetimes).  If the CDN allows customers to have different HTTPS records, the customers must be partitioned into separate Alt-Svc hostname groups.  If the CDN allows customers to publish their own HTTPS records, it must only use Alt-Svc hostnames that are under the control of the customer.  This seems like it could become a significant burden for CDN operators and customers.\r\n\r\nThis is our choice: do we require client implementors to let the origin's HTTPS record influence Alt-Svc behaviors (current draft), or do we require server operators to publish matching HTTPS records on the Alt-Svc hostname?  Perhaps someone with more CDN experience can comment on how difficult this would be.",
          "createdAt": "2021-05-26T17:50:06Z",
          "updatedAt": "2021-05-26T17:50:06Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "> If the CDN allows customers to publish their own HTTPS records, it must only use Alt-Svc \r\n> hostnames that are under the control of the customer. \r\n\r\nI don't follow this?  Why doesn't the Alt-Svc hostname just want to be under the same\r\ndomain of control as the HTTPS SvcMode record?  ie, a CDN would return an \r\nAlt-Svc hostname that it selects and has an HTTPS RR.  In a multi-CDN case, \r\nCDN Alpha would return one Alt-Svc hostname corresponding to its own HTTPS RRs, and CDN Bravo would return one Alt-Svc hostname corresponding to its own HTTPS RRs, and an origin not on a CDN would do the same.\r\n\r\nI guess the case which could be tricky when Alt-Svc is to \":443\" so uses the origin name as the Alt-Svc hostname so this could switch CDNs, but this can already switch CDN's with Alt-Svc today in this case.  Worst case seems to be that the client has to abandon the Alt-Svc and go back to HTTPS RRs targetted by the origin hostname.\r\n",
          "createdAt": "2021-05-26T17:59:10Z",
          "updatedAt": "2021-05-26T17:59:10Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> Why doesn't the Alt-Svc hostname just want to be under the same domain of control as the HTTPS SvcMode record?\r\n\r\nYes, that's what I mean.  In the alternative designs, if a hosting provider permits its customers to publish their own ServiceMode records, it must only use Alt-Svc hostnames that they control.  In some CDN arrangements (e.g. static IP hosting), the norm is currently for all records to live in the customer's zone.\r\n\r\nIf the CDN publishes its own ServiceMode records (as expected in the common case), then this consideration does not apply.  However, even if the CDN controls all the records, the alternative designs still create a synchronization requirement if the CDN can generate different ServiceMode records for different customers.",
          "createdAt": "2021-05-26T18:21:35Z",
          "updatedAt": "2021-05-26T18:21:35Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "Summarizing the options from the perspective of client behavior, I see two options here:\r\n\r\n1. Use Alt-Svc to get the request host/port and pass that off to the connection logic similarly to a non-Alt-Svc host/port (which is the origin), and as a result of treating it similarly to non-Alt-Svc stuff, the connection/DNS logic makes the normal A/AAAA/HTTPS queries  (all for the request host/port which is the alt-svc hostname) and ECH is supported via ECH keys in the resultingly queried HTTPS records.  From an external-behavior perspective, this works out as \"treat Alt-Svc as an alias\".\r\n\r\n   Pros:\r\n   - Minimizes client complexity because it minimizes differences between Alt-Svc and non-Alt-Svc connections.  And minimizing client complexity means more adoption and less accidental adoption of spec-non-compliant behavior.  (Somebody is bound to query HTTPS for Alt-Svc hostnames whether or not that is the intention, so it's safer if we define how that is done.)\r\n   - Easier partial/transition adoption of HTTPS.  E.g., if some client just wants to query HTTPS to get ECH keys (either because that is all the client cares about or because that is just the first step towards full support of all HTTPS-allowed behavior), that client can mostly just add HTTPS queries alongside A/AAAA queries, and add the logic to handle HTTPS results including using ECH.  No need to alter bigger-picture parts of the connection logic that a client likely would not need to alter if not (yet) supporting things like DNS-based upgrade to h3.\r\n   - If we think we're eventually going to want HTTPS queries with Alt-Svc, it's safer to define now how that works.  Vs if we say for now that it's forbidden, servers may make assumptions that clients will never ever do it, e.g. by specifying HTTPS records that are incompatible if the client got to the host/port through an Alt-Svc.  We wouldn't be able to safely change the interaction without a new Alt-Svc or a new HTTPS.\r\n   \r\n   Cons:\r\n   - Complicates/slows standardization of this spec.  Need to coordinate with the HTTPS WG because, depending on the specifics of the Alt-Svc spec that I haven't studied in too much detail lately, this either updates Alt-Svc, or in the least, reduces some flexibility around potential future changes to Alt-Svc (because any future Alt-Svc parameters need to account for how they may interact with information from HTTPS).\r\n   - As Ben noted above, could force servers to ensure unique Alt-Svc hostnames per origin to allow different HTTPS information on each of those hostnames.  But I would assume this isn't actually a problem unless some implementor (especially a CDN) has specific problems with it.  It's just the general nature of HTTPS records that if you have origin-specific parameters, that you shouldn't let any chains from other origins point to the domain with those HTTPS records.  Seems the same issues to me as CNAME/HTTPS alias redirection.  If somebody wants origin-specific parameters, they also need to update their CNAMEs to point to origin-specific domains rather than a big shared domain.\r\n\r\n2. Alter a bunch of connection logic to block querying HTTPS for Alt-Svc names and ensure Alt-Svc is not used if the origin has HTTPS records (or at least HTTPS records that would result in using ECH).\r\n\r\n   Pros:\r\n   - Other than maybe cleaning up some explanations, this is pretty much what we currently have written in the draft, so it's the best path to getting the spec standardized as soon as possible.\r\n   - No coordination/changes needed with Alt-Svc.  Alt-Svc and HTTPS are effectively treated as two completely isolated mechanisms with interactions disallowed.\r\n\r\n   Cons:\r\n   - Except for extremely simple clients that just do all the DNS for the origin, and then attempt to connect to the results, this option requires a lot of non-obvious complex changes to client implementations and all their connection logic.  Real-world client implementations, especially browsers, have a lot of complexity in the connection logic, and you really do not want to mess with that any more than necessary.  I previously said this may require insurmountable complexity around kicking off a whole bunch of semi-concurrent connection jobs for all the different combinations of parameters that may get used for the eventual connection (with/without Alt-Svc, h3 vs non-h3, etc).  We think we may have found a way to make it more in the realm of possible by altering some of our h3 jobs to run concurrent DNS requests for Alt-Svc name and the origin and decide on cancelling out of using Alt-Svc names depending on DNS results from the origin, but there's still a lot of hidden complexity here that I would prefer not to introduce to already-complex code, and I might easily later discover some reason this plan doesn't work.",
          "createdAt": "2021-05-26T19:20:31Z",
          "updatedAt": "2021-05-26T19:20:31Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "> > Clients querying HTTPS for an Alt-Svc host/ports different from the origin host/port MUST only consider endpoints compatible with any information the client supports using from Alt-Svc and that were read from the specific Alt-Svc info, other than the host/port name where redirects and such are still followed because DNS naturally owns the \"where to go\" question.\r\n> \r\n> I don't think that this is necessary. We need to treat Alt-Svc and DNS both in the same way: as hints.\r\n> \r\n> Yes, the information provided with Alt-Svc is authenticated, so it is arguably more trustworthy than what the DNS says (DNSSEC disclaimer, etc...). However, I don't think that it helps. It makes the system more complicated and brittle though. Let's say that you learn that an ALPN of only \"http/1.1\" is supported for this alternative. What then if the DNS says that \"h2\" is an option? Maybe HTTP/2 was just added. Does the client attempt HTTP/2 anyway? How does it treat evidence that there was a downgrade? Of course, ALPN is robust against that particular downgrade, but follow the logic with h3 instead of h2.\r\n\r\nServers shouldn't send the client an HTTPS record saying \"you can use h3 if you go here\" if they don't want the client connecting h3 to that endpoint.  So from that perspective, this seems reasonable to me.  Once that record has been received by the client, after following some chain from the origin, it seems reasonable to use it, even if one of the chain links said \"go over to this hostname if you want h2\".\r\n\r\nBut if you get to an h3 endpoint via an h2 Alt-Svc, is it also acceptable for the client to attempt an h2 connection to that endpoint, as would seem reasonable if we treat these purely as hints, or would h2 only be usable on falling back to the Alt-Svc A/AAAA per SVCB-optional behavior (which would seem essentially equivalent to the \"override\" behavior previously discussed)? Unless we justify it as the Alt-Svc ALPNs getting merged with any HTTPS ALPNs, attempting h2 would seem to be changing the \"Clients SHOULD NOT attempt connection to a service endpoint whose SVCB ALPN set does not contain any supported protocols\" rule.\r\n\r\nAnd what about any Alt-Svc params added in the future where it really doesn't make sense to treat them as hints or allow overriding? I suppose it could be argued that this is safe to decide in the future when/if such params are ever added (but only if the HTTPS WG is okay with this implicit requirement being placed on future development of Alt-Svc).",
          "createdAt": "2021-05-26T19:48:18Z",
          "updatedAt": "2021-05-26T19:48:18Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I still don't see why implementing support for #326 is hard.  HTTPS queries are for the origin, and Alt-Svc doesn't change the origin.  With Alt-Svc, every connection job has a \"target\" and an origin (which are the same except in remote alt-svc), and each job should query A/AAAA for the former and HTTPS for the latter, whether they're the same or different.\r\n\r\nHowever, I've written up #329 as an alternative to #326, describing what I think @ericorth is proposing.  Hopefully that lets us compare the options head-to-head.",
          "createdAt": "2021-05-26T21:25:30Z",
          "updatedAt": "2021-05-26T21:25:30Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this is resolved by #329.",
          "createdAt": "2021-08-17T15:27:13Z",
          "updatedAt": "2021-08-17T15:27:13Z"
        }
      ]
    },
    {
      "number": 330,
      "id": "MDU6SXNzdWU5MTg5NzI4MTc=",
      "title": "Wrong section referenced in RFC8126",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/330",
      "state": "CLOSED",
      "author": "ericorth",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Minor citation bug.  Section 14.3.1 (IANA Considerations > New registry for Service Parameters > Procedure):\r\n\r\n> Entries in this registry are subject to a First Come First Served registration policy ({{!RFC8126}}, Section 4.6).\r\n\r\nWrong section.  \"First Come First Served\" is RFC8126, Section 4.4.  The currently-cited 4.6 is actually \"Specification Required\".",
      "createdAt": "2021-06-11T16:44:08Z",
      "updatedAt": "2021-06-11T16:47:33Z",
      "closedAt": "2021-06-11T16:47:11Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2021-06-11T16:47:33Z",
          "updatedAt": "2021-06-11T16:47:33Z"
        }
      ]
    },
    {
      "number": 338,
      "id": "MDU6SXNzdWU5ODgwMzAzODU=",
      "title": "Lingering use of SvcDomainName",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/338",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "There is one remaining instance of SvcDomainName that should be changed to TargetName:\r\n\r\n```\r\nClients may thus find a SvcDomainName pointing to a name other than the one which returned along with the A and AAAA lookups and will need to do an additional resolution for them.\r\n```",
      "createdAt": "2021-09-03T19:02:35Z",
      "updatedAt": "2021-09-08T01:08:45Z",
      "closedAt": "2021-09-08T01:08:45Z",
      "comments": []
    },
    {
      "number": 340,
      "id": "MDU6SXNzdWU5OTE0NTk2MDU=",
      "title": "HTTPS as a protocol",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/340",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "OWNER",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "The document pervasively refers to \"HTTPS\" as a protocol.  However, the current terminology appears to be that HTTP is a protocol, which can be used to access \"http\"-schemed and \"https\"-schemed URIs, as well as other schemes which might be transported.  We should do a pass over the document and ensure our use of HTTP/HTTPS/\"http\"/\"https\" is consistent with https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html.",
      "createdAt": "2021-09-08T19:29:49Z",
      "updatedAt": "2021-10-07T20:02:54Z",
      "closedAt": "2021-10-07T20:02:54Z",
      "comments": []
    },
    {
      "number": 342,
      "id": "I_kwDOBsWBq8472rKM",
      "title": "Clarify whether SvcParams is mandatory or optional",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/342",
      "state": "CLOSED",
      "author": "silverwind",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I would like to know whether a record without any `SvcParams` should be considered valid. Reading through sections 2, it is not immediately clear whether `SvcParams` is mandatory or optional. Section 2 says\r\n\r\n> SVCB RRs are extensible by a list of SvcParams\r\n\r\nThe word \"extensible\" implies to me that `SvcParams` is optional but section 2.1 list it like this:\r\n\r\n> Name TTL IN SVCB SvcPriority TargetName SvcParams\r\n\r\nThere are no optional ABNF sequences (`[]`) in this declaration, which makes it seem as if at least one `SvcParamKey` is required.",
      "createdAt": "2021-09-22T11:35:59Z",
      "updatedAt": "2021-09-22T11:46:10Z",
      "closedAt": "2021-09-22T11:46:10Z",
      "comments": [
        {
          "author": "silverwind",
          "authorAssociation": "NONE",
          "body": "Actually this seems  to be clarified in section 1.2 which I skipped over earlier.",
          "createdAt": "2021-09-22T11:46:10Z",
          "updatedAt": "2021-09-22T11:46:10Z"
        }
      ]
    },
    {
      "number": 343,
      "id": "I_kwDOBsWBq848DiXg",
      "title": "ALPN text incorrectly implies something about Alt-Svc",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/343",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "> Unlike Alt-Svc Field Values, HTTPS RRs can contain multiple ALPN IDs, and clients are encouraged to offer additional ALPNs that they support.\r\n\r\nFrom a grammatical perspective, the construction of this sentence is problematic.  It could mean:\r\n\r\n1. HTTPS RRs differ from Alt-Svc in that they can convey multiple ALPN IDs with each entry.  Consequently, clients are encouraged to include multiple ALPN IDs when they attempt to make a connection.\r\n2. HTTPS RRs differ from Alt-Svc in that they can convey multiple ALPN IDs with each entry.  They also differ in that clients are permitted to include additional ALPN IDs when they make a connection.\r\n\r\nWhen it comes to the latter part, both interpretations are problematic.  Either way, it might be read to imply something that Alt-Svc (RFC 7838) does not say.  The relevant text in RFC 7838 says:\r\n\r\n>  If the connection to the alternative service does not negotiate the expected protocol (for example, ALPN fails to negotiate h2, or an Upgrade request to h2c is not accepted), the connection to the alternative service MUST be considered to have failed.\r\n\r\nThis does not say anything about what clients offer when attempting to connect to a server, only what they ultimately accept.  However, the text first quoted here seems to imply that clients are somehow prohibited from offering additional ALPN IDs when connecting to an alternative service.\r\n\r\nALPN depends (critically) on clients representing the set of protocols that they are willing to use faithfully.  Implying that they might not, especially when using a medium with oft-questionable security properties to drive that decision, is a bad idea.\r\n\r\nI think that this is simply editorial.  The procedures elsewhere in the document are good.  It's a little fiddly to get right, but I will attempt to propose a small change shortly that should fix this.",
      "createdAt": "2021-09-27T00:46:03Z",
      "updatedAt": "2021-10-07T21:02:58Z",
      "closedAt": "2021-10-07T21:02:57Z",
      "comments": []
    },
    {
      "number": 345,
      "id": "I_kwDOBsWBq848Dl3Z",
      "title": "Rename primary branch",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/345",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current name has issues.",
      "createdAt": "2021-09-27T01:11:17Z",
      "updatedAt": "2021-09-27T13:22:41Z",
      "closedAt": "2021-09-27T13:22:41Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Done",
          "createdAt": "2021-09-27T13:22:41Z",
          "updatedAt": "2021-09-27T13:22:41Z"
        }
      ]
    },
    {
      "number": 349,
      "id": "I_kwDOBsWBq848u7zS",
      "title": "Referer handling on HSTS behavior",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/349",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Given the description:\r\n\r\n\"client SHOULD behave as if it has received an HTTP 307 (Temporary Redirect) status code with this \"https\" URL in the \"Location\" field.\"\r\n\r\nShould we provide any clarification on whether a Referer header should be present (listing the \"http\" Scheme URI) or omitted?  Or should we leave this undefined?",
      "createdAt": "2021-10-06T18:29:53Z",
      "updatedAt": "2021-10-06T19:49:55Z",
      "closedAt": "2021-10-06T19:49:55Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I think redirects [don't affect Referer](https://stackoverflow.com/a/5441932), so maybe we don't have to worry about this?",
          "createdAt": "2021-10-06T19:08:45Z",
          "updatedAt": "2021-10-06T19:08:45Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Good point.  #wontfix.",
          "createdAt": "2021-10-06T19:49:55Z",
          "updatedAt": "2021-10-06T19:49:55Z"
        }
      ]
    },
    {
      "number": 354,
      "id": "I_kwDOBsWBq849s_rm",
      "title": "TCP Fast Open indication",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/354",
      "state": "OPEN",
      "author": "Avamander",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "future draft"
      ],
      "body": "It would be very useful if HTTPSVC record could indicate [TFO](https://en.wikipedia.org/wiki/TCP_Fast_Open) support. \r\n\r\nThere's no other good way to indicate this preference. [Previous attempts](https://bugzilla.mozilla.org/show_bug.cgi?id=1188435) at \"try it everywhere\" by some web browsers were (IMHO) too early and and too eager, resulting in very little benefit. Most mobile devices could simply not use it when it was last tried, that has changed by now. \r\n\r\nMore informed attempts at TFO would significantly increase its usefulness and give the technology a chance to gain adoption.",
      "createdAt": "2021-10-25T14:24:13Z",
      "updatedAt": "2021-11-09T15:01:49Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "This is an interesting idea, but I'm not sure it would help.  My impression is that servers (especially web servers) are reliably tolerant of TFO, and the problem is that [some network devices](https://bugzilla.mozilla.org/show_bug.cgi?id=1398201) are intolerant of TFO.  Having a signal from the origin that the server supports TFO wouldn't solve that problem.\r\n\r\nNevertheless, the SvcParam registry is essentially open (\"first come first served\"), so it is possible to register a codepoint for any extension you would like to see, even if there isn't broad consensus for it.  (Please don't abuse this.)",
          "createdAt": "2021-10-25T15:13:10Z",
          "updatedAt": "2021-10-25T15:13:10Z"
        },
        {
          "author": "Avamander",
          "authorAssociation": "NONE",
          "body": "Yes, middleboxes are concern, but it would still have a benefit in those cases. Both the statistics and falling back for that session would be more accurate. Meaning - broken middlebox detection improves instead of guessing.\r\n\r\n> Nevertheless, the SvcParam registry is essentially open\r\n\r\nHow would that process look like, and would it be the best course of action for it to be usable?",
          "createdAt": "2021-10-25T15:25:38Z",
          "updatedAt": "2021-10-25T15:25:38Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Middlebox statistics are easy(?): just send probes to some test domains with known configurations.  The fallback logic seems to be about the same with or without this signal.\r\n\r\nIf you're interested in pursuing this, I would strongly recommend emailing the [tsvarea](https://www.ietf.org/mailman/listinfo/tsv-area) or [tcpm](https://www.ietf.org/mailman/listinfo/tcpm) list for feedback first.  If there is support, you could write it up as a very short Internet-Draft, and use that draft as the documentation reference in a registration request to IANA.",
          "createdAt": "2021-10-25T15:41:44Z",
          "updatedAt": "2021-10-25T15:41:44Z"
        }
      ]
    },
    {
      "number": 355,
      "id": "I_kwDOBsWBq84-giYb",
      "title": "Overuse of should/SHOULD",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/355",
      "state": "OPEN",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See this mailing list thread which recommends that we convert some SHOULD to MUST and which also points out some uses of \"should\" that would be better to fix:\r\nhttps://mailarchive.ietf.org/arch/msg/dnsop/EhP4nvJV1WEa4wiEIPPZIdLvIhc/",
      "createdAt": "2021-11-09T15:07:26Z",
      "updatedAt": "2021-11-09T15:07:26Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 356,
      "id": "I_kwDOBsWBq84--Zax",
      "title": "Make sure we have the right meaning of \".\" with wildcard owner names",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/356",
      "state": "OPEN",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When TargetName is \".\", and the record's owner name is a wildcard, it's clear what we want this to mean, but I'm not sure the text formally captures it.",
      "createdAt": "2021-11-17T19:34:30Z",
      "updatedAt": "2021-11-17T21:35:17Z",
      "closedAt": null,
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Does wildcard even exist as a concept at the level of ownername?  I thought it (and some similar constructs) where a convenience for zone files.  But we should still be clear on this if there's confusion.",
          "createdAt": "2021-11-17T20:31:11Z",
          "updatedAt": "2021-11-17T20:31:11Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "As always, the terminology is a bit slippery.  For example, RFC 1034 [says](https://datatracker.ietf.org/doc/html/rfc1034#section-4.3.3)\r\n\r\n> In the previous algorithm, special treatment was given to RRs with owner\r\nnames starting with the label \"*\".  Such RRs are called wildcards.\r\nWildcard RRs can be thought of as instructions for synthesizing RRs.\r\nWhen the appropriate conditions are met, the name server creates RRs\r\nwith an owner name equal to the query name and contents taken from the\r\nwildcard RRs.\r\n",
          "createdAt": "2021-11-17T21:35:17Z",
          "updatedAt": "2021-11-17T21:35:17Z"
        }
      ]
    },
    {
      "number": 357,
      "id": "I_kwDOBsWBq85APCtr",
      "title": "question on Appendix D, Figure 5",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/357",
      "state": "OPEN",
      "author": "rafaelvanoni",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi folks, I'm wondering if the following example is missing the quotes in its wire format portion:\r\n```\r\n   example.com.   SVCB   1 foo.example.com. key667=\"hello\\210qoo\"\r\n\r\n   \\# 32 (\r\n   00 01                                              ; priority\r\n   03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target\r\n   02 9b                                              ; key 667\r\n   00 09                                              ; length 9\r\n   68 65 6c 6c 6f d2 71 6f 6f                         ; value\r\n   )\r\n\r\n   \\x00\\x01                                           # priority\r\n   \\x03foo\\x07example\\x03com\\x00                      # target\r\n   \\x02\\x9b                                           # key 667\r\n   \\x00\\x09                                           # length 9\r\n   hello\\xd2qoo                                       # value\r\n\r\n       Figure 5: A generic key and quoted value with a decimal escape\r\n```\r\n\r\nShouldn't the value line be something like\r\n```\r\n`\\x22hello\\xd2qoo\\x22\" \r\n```\r\nSo that it matches the quoted text in the presentation format text ?\r\n\r\nThanks",
      "createdAt": "2021-12-12T00:39:43Z",
      "updatedAt": "2021-12-14T05:34:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "\n\n> On 12 Dec 2021, at 11:39, Rafael Vanoni ***@***.***> wrote:\n> \n> \n> Hi folks, I'm wondering if the following example is missing the quotes in its wire format portion:\n> \n>    example.com.   SVCB   1 foo.example.com. key667=\"hello\\210qoo\"\n> \n>    \\# 32 (\n>    00 01                                              ; priority\n>    03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target\n>    02 9b                                              ; key 667\n>    00 09                                              ; length 9\n>    68 65 6c 6c 6f d2 71 6f 6f                         ; value\n>    )\n> \n>    \\x00\\x01                                           # priority\n>    \\x03foo\\x07example\\x03com\\x00                      # target\n>    \\x02\\x9b                                           # key 667\n>    \\x00\\x09                                           # length 9\n>    hello\\xd2qoo                                       # value\n> \n>        Figure 5: A generic key and quoted value with a decimal escape\n> \n> Shouldn't the value line be something like\n> \n> `\\x22hello\\xd2qoo\\x22\" \n> \n> ?\n\nNo.  For the double quotes to be part of the value it would need to be escaped.\nThe value is the part inside the double quotes.\n\n> Thanks\n> \n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n> Triage notifications on the go with GitHub Mobile for iOS or Android. \n> \n\n-- \nMark Andrews, ISC\n1 Seymour St., Dundas Valley, NSW 2117, Australia\nPHONE: +61 2 9871 4742              INTERNET: ***@***.***\n\n",
          "createdAt": "2021-12-13T05:06:11Z",
          "updatedAt": "2021-12-13T05:06:11Z"
        },
        {
          "author": "rafaelvanoni",
          "authorAssociation": "NONE",
          "body": "Ok, but how do I know when to present a value with double quotes (and when not to) ?",
          "createdAt": "2021-12-13T23:20:39Z",
          "updatedAt": "2021-12-13T23:20:39Z"
        },
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "\n\n> On 14 Dec 2021, at 10:20, Rafael Vanoni ***@***.***> wrote:\n> \n> \n> Ok, but how do I know when to present a value with double quotes (and when not to) ?\n\nYou make a decision as a implementor. There isn\u2019t a canonical format.\n\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n> Triage notifications on the go with GitHub Mobile for iOS or Android. \n> \n\n-- \nMark Andrews, ISC\n1 Seymour St., Dundas Valley, NSW 2117, Australia\nPHONE: +61 2 9871 4742              INTERNET: ***@***.***\n\n",
          "createdAt": "2021-12-14T05:31:42Z",
          "updatedAt": "2021-12-14T05:31:42Z"
        },
        {
          "author": "rafaelvanoni",
          "authorAssociation": "NONE",
          "body": "Ah gotcha, they're mixed in the examples so I wasn't sure of that. Thanks for the clarification.",
          "createdAt": "2021-12-14T05:34:06Z",
          "updatedAt": "2021-12-14T05:34:06Z"
        }
      ]
    },
    {
      "number": 358,
      "id": "I_kwDOBsWBq85BK5XV",
      "title": "Are HTTPS records supposed to be resolved via CNAME",
      "url": "https://github.com/MikeBishop/dns-alt-svc/issues/358",
      "state": "CLOSED",
      "author": "bt90",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "question"
      ],
      "body": "Given the following setup:\r\n\r\n```\r\n*.example.com.   86400      IN  CNAME      example.com.\r\nexample.com.     86400      IN  HTTPS      1 . alpn=\"h3,h2\"\r\n```\r\n\r\nShould a query for the HTTPS record of e.g `subdomain.example.com` be resolved using the CNAME?",
      "createdAt": "2022-01-04T13:50:45Z",
      "updatedAt": "2022-01-04T15:02:15Z",
      "closedAt": "2022-01-04T15:02:07Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes.  The ability to place an HTTPS record on a CNAME target is the main reason for HTTPS records being distinct from SVCB.\r\n\r\nThe fact that the CNAME response was generated from a wildcard owner name in the zone file is not even generally visible to the stub resolver.  ",
          "createdAt": "2022-01-04T15:02:07Z",
          "updatedAt": "2022-01-04T15:02:07Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk3MjM3MzU3",
      "title": "Recommend shuffling the RRSET",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/1",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Suggested by Shumon Huque: https://www.ietf.org/mail-archive/web/dnsop/current/msg23143.html",
      "createdAt": "2018-06-25T21:12:33Z",
      "updatedAt": "2018-06-28T22:14:44Z",
      "closedAt": "2018-06-28T22:14:41Z",
      "mergedAt": "2018-06-28T22:14:41Z",
      "mergedBy": "bemasc",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "OK.  Could we say that the semantics are the same as getting multiple Alt-Svc response headers?\r\n\r\nRFC 2616 says \"Multiple message-header fields with the same field-name MAY be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list [i.e., #(values)].  It MUST be possible to combine the multiple header fields into one \"field-name: field-value\" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma.\"\r\n\r\nAlt-Svc says \"When multiple values are present, the order of the values reflects the server's preference\".\r\n\r\nI think this is actually workable.  The server can produce multiple RRs, each of which can contain multiple options in preference order.  The DNS client will scramble them, and then HTTP will glue them together in that order.  Then the client will (probably) use the first one that's compatible.",
          "createdAt": "2018-06-28T02:09:24Z",
          "updatedAt": "2018-06-28T02:09:24Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I added reassurances around multiple alt-values and explicit recommendations for client behavior when receiving multiple records.  Please take a look.",
          "createdAt": "2018-06-28T21:23:46Z",
          "updatedAt": "2018-06-28T21:23:46Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Citation fixed.",
          "createdAt": "2018-06-28T22:14:37Z",
          "updatedAt": "2018-06-28T22:14:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNjQ4NDkx",
          "commit": {
            "abbreviatedOid": "d400d30"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "Seems fine as a start.  For clarity, it might be worth mentioning that this doesn't modify the interpretation of multiple alternatives within a single record, only the behavior when multiple records are returned.\r\n\r\nMore concerning, this raises the point that there's no defined behavior for what to do with these multiple records:  Fold them together, as multiple instances of the HTTP header would do?  (In which case order matters.)  Just take the first one?  Something else?",
          "createdAt": "2018-06-27T23:56:03Z",
          "updatedAt": "2018-06-28T00:07:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzMDM2NDQx",
          "commit": {
            "abbreviatedOid": "4b3f49e"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Looks good, modulo a citation fix.",
          "createdAt": "2018-06-28T21:56:33Z",
          "updatedAt": "2018-06-28T21:56:51Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Cite the current HTTP RFC, not the obsolete one; this should be Section 3.2.2 of RFC7230.",
              "createdAt": "2018-06-28T21:56:33Z",
              "updatedAt": "2018-06-28T22:14:10Z"
            }
          ]
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "992f23c3ca9ed46fadfc3c0c6b847379dabab32a",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-random",
      "headRefOid": "1738dc339d0e517b4b02594c46e962b35fe24e54",
      "mergeCommit": {
        "oid": "828f702e45e2bea3b4b422cd2c6578c584e3c8ca"
      }
    },
    {
      "number": 2,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc5NTA4OTQz",
      "title": "Add Erik Nygren's HTTPSSVC version of the draft",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/2",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is Erik's original draft from my inbox, except for RFC-markdown syntax and linter fixes.",
      "createdAt": "2019-05-16T13:33:59Z",
      "updatedAt": "2019-07-03T14:50:50Z",
      "closedAt": "2019-07-03T14:50:50Z",
      "mergedAt": "2019-07-03T14:50:50Z",
      "mergedBy": "bemasc",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the review @MikeBishop.  I added comments on a few points where I contributed text, but I'll defer to @enygren on the others.",
          "createdAt": "2019-06-14T20:40:11Z",
          "updatedAt": "2019-06-14T20:40:11Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "No disagreement with any of the remaining comments which are mostly editorial.",
          "createdAt": "2019-06-14T22:03:23Z",
          "updatedAt": "2019-06-14T22:03:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMDcwOTE1",
          "commit": {
            "abbreviatedOid": "6213882"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "I like the direction.  Lots here, and apologies again for my tardiness in giving these a thorough review.  I'll be working through the other PRs later this afternoon.",
          "createdAt": "2019-06-14T18:56:27Z",
          "updatedAt": "2019-06-14T19:04:19Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "This example (and others throughout, but this is especially bad) doesn't render cleanly in the output.\r\n![image](https://user-images.githubusercontent.com/4273797/59531687-6eb5e400-8e9b-11e9-8566-d23383ba4de5.png)\r\n",
              "createdAt": "2019-06-14T18:56:28Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            },
            {
              "originalPosition": 125,
              "body": "Probably need a goal around degradation when servers are deployed this way and there\u2019s a legacy client.",
              "createdAt": "2019-06-14T18:57:00Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            },
            {
              "originalPosition": 185,
              "body": "Forward references to the sections in 6.x that define these would be useful.",
              "createdAt": "2019-06-14T18:57:28Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            },
            {
              "originalPosition": 265,
              "body": "(1) requires scheme to be \u201chttps,\u201d but (2) defines what to do if it\u2019s not.  I\u2019d condense them and say that if scheme is \u201chttps\u201d and the port is \u201c443\u201d (no need to specify omitted, since that\u2019s the default port for https), use the hostname; otherwise build _port._scheme.hostname",
              "createdAt": "2019-06-14T18:58:05Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            },
            {
              "originalPosition": 287,
              "body": "Would it make sense to ignore all 1s if there are any 0s, rather than ignoring everything?  That might make upgrade scenarios easier.",
              "createdAt": "2019-06-14T18:58:25Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            },
            {
              "originalPosition": 340,
              "body": "Extraneous \\\u2019s in example; needs to be marked as a figure",
              "createdAt": "2019-06-14T18:59:11Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            },
            {
              "originalPosition": 358,
              "body": "Mentions way to find RR for other schemes/ports; should probably cross-reference 2.2.",
              "createdAt": "2019-06-14T18:59:41Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            },
            {
              "originalPosition": 381,
              "body": "Why are clients only permitted to synthesize a lifetime instead of encouraged?",
              "createdAt": "2019-06-14T19:00:12Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            },
            {
              "originalPosition": 389,
              "body": "I\u2019m dubious that omitting persist actually helps.  Once the client has connected to the server, if the server possesses a valid certificate, then it simply supplies the persistent record as an HTTP header.  If the server doesn\u2019t possess a valid certificate, then the persistent entry will fail to connect anyway.",
              "createdAt": "2019-06-14T19:00:36Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            },
            {
              "originalPosition": 395,
              "body": "Given the requirement to only have one alias (2.4), perhaps it\u2019s worth specifying that this is only applicable to the alt-svc form?",
              "createdAt": "2019-06-14T19:00:58Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            },
            {
              "originalPosition": 410,
              "body": "Information coming over an HTTPS connection is authenticated by the certificate, while DNS is potentially unauthenticated.  Records from an authenticated connection are always higher priority than those from DNS.",
              "createdAt": "2019-06-14T19:01:18Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            },
            {
              "originalPosition": 456,
              "body": "I\u2019m leery of making this HSTS-equivalent, especially since it would be trivial to permit 2.2 to indicate that the http scheme can be served over HTTPS using existing Alt-Svc mechanisms.  Just point to RFC 8164 and keep going.",
              "createdAt": "2019-06-14T19:01:38Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            },
            {
              "originalPosition": 533,
              "body": "This references the draft which defines sni=, but you redefine it in 6.1.  Need to resolve.",
              "createdAt": "2019-06-14T19:02:19Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            },
            {
              "originalPosition": 618,
              "body": "This references the draft which defines sni=, but you redefine it in 6.1.  Need to resolve.",
              "createdAt": "2019-06-14T19:02:51Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            },
            {
              "originalPosition": 682,
              "body": "This is titled \"Appendix,\" but is a top-level section in the body.  I'd suggest making each of these subsections an actual and separate appendix.",
              "createdAt": "2019-06-14T19:03:33Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMTA1Mzc1",
          "commit": {
            "abbreviatedOid": "6213882"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-14T20:23:36Z",
          "updatedAt": "2019-06-14T20:23:37Z",
          "comments": [
            {
              "originalPosition": 389,
              "body": "The concern here is about an active attacker on the local network who is also a pervasive passive adversary.  This attacker could inject a fraudulent DNS record that would then permit them to track that user even after they leave the network.  The adversary in this case is not the server operator.\r\n\r\nFor example, suppose there is a server operator who doesn't use Alt-Svc at all, and who serves the same domain on all IPs of a /64.  An adversary who can inject a long-TTL DNS record can pin a user to one of those IPs, and then reidentify that user across the internet whenever they visit that domain.  This can (and should) be solved by clearing the client's DNS cache when moving between networks.  Since DNS data in this case can be cached in the Alt-Svc cache, we need \"persist=0\" to get equivalent behavior.\r\n\r\nEDIT: Persist=1 would also enable a persistent DoS by a network that wants to block access to some site.",
              "createdAt": "2019-06-14T20:23:37Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMTA2ODg0",
          "commit": {
            "abbreviatedOid": "6213882"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-14T20:27:12Z",
          "updatedAt": "2019-06-14T20:27:12Z",
          "comments": [
            {
              "originalPosition": 381,
              "body": "I agree, how about\r\n> clients SHOULD synthesize a new \"ma\" parameter from the DNS TTL if they intend to integrate with an Alt-Svc cache.",
              "createdAt": "2019-06-14T20:27:12Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMTEwOTY0",
          "commit": {
            "abbreviatedOid": "6213882"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-14T20:37:48Z",
          "updatedAt": "2019-06-14T20:37:48Z",
          "comments": [
            {
              "originalPosition": 456,
              "body": "I think HSTS support here is important.  It's a rare chance to fix the \"bare domain\" bootstrap problem, and would win a lot of support for HTTPSSVC from parties who would otherwise not be very interested in this stuff.\r\n\r\nI don't view opportunistic security as sufficient, and I think it's considerably more complicated than \"HTTPSSVC requires HTTPS\".",
              "createdAt": "2019-06-14T20:37:48Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMTQ0NDcw",
          "commit": {
            "abbreviatedOid": "8ae87b7"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-14T22:00:41Z",
          "updatedAt": "2019-06-14T22:00:41Z",
          "comments": [
            {
              "originalPosition": 287,
              "body": "Good idea...  At least keeps it deterministic.",
              "createdAt": "2019-06-14T22:00:41Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMTQ0OTE1",
          "commit": {
            "abbreviatedOid": "8ae87b7"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-14T22:02:22Z",
          "updatedAt": "2019-06-14T22:02:22Z",
          "comments": [
            {
              "originalPosition": 456,
              "body": "I tend to agree wtih Ben here that we should at least try and propose this.",
              "createdAt": "2019-06-14T22:02:22Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMTQ0OTky",
          "commit": {
            "abbreviatedOid": "8ae87b7"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-14T22:02:39Z",
          "updatedAt": "2019-06-14T22:02:40Z",
          "comments": [
            {
              "originalPosition": 410,
              "body": "Agreed.",
              "createdAt": "2019-06-14T22:02:39Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwNzU5NzQ5",
          "commit": {
            "abbreviatedOid": "c92bbf7"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-17T21:36:26Z",
          "updatedAt": "2019-06-17T21:36:27Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "As I've mentioned before, I tend to think we should drop this, based on the chilly reception we've gotten thus far.  The browser folks I've talked to seemed particularly opposed to implementing any protocol that created mismatch between the SNI and the actual validation process, because of the potential for security bugs.",
              "createdAt": "2019-06-17T21:36:27Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMTA1NzA3",
          "commit": {
            "abbreviatedOid": "c92bbf7"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T13:43:43Z",
          "updatedAt": "2019-06-18T13:43:43Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Fixed in #12",
              "createdAt": "2019-06-18T13:43:43Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMTA1ODQ5",
          "commit": {
            "abbreviatedOid": "c92bbf7"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T13:43:55Z",
          "updatedAt": "2019-06-18T13:43:56Z",
          "comments": [
            {
              "originalPosition": 340,
              "body": "Fixed in #12",
              "createdAt": "2019-06-18T13:43:56Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMTA2MTc4",
          "commit": {
            "abbreviatedOid": "c92bbf7"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T13:44:24Z",
          "updatedAt": "2019-06-18T13:44:24Z",
          "comments": [
            {
              "originalPosition": 682,
              "body": "Fixed in #12",
              "createdAt": "2019-06-18T13:44:24Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMTE2NjU4",
          "commit": {
            "abbreviatedOid": "c92bbf7"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T13:59:51Z",
          "updatedAt": "2019-06-18T13:59:51Z",
          "comments": [
            {
              "originalPosition": 265,
              "body": "Addressed by #13.",
              "createdAt": "2019-06-18T13:59:51Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMTE2OTE5",
          "commit": {
            "abbreviatedOid": "c92bbf7"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T14:00:12Z",
          "updatedAt": "2019-06-18T14:00:13Z",
          "comments": [
            {
              "originalPosition": 358,
              "body": "Addressed by #13.",
              "createdAt": "2019-06-18T14:00:12Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMTE3Mjkw",
          "commit": {
            "abbreviatedOid": "c92bbf7"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T14:00:45Z",
          "updatedAt": "2019-06-18T14:00:45Z",
          "comments": [
            {
              "originalPosition": 340,
              "body": "Addressed in #12.",
              "createdAt": "2019-06-18T14:00:45Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMTE3NTQw",
          "commit": {
            "abbreviatedOid": "c92bbf7"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T14:01:05Z",
          "updatedAt": "2019-06-18T14:01:05Z",
          "comments": [
            {
              "originalPosition": 682,
              "body": "Addressed in #12",
              "createdAt": "2019-06-18T14:01:05Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMTE5Nzkz",
          "commit": {
            "abbreviatedOid": "c92bbf7"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T14:04:12Z",
          "updatedAt": "2019-06-18T14:04:13Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "Fixed in #12",
              "createdAt": "2019-06-18T14:04:13Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMTI1NTY0",
          "commit": {
            "abbreviatedOid": "c92bbf7"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T14:12:36Z",
          "updatedAt": "2019-06-18T14:12:36Z",
          "comments": [
            {
              "originalPosition": 287,
              "body": "What is the advantage of preferring version 0?  Intuitively, I would expect a preference for version 1, since it enables better performance and security.  For future-proofing, I could imagine a rule like \"prefer the highest type number you support, and ignore anything higher\".",
              "createdAt": "2019-06-18T14:12:36Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMTM2MTAw",
          "commit": {
            "abbreviatedOid": "c92bbf7"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T14:27:13Z",
          "updatedAt": "2019-06-18T14:27:14Z",
          "comments": [
            {
              "originalPosition": 410,
              "body": "Proposal in #14.",
              "createdAt": "2019-06-18T14:27:13Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMTQyNTQy",
          "commit": {
            "abbreviatedOid": "c92bbf7"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T14:36:00Z",
          "updatedAt": "2019-06-18T14:36:01Z",
          "comments": [
            {
              "originalPosition": 381,
              "body": "Addressed by #15.",
              "createdAt": "2019-06-18T14:36:01Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMTQyNjky",
          "commit": {
            "abbreviatedOid": "c92bbf7"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T14:36:12Z",
          "updatedAt": "2019-06-18T14:36:12Z",
          "comments": [
            {
              "originalPosition": 389,
              "body": "Clarified in #15.",
              "createdAt": "2019-06-18T14:36:12Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMzcwMzQw",
          "commit": {
            "abbreviatedOid": "c92bbf7"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T21:23:55Z",
          "updatedAt": "2019-06-18T21:23:55Z",
          "comments": [
            {
              "originalPosition": 287,
              "body": "Two reasons, but I could be persuaded otherwise:  There's a requirement that there be only one \"0.\"  If the rule is \"consume the first zero, ignore anything else\" then you have an easy and deterministic rule.  Also, it makes it easy to roll out \"1\" by populating the new records prior to removing the old one.\r\n\r\nAnd of course, something is better than nothing -- I'm amenable to other deterministic ways of selecting, but I'm less attracted to \"pretend you didn't see it\" as a mandated reaction.",
              "createdAt": "2019-06-18T21:23:55Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMzc0NjI0",
          "commit": {
            "abbreviatedOid": "c92bbf7"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T21:33:41Z",
          "updatedAt": "2019-06-18T21:33:42Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "I'm amenable to leaving them separate -- my comment is purely around document consistency.  It would be consistent if all references to both were removed, too.  :-)",
              "createdAt": "2019-06-18T21:33:41Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMzc1NjQ2",
          "commit": {
            "abbreviatedOid": "c92bbf7"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T21:36:07Z",
          "updatedAt": "2019-06-18T21:36:08Z",
          "comments": [
            {
              "originalPosition": 389,
              "body": "The DoS issue is solved by Alt-Svc failing back to a direct connection if alternatives fail.  But the tracking argument is valid -- the attacker could just relay the packets to the real server, meaning the TLS handshake will complete (albeit with TLS RTT exceeding TCP's RTT from the client's point of view).",
              "createdAt": "2019-06-18T21:36:07Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxODE1Nzg0",
          "commit": {
            "abbreviatedOid": "18fa632"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-19T16:18:03Z",
          "updatedAt": "2019-06-19T16:18:04Z",
          "comments": [
            {
              "originalPosition": 389,
              "body": "Good point, that makes this attack even easier.",
              "createdAt": "2019-06-19T16:18:03Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTAxNTcy",
          "commit": {
            "abbreviatedOid": "18fa632"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-19T18:43:36Z",
          "updatedAt": "2019-06-19T18:43:36Z",
          "comments": [
            {
              "originalPosition": 287,
              "body": "I think what Mike says makes sense (to use one of the \"0\"'s, ignore the others if multiple 0's or a mix of 0/1 are present).  These aren't different versions/types, they have different semantics.  (The \"0\" is a CNAME/ANAME equivalent and the \"1\" is the ALTSVC record.)  I guess we could swap the 0/1 value definitions and then say \"use the highest you understand\" or we could also just say to ignore ones you don't understand and then let any future draft that defines \"2\" if-any tell clients how to prefer or disprefer it.)",
              "createdAt": "2019-06-19T18:43:36Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTEzMTc3",
          "commit": {
            "abbreviatedOid": "18fa632"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-19T19:05:41Z",
          "updatedAt": "2019-06-19T19:05:41Z",
          "comments": [
            {
              "originalPosition": 287,
              "body": "OK, proposed text in #16",
              "createdAt": "2019-06-19T19:05:41Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTcwODg1",
          "commit": {
            "abbreviatedOid": "c0f8a36"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-19T21:04:37Z",
          "updatedAt": "2019-06-19T21:04:37Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "I'm fine with dropping this.  It could always be a separate document and reduces complexity here.",
              "createdAt": "2019-06-19T21:04:37Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTc3MzE4",
          "commit": {
            "abbreviatedOid": "c0f8a36"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-19T21:18:55Z",
          "updatedAt": "2019-06-19T21:18:56Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "Created PR #17 for this.",
              "createdAt": "2019-06-19T21:18:56Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTgwODA5",
          "commit": {
            "abbreviatedOid": "c0f8a36"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-19T21:26:48Z",
          "updatedAt": "2019-06-19T21:26:49Z",
          "comments": [
            {
              "originalPosition": 395,
              "body": "Added clarification in #9e5d5a2f60c5410598ca1e9b3c916b75ea452855\r\n",
              "createdAt": "2019-06-19T21:26:48Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTgzOTIx",
          "commit": {
            "abbreviatedOid": "9e5d5a2"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-19T21:34:04Z",
          "updatedAt": "2019-06-19T21:34:04Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Added PR #18 to address this.  (Although later in the doc.)",
              "createdAt": "2019-06-19T21:34:04Z",
              "updatedAt": "2019-07-01T14:53:37Z"
            }
          ]
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "828f702e45e2bea3b4b422cd2c6578c584e3c8ca",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "nygren-httpssvc",
      "headRefOid": "c48304f1e70d5c9426a6695febfc27b1fae5c7b1",
      "mergeCommit": {
        "oid": "9a088ec47f656348b8d58366d86e4ccc38eadb5f"
      }
    },
    {
      "number": 3,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc5NTE1MDc4",
      "title": "Explain how this might solve the ANAME problem",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/3",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-05-16T13:48:28Z",
      "updatedAt": "2019-05-24T21:16:32Z",
      "closedAt": "2019-05-24T21:16:32Z",
      "mergedAt": "2019-05-24T21:16:32Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "3afab645fbdc5734d6e7af0046c6922a2976ebe9",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-aname-comparison",
      "headRefOid": "a9e61fa2a0c260c540c95ecef1ca28463c66dca6",
      "mergeCommit": {
        "oid": "c63091aba531059d5221a44dca585288cf0a5348"
      }
    },
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc5NTE3NjI0",
      "title": "Slightly adjust references to ESNIKeys",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/4",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-05-16T13:54:07Z",
      "updatedAt": "2019-05-24T21:17:33Z",
      "closedAt": "2019-05-24T21:17:33Z",
      "mergedAt": "2019-05-24T21:17:33Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQxOTQ4NDAx",
          "commit": {
            "abbreviatedOid": "2ae38b1"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-24T21:17:26Z",
          "updatedAt": "2019-05-24T21:17:26Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "3afab645fbdc5734d6e7af0046c6922a2976ebe9",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-esnikeys",
      "headRefOid": "2ae38b104fd1745646b0025585c2cdc5e841910f",
      "mergeCommit": {
        "oid": "d38264d7c7d078c773b1e207c7ed4dfb98476ec2"
      }
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc5NTYzODM0",
      "title": "Make the \"hts\" parameter implicit",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/5",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This makes HTTPSSVC more valuable as a security measure, for\r\nwebsites that can't easily get themselves on the HSTS preload\r\nlist.\r\n\r\nThe value of the \"_http\" scheme prefix is unclear in this\r\nformulation.  It could possibly be removed, depending on\r\nthe importance of supporting strange situations like\r\n\"https://example.com:80\", or http and https on the same port.",
      "createdAt": "2019-05-16T15:39:18Z",
      "updatedAt": "2019-05-24T21:19:38Z",
      "closedAt": "2019-05-24T21:19:38Z",
      "mergedAt": "2019-05-24T21:19:38Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQxOTQ5MDEx",
          "commit": {
            "abbreviatedOid": "51d7788"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-24T21:19:32Z",
          "updatedAt": "2019-05-24T21:19:32Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "3afab645fbdc5734d6e7af0046c6922a2976ebe9",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-hsts",
      "headRefOid": "51d778881b9ac3ae9092baf31fcf5eb840eb6bd4",
      "mergeCommit": {
        "oid": "926f4c01192defe70579f7b7985c6170f703d6dc"
      }
    },
    {
      "number": 6,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc5NTcwNDUz",
      "title": "Ban the \"persist\" flag",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/6",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-05-16T15:55:46Z",
      "updatedAt": "2019-05-24T21:20:24Z",
      "closedAt": "2019-05-24T21:20:24Z",
      "mergedAt": "2019-05-24T21:20:24Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQxOTQ5MjE3",
          "commit": {
            "abbreviatedOid": "d7368ed"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-24T21:20:19Z",
          "updatedAt": "2019-05-24T21:20:19Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "3afab645fbdc5734d6e7af0046c6922a2976ebe9",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-persist",
      "headRefOid": "d7368ed23b04eb62c23c28c252253c9e36bb0920",
      "mergeCommit": {
        "oid": "5810512ceb9a56f559b495707508857924c25214"
      }
    },
    {
      "number": 7,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc5NTg1NTU2",
      "title": "Change handling of nonstandard HTTP ports",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/7",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "EDIT: New approach: This handles nonstandard HTTP ports in the same way as HSTS.",
      "createdAt": "2019-05-16T16:38:08Z",
      "updatedAt": "2019-05-30T21:16:42Z",
      "closedAt": "2019-05-30T21:16:42Z",
      "mergedAt": "2019-05-30T21:16:42Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQxOTUwMjMw",
          "commit": {
            "abbreviatedOid": "95b0d98"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-24T21:24:10Z",
          "updatedAt": "2019-05-30T21:12:58Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I'm not sure I follow this?  Where does the \"https URL\" number come from in this implicit 302 redirect case?",
              "createdAt": "2019-05-24T21:24:10Z",
              "updatedAt": "2019-05-30T21:12:58Z"
            }
          ]
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "5810512ceb9a56f559b495707508857924c25214",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-port",
      "headRefOid": "31895778cf90d59b3d5f63820b4a5e8852feae2f",
      "mergeCommit": {
        "oid": "62138820013b628ba620ed5dc761048341d779b5"
      }
    },
    {
      "number": 8,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgyMTY0MzY1",
      "title": "Update draft-nygren-httpbis-httpssvc.md",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/8",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Remove ECS reference.",
      "createdAt": "2019-05-24T21:29:24Z",
      "updatedAt": "2019-06-28T19:58:11Z",
      "closedAt": "2019-06-17T21:30:10Z",
      "mergedAt": "2019-06-17T21:30:10Z",
      "mergedBy": "bemasc",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQxOTU3NzA4",
          "commit": {
            "abbreviatedOid": "d52ea5e"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-24T21:54:01Z",
          "updatedAt": "2019-05-24T21:54:01Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "5810512ceb9a56f559b495707508857924c25214",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-remove-ecs-reference",
      "headRefOid": "d52ea5eb30d41253867b22b8345a891d2d4e6609",
      "mergeCommit": {
        "oid": "c92bbf7915ff0239eeb9b2bfbd502e27597bf27d"
      }
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgzNzQ5MzE1",
      "title": "Defend HSTS behavior against certain attackers",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/9",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "With this change, the behavior might even be worthy of\r\nthe name \"strict\".",
      "createdAt": "2019-05-30T17:50:41Z",
      "updatedAt": "2019-06-26T00:51:44Z",
      "closedAt": "2019-06-26T00:51:41Z",
      "mergedAt": "2019-06-26T00:51:41Z",
      "mergedBy": "enygren",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm a little leery of assuming one feature supported means a different one isn't broken.\r\n\r\nSupporting unknown RRTYPEs has been the standard [since 2003](https://tools.ietf.org/html/rfc3597), and almost all servers do this correctly.  I don't think we need to accommodate servers who've implemented the still-rare standard from 2018 but not the near-universal one from 2003.  AFAIK, no such servers exist today, and once HTTPSSVC is widely deployed, anybody who tried to set up such a server would quickly figure out that it is seriously broken\r\n\r\nAdditionally, this accommodation is not the only reason to apply this logic.  If you don't have a secure connection to your recursive, then respecting SERVFAIL doesn't actually protect you from a network adversary (specifically an adversary between you and the recursive).  With a validating resolver and a secure connection, respecting SERVFAIL provides reliable protection (on signed domains).\r\n\r\n> Perhaps a better approach is to synthesize an HSTS record just like we synthesize an Alt-Svc record and persist that independently of clearing the Alt-Svc records.\r\n\r\nThis approach is still opportunistic, not reliable against an active attacker.  It would also enable a persistent DoS by a transient local network adversary (as with persist=1).  I think this functionality is better served by the existing `Strict-Transport-Security` header, which can be set securely by the site itself on first access.",
          "createdAt": "2019-06-19T14:57:31Z",
          "updatedAt": "2019-06-19T14:57:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMTQzOTAy",
          "commit": {
            "abbreviatedOid": "69ef605"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-14T21:58:27Z",
          "updatedAt": "2019-06-14T21:58:28Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Presumably this could also happen for servers that are misbehaving and don't understand the HTTPSSVC record type in the query?  I think we'd need more data an implementation experience.  Perhaps we could reword this as a MAY?  (Or put in Security Considerations?)",
              "createdAt": "2019-06-14T21:58:27Z",
              "updatedAt": "2019-06-20T15:22:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMTU4NDAy",
          "commit": {
            "abbreviatedOid": "69ef605"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-14T23:06:07Z",
          "updatedAt": "2019-06-14T23:06:08Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Yeah, it depends on how much faith the client has in their resolver.  I would be OK with conditioning this on a secure transport to the resolver (as a proxy for \"decent resolver, won't SERVFAIL on new RRTYPEs\").",
              "createdAt": "2019-06-14T23:06:07Z",
              "updatedAt": "2019-06-20T15:22:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwNzU1ODg4",
          "commit": {
            "abbreviatedOid": "db2ce11"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-17T21:27:29Z",
          "updatedAt": "2019-06-17T21:27:29Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "OK, I've updated this PR to only apply to \"cryptographically protected connections\".  Please review.",
              "createdAt": "2019-06-17T21:27:29Z",
              "updatedAt": "2019-06-20T15:22:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMzc4NjU4",
          "commit": {
            "abbreviatedOid": "db2ce11"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "I'm a little leery of assuming one feature supported means a different one isn't broken.  Perhaps a better approach is to synthesize an HSTS record just like we synthesize an Alt-Svc record and persist that independently of clearing the Alt-Svc records.  That way, if the client has ever seen the record, then they'll be secure in the future regardless of attacks against their DNS server?",
          "createdAt": "2019-06-18T21:43:21Z",
          "updatedAt": "2019-06-18T21:43:21Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTYyODI0",
          "commit": {
            "abbreviatedOid": "db2ce11"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-19T20:48:30Z",
          "updatedAt": "2019-06-19T20:48:30Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Is this special in any way?  How is this different/new behavior here?  (Are there clients that always enforce DNSSEC validation on all A/AAAA RRs?) While nice, I'm not sure this needs to be included here.",
              "createdAt": "2019-06-19T20:48:30Z",
              "updatedAt": "2019-06-20T15:22:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTYzMDY5",
          "commit": {
            "abbreviatedOid": "db2ce11"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-19T20:48:58Z",
          "updatedAt": "2019-06-19T20:48:58Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "\r\n\r\nIs this special in any way? How is this different/new behavior here? (Are there clients that always enforce DNSSEC validation on all A/AAAA RRs?) While nice, I'm not sure this needs to be included here.\r\n",
              "createdAt": "2019-06-19T20:48:58Z",
              "updatedAt": "2019-06-20T15:22:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTYzMjU3",
          "commit": {
            "abbreviatedOid": "db2ce11"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-19T20:49:19Z",
          "updatedAt": "2019-06-19T20:49:19Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Looks fine now.",
              "createdAt": "2019-06-19T20:49:19Z",
              "updatedAt": "2019-06-20T15:22:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTY1MTYy",
          "commit": {
            "abbreviatedOid": "db2ce11"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-19T20:53:10Z",
          "updatedAt": "2019-06-19T20:53:10Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "... \"or are received as part of the reponses to the AAAA and/or A queries that were issued-in-parallel.\"\r\n",
              "createdAt": "2019-06-19T20:53:10Z",
              "updatedAt": "2019-06-20T15:22:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTY3NTg3",
          "commit": {
            "abbreviatedOid": "db2ce11"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-19T20:58:01Z",
          "updatedAt": "2019-06-19T20:58:01Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "Add:  \"When the SvcDomainNames and any needed HTTPSSVC records are available, these client SHOULD make subsequent requests over connections specified by the HTTPSSVC records.\"\r\n\r\n(I suspect that for transitional purposes the A/AAAA record alongside the origin domains in these cases will provide sub-par performance relative to the target of the HTTPSSVC record.)",
              "createdAt": "2019-06-19T20:58:01Z",
              "updatedAt": "2019-06-20T15:22:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTg1OTQz",
          "commit": {
            "abbreviatedOid": "db2ce11"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-19T21:39:06Z",
          "updatedAt": "2019-06-19T21:39:07Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "The issue is that Alt-Svc and HTTPSSVC are \"optional\", and connection can always continue without them.  This text is intended to clarify that while their presence is optional (NXDOMAIN isn't a problem), certain failure modes should be treated as fatal, even if the connection actually would complete successfully if the client ignored the error, because this category of errors might represent adversary trying to force a downgrade.\r\n\r\nAdmittedly, this particular text is mostly academic/optimistic, since very few clients (and AFAIK no commercially deployed clients) actually validate DNSSEC on the client.",
              "createdAt": "2019-06-19T21:39:06Z",
              "updatedAt": "2019-06-20T15:22:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyMzY2MjY1",
          "commit": {
            "abbreviatedOid": "aba8af8"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-20T15:29:52Z",
          "updatedAt": "2019-06-20T15:29:53Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "Due to a mixup on my part this PR ended up showing diffs against the wrong branch, including this text.  I've fixed this PR and opened #19 under your name for this change.",
              "createdAt": "2019-06-20T15:29:52Z",
              "updatedAt": "2019-06-20T15:29:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyMzY2MzY4",
          "commit": {
            "abbreviatedOid": "aba8af8"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-20T15:30:02Z",
          "updatedAt": "2019-06-20T15:30:03Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "Moved to #19.",
              "createdAt": "2019-06-20T15:30:03Z",
              "updatedAt": "2019-06-20T15:30:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0MzM3MDU2",
          "commit": {
            "abbreviatedOid": "aba8af8"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-26T00:51:36Z",
          "updatedAt": "2019-06-26T00:51:36Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "79b7ffb456f6b581fa1cfe6e756540eefb6393a3",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-srvfail",
      "headRefOid": "aba8af8ffe31e474629ea565885e04364b7a4ace",
      "mergeCommit": {
        "oid": "a5f0685d6007bacc03bdaa6b60239a408f61abd7"
      }
    },
    {
      "number": 10,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg0MTc5NzIy",
      "title": "Change performance-optimized client behavior",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/10",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This gives clients an opt-out in the rare cases where\r\nHTTPSSVC would impair performance, and also gives\r\nserver admins a clear way to avoid these cases.",
      "createdAt": "2019-05-31T20:15:37Z",
      "updatedAt": "2019-06-14T21:56:14Z",
      "closedAt": "2019-06-14T21:56:14Z",
      "mergedAt": "2019-06-14T21:56:14Z",
      "mergedBy": "enygren",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I've substantially changed the proposal here, incorporating your CNAME idea and also making \"SvcRecordType = 0\" optional for the client (since it doesn't have any security implication).",
          "createdAt": "2019-06-13T22:04:28Z",
          "updatedAt": "2019-06-13T22:04:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1Njg4Mzg3",
          "commit": {
            "abbreviatedOid": "d51dc20"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-04T20:35:30Z",
          "updatedAt": "2019-06-04T20:35:31Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Does it?  I'd think with the source-address-token-validation it's the same number of RTTs for a cold client as the TCP+TLS 1.3 1RTT flow?  (Perhaps I'm misremembering.)",
              "createdAt": "2019-06-04T20:35:30Z",
              "updatedAt": "2019-06-13T22:02:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1NjkwMDc4",
          "commit": {
            "abbreviatedOid": "d51dc20"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-04T20:38:51Z",
          "updatedAt": "2019-06-04T20:38:51Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Do we want to mention my hack here?  (That clients SHOULD look at the set of aliases / canonical names in the A/AAAA response chain to see if they have an A/AAAA resolution of the SvcDomainName in this recent response?)  And that operators may choose to have the SvcDomainName match a name that the client would see a resolution for as part of the A/AAAA lookup?",
              "createdAt": "2019-06-04T20:38:51Z",
              "updatedAt": "2019-06-13T22:02:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1NjkxMjEy",
          "commit": {
            "abbreviatedOid": "d51dc20"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-04T20:41:10Z",
          "updatedAt": "2019-06-04T20:41:10Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "DNS RTTs and Origin RTTs often have no relation and may be orders of magnitude different.  (The former may have cache miss impact and server processing time overhead, but there are also plenty of cases where the DNS recursive is close to the client and the origin is far away, or vice-versa.)",
              "createdAt": "2019-06-04T20:41:10Z",
              "updatedAt": "2019-06-13T22:02:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1NjkxMzAy",
          "commit": {
            "abbreviatedOid": "d51dc20"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-04T20:41:19Z",
          "updatedAt": "2019-06-04T20:41:20Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "That's true, but I thought most servers were expected not to perform that kind of validation unless an attack is detected.",
              "createdAt": "2019-06-04T20:41:20Z",
              "updatedAt": "2019-06-13T22:02:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1NjkyMTI5",
          "commit": {
            "abbreviatedOid": "d51dc20"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-04T20:43:01Z",
          "updatedAt": "2019-06-04T20:43:01Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "I think that's worth mentioning somewhere.  The client behavior might just be \"decent DNS cache\" behavior.",
              "createdAt": "2019-06-04T20:43:01Z",
              "updatedAt": "2019-06-13T22:02:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1Njk4NzMw",
          "commit": {
            "abbreviatedOid": "d51dc20"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-04T20:56:36Z",
          "updatedAt": "2019-06-04T20:56:37Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Yeah, they're not well-correlated.  The main point here is to find a way to make the average net performance loss negligible (or even a net win), even on legacy recursives (which will surely be prevalent for many years).  My sense is that an acceptable solution:\r\n\r\n1. Can't impose a latency-proportional average-case delay on any large category of connections.\r\n2. Must provide security features reliably or not at all.\r\n\r\nI'm certainly open to alternative solutions if you don't think this one will be convincing.  I just don't have any other good ideas for how to square this.",
              "createdAt": "2019-06-04T20:56:36Z",
              "updatedAt": "2019-06-13T22:02:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5NjI4MTg5",
          "commit": {
            "abbreviatedOid": "38f6f86"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-13T22:03:47Z",
          "updatedAt": "2019-06-13T22:03:47Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Done",
              "createdAt": "2019-06-13T22:03:47Z",
              "updatedAt": "2019-06-13T22:03:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMTQzMTMw",
          "commit": {
            "abbreviatedOid": "38f6f86"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-14T21:55:19Z",
          "updatedAt": "2019-06-14T21:55:20Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "I'm still a little dubious on this, but we can include and discuss.",
              "createdAt": "2019-06-14T21:55:19Z",
              "updatedAt": "2019-06-14T21:55:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMTQzMjk5",
          "commit": {
            "abbreviatedOid": "38f6f86"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I'm still a little dubious on the optimization for SvcRecordType=0 but fine leaving it proposed as-is.",
          "createdAt": "2019-06-14T21:56:05Z",
          "updatedAt": "2019-06-14T21:56:05Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "62138820013b628ba620ed5dc761048341d779b5",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-performance",
      "headRefOid": "38f6f869a3665c6bf17a41676068947fe5a28855",
      "mergeCommit": {
        "oid": "8ae87b710b82e3f7ff6c992508e2f9dd2a9e0d38"
      }
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg4MTA0NjUz",
      "title": "Ban fallback when ESNI is enabled",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/11",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-06-13T21:34:01Z",
      "updatedAt": "2019-06-21T21:27:21Z",
      "closedAt": "2019-06-21T21:27:18Z",
      "mergedAt": "2019-06-21T21:27:18Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMTQwOTcx",
          "commit": {
            "abbreviatedOid": "0e969a8"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-14T21:47:18Z",
          "updatedAt": "2019-06-14T21:47:18Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Are there any caveats we'd want?  Such as for clients that don't care about the privacy benefits of ESNI?  (Does the ESNI spec itself allow for any fallbacks?) This otherwise seems generally reasonable.",
              "createdAt": "2019-06-14T21:47:18Z",
              "updatedAt": "2019-06-20T16:05:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMTU3NDM3",
          "commit": {
            "abbreviatedOid": "0e969a8"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-14T23:00:44Z",
          "updatedAt": "2019-06-14T23:00:44Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Why would a client that doesn't care about the privacy benefits of ESNI use ESNI?  Maybe the phrasing is unclear, but my goal was to specify that if the client cared enough to encrypt the SNI on the first try, then it shouldn't send un-encrypted SNI on the second try.\r\n\r\nEDIT: To your second point, the ESNI folks are working on error-recovery, but not \"fallback\" to a non-ESNI connection.",
              "createdAt": "2019-06-14T23:00:44Z",
              "updatedAt": "2019-06-20T16:05:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMzc5MTg2",
          "commit": {
            "abbreviatedOid": "0e969a8"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T21:44:38Z",
          "updatedAt": "2019-06-18T21:44:38Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "For one thing, to contribute to the overall prevalence of ESNI on the Internet, reducing the odds that it stands out as unusual.  A client that will use ESNI when possible, but doesn't really care whether it's used in any particular instance, seems entirely plausible.",
              "createdAt": "2019-06-18T21:44:38Z",
              "updatedAt": "2019-06-20T16:05:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxNzgzNjU4",
          "commit": {
            "abbreviatedOid": "0e969a8"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-19T15:28:32Z",
          "updatedAt": "2019-06-19T15:28:32Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "An ESNI fallback behavior creates an incentive for a network adversary to block connections with ESNI, to force a retry without ESNI and reveal the name.  (If only some clients have fallback it's generally easy to target them, because most TLS clients have a distinctive ClientHello due to cipher and extension choices and ordering.)\r\n\r\nESNI is not designed to be opportunistic, and I don't think the TLS group would approve of a document that introduced that kind of behavior.  I'd rather have clients behave consistently, either implementing ESNI support or not.\r\n\r\nBottom line: \"MUST\" is used when the consequences of failure to comply are serious (and perhaps non-obvious).  I think this situation deserves a MUST.",
              "createdAt": "2019-06-19T15:28:32Z",
              "updatedAt": "2019-06-20T16:05:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTU3Njgz",
          "commit": {
            "abbreviatedOid": "0e969a8"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-19T20:37:47Z",
          "updatedAt": "2019-06-19T20:37:48Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I think it's reasonable to include this and then discuss with a broader audience?  ",
              "createdAt": "2019-06-19T20:37:48Z",
              "updatedAt": "2019-06-20T16:05:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTU5MTAx",
          "commit": {
            "abbreviatedOid": "0e969a8"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-19T20:40:43Z",
          "updatedAt": "2019-06-19T20:40:43Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Although one reason to *not* have this as a MUST:  at least one use-case I've been interested in getting implemented is to do ESNI for just HTTP/3 QUIC (as there's lots of value in trying to prevent middle boxes from messing with ESNI).  This isn't possible if doing so prevents QUIC fallback to HTTP/2 (which is necessary). \r\n\r\nWould an additional attribute indicating the ESNI is opportunistic and fallback is allowed be a compromise?  \"esnioppt=1\"?\r\n",
              "createdAt": "2019-06-19T20:40:43Z",
              "updatedAt": "2019-06-20T16:05:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTgzNTEw",
          "commit": {
            "abbreviatedOid": "0e969a8"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-19T21:33:07Z",
          "updatedAt": "2019-06-19T21:33:07Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "What a mess.  @MikeBishop, what is the exact semantics of unknown parameters in Alt-Svc?  If a client sees an alt-value with \"esnikeys\", and doesn't know what that parameter is for, does it ignore the parameter or the whole alt-value?",
              "createdAt": "2019-06-19T21:33:07Z",
              "updatedAt": "2019-06-20T16:05:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTg2MDgz",
          "commit": {
            "abbreviatedOid": "0e969a8"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-19T21:39:28Z",
          "updatedAt": "2019-06-19T21:39:28Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "From rfc7838:  \"Unknown parameters MUST be ignored.  That is, the values (alt-value) they appear in MUST be processed as if the unknown parameter was not present.\"",
              "createdAt": "2019-06-19T21:39:28Z",
              "updatedAt": "2019-06-20T16:05:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyMzg4NjQ5",
          "commit": {
            "abbreviatedOid": "f39b72d"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-20T16:06:25Z",
          "updatedAt": "2019-06-20T16:06:26Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "OK, I've added a way to let server operators choose opportunistic ESNI.  Please review.",
              "createdAt": "2019-06-20T16:06:25Z",
              "updatedAt": "2019-06-20T16:06:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUzMDM5MjQx",
          "commit": {
            "abbreviatedOid": "f39b72d"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-21T21:26:57Z",
          "updatedAt": "2019-06-21T21:26:57Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Sounds good.",
              "createdAt": "2019-06-21T21:26:57Z",
              "updatedAt": "2019-06-21T21:26:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUzMDM5MzA5",
          "commit": {
            "abbreviatedOid": "f39b72d"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-21T21:27:09Z",
          "updatedAt": "2019-06-21T21:27:09Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "62138820013b628ba620ed5dc761048341d779b5",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-fallback",
      "headRefOid": "f39b72d02baf558d96d7f13e7ee4909d349fef8c",
      "mergeCommit": {
        "oid": "f4f020d114756eba6a2780fa65c0ebf4ebfcbe86"
      }
    },
    {
      "number": 12,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg5MDQ0NzY1",
      "title": "Improve formatting and cross-references",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/12",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This should address Mike's formatting comments from the main review.",
      "createdAt": "2019-06-17T22:35:03Z",
      "updatedAt": "2019-06-19T20:31:35Z",
      "closedAt": "2019-06-19T20:31:30Z",
      "mergedAt": "2019-06-19T20:31:30Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTU0Njgy",
          "commit": {
            "abbreviatedOid": "dc82fef"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-19T20:31:25Z",
          "updatedAt": "2019-06-19T20:31:25Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "c92bbf7915ff0239eeb9b2bfbd502e27597bf27d",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-formatting",
      "headRefOid": "dc82fefd1f523f5ec52a0ca45de17e2be04af6e6",
      "mergeCommit": {
        "oid": "fb8459e38ecb925a89a61ec359b1a9a2a69c0ed8"
      }
    },
    {
      "number": 13,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg5Mjk1OTcz",
      "title": "Adjust scheme and port description for clarity.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/13",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-06-18T13:59:28Z",
      "updatedAt": "2019-06-19T20:33:36Z",
      "closedAt": "2019-06-19T20:33:36Z",
      "mergedAt": "2019-06-19T20:33:36Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTU1NjY3",
          "commit": {
            "abbreviatedOid": "7a0520b"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-19T20:33:31Z",
          "updatedAt": "2019-06-19T20:33:31Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "c92bbf7915ff0239eeb9b2bfbd502e27597bf27d",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-port",
      "headRefOid": "7a0520bfd85c9901d5399f2fe204b274b403ffa4",
      "mergeCommit": {
        "oid": "c0f8a369c82ac57c0696409bf08fe005ee49cf71"
      }
    },
    {
      "number": 14,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg5MzA4NDA4",
      "title": "Priority clarification",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/14",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-06-18T14:26:27Z",
      "updatedAt": "2019-06-19T20:30:03Z",
      "closedAt": "2019-06-19T20:29:55Z",
      "mergedAt": "2019-06-19T20:29:54Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTUzODky",
          "commit": {
            "abbreviatedOid": "604b7fb"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-19T20:29:47Z",
          "updatedAt": "2019-06-19T20:29:47Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "c92bbf7915ff0239eeb9b2bfbd502e27597bf27d",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-pri",
      "headRefOid": "604b7fb589cde07a69fb13a24cb8434e88d631bf",
      "mergeCommit": {
        "oid": "74a297e7f2534bb659857e16559c8617d2f45aa2"
      }
    },
    {
      "number": 15,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg5MzEyNDY1",
      "title": "Improve description of \"ma\" and \"persist\" handling",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/15",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-06-18T14:35:13Z",
      "updatedAt": "2019-06-19T14:41:45Z",
      "closedAt": "2019-06-19T14:41:45Z",
      "mergedAt": "2019-06-19T14:41:45Z",
      "mergedBy": "bemasc",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMzczMDM1",
          "commit": {
            "abbreviatedOid": "9cfb1b8"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-18T21:30:05Z",
          "updatedAt": "2019-06-18T21:30:05Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "c92bbf7915ff0239eeb9b2bfbd502e27597bf27d",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-ma",
      "headRefOid": "9cfb1b82b56915ae522ca8c92c8630f11e3f66e5",
      "mergeCommit": {
        "oid": "18fa63215c6bba5902d4cae1f81828de9f2dcc79"
      }
    },
    {
      "number": 16,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg5ODQwNDMx",
      "title": "Improve handling of mixed-type RRSets",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/16",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-06-19T19:05:26Z",
      "updatedAt": "2019-06-19T20:08:24Z",
      "closedAt": "2019-06-19T20:07:56Z",
      "mergedAt": "2019-06-19T20:07:56Z",
      "mergedBy": "bemasc",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTQyMTg2",
          "commit": {
            "abbreviatedOid": "3b5d6c7"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-19T20:06:17Z",
          "updatedAt": "2019-06-19T20:06:22Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Quibble:  This could be read as saying that in the presence of multiple \"0\"s, you MAY ignore them all if any of them aren't in your cache.  But then again, you can ignore them entirely for any reason you like, so it's kind of a moot point.",
              "createdAt": "2019-06-19T20:06:18Z",
              "updatedAt": "2019-06-19T20:06:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxOTQzMTky",
          "commit": {
            "abbreviatedOid": "3b5d6c7"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-19T20:08:20Z",
          "updatedAt": "2019-06-19T20:08:21Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I hit merge, but feel free to suggest improved text (or logic!) here.",
              "createdAt": "2019-06-19T20:08:20Z",
              "updatedAt": "2019-06-19T20:08:21Z"
            }
          ]
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "18fa63215c6bba5902d4cae1f81828de9f2dcc79",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-type",
      "headRefOid": "3b5d6c704fce12fed3f98101f050d0cfe91680dd",
      "mergeCommit": {
        "oid": "187a1c2e7f5548c2aa7752e729813016f844fee0"
      }
    },
    {
      "number": 17,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg5ODgyMTAx",
      "title": "Remove Alt-Svc sni= parameter",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/17",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Finish removing the Alt-Svc \"sni=\" parameter (other than from the comparisons appendix discussion).",
      "createdAt": "2019-06-19T21:15:34Z",
      "updatedAt": "2019-06-19T21:55:32Z",
      "closedAt": "2019-06-19T21:55:29Z",
      "mergedAt": "2019-06-19T21:55:29Z",
      "mergedBy": "enygren",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": ":+1: ",
          "createdAt": "2019-06-19T21:31:07Z",
          "updatedAt": "2019-06-19T21:31:07Z"
        }
      ],
      "reviews": [],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "c0f8a369c82ac57c0696409bf08fe005ee49cf71",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-remove-sni-param",
      "headRefOid": "9fae1c6a25e1a15372644b2bc8b27923820a748f",
      "mergeCommit": {
        "oid": "79b7ffb456f6b581fa1cfe6e756540eefb6393a3"
      }
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg5ODg3NDk1",
      "title": "Add a note that fallback A/AAAA records are needed for Alias form",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/18",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-06-19T21:33:31Z",
      "updatedAt": "2019-06-21T01:48:56Z",
      "closedAt": "2019-06-21T01:48:51Z",
      "mergedAt": "2019-06-21T01:48:50Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyMzQ1NzA3",
          "commit": {
            "abbreviatedOid": "2b038b3"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-20T14:57:41Z",
          "updatedAt": "2019-06-20T14:57:41Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "9e5d5a2f60c5410598ca1e9b3c916b75ea452855",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-fallback-records",
      "headRefOid": "2b038b32e5e6d99992e2633f7b06e2eb33d2dd97",
      "mergeCommit": {
        "oid": "6efc05c52827330bfef52405485f6deb381591d0"
      }
    },
    {
      "number": 19,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkwMjY3MDk0",
      "title": "Clarify performance optimized behavior",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/19",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-06-20T15:27:12Z",
      "updatedAt": "2019-06-28T19:58:58Z",
      "closedAt": "2019-06-20T18:39:30Z",
      "mergedAt": "2019-06-20T18:39:30Z",
      "mergedBy": "bemasc",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Text is from @enygren.  :+1: from me.",
          "createdAt": "2019-06-20T15:30:51Z",
          "updatedAt": "2019-06-20T15:30:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyNDM0Mjkw",
          "commit": {
            "abbreviatedOid": "a7f557e"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-20T17:36:53Z",
          "updatedAt": "2019-06-20T17:36:53Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "79b7ffb456f6b581fa1cfe6e756540eefb6393a3",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-performance",
      "headRefOid": "a7f557eb308a9cd3611ad12ffbfa4a726567015b",
      "mergeCommit": {
        "oid": "1e21475fa32808d5a89a03a6f63c52077ac47208"
      }
    },
    {
      "number": 20,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkwNDM0ODQ2",
      "title": "Add a TO BE REMOVED section as suggested by Ben",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/20",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-06-21T01:55:11Z",
      "updatedAt": "2019-06-21T21:16:19Z",
      "closedAt": "2019-06-21T21:16:16Z",
      "mergedAt": "2019-06-21T21:16:16Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyNjEyNTAw",
          "commit": {
            "abbreviatedOid": "66dae2a"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-21T02:03:28Z",
          "updatedAt": "2019-06-21T02:03:28Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "6efc05c52827330bfef52405485f6deb381591d0",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-to-be-removed-intro",
      "headRefOid": "66dae2ad9d3cb82aee652f395b4718ea2b3e4e5b",
      "mergeCommit": {
        "oid": "41dba7dd2d986beb9f1cadacfba174039c56c4c7"
      }
    },
    {
      "number": 21,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkwNDM4Mzc5",
      "title": "Define the resolution algorithm",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/21",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-06-21T02:20:07Z",
      "updatedAt": "2019-06-21T21:24:18Z",
      "closedAt": "2019-06-21T21:24:14Z",
      "mergedAt": "2019-06-21T21:24:14Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyNjE2NDg3",
          "commit": {
            "abbreviatedOid": "7f748d4"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-21T02:26:02Z",
          "updatedAt": "2019-06-21T02:33:48Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Technically if you're v4 or v6 only this is obviously not quite right.  I think \"A/AAAA\" is the usual shorthand.",
              "createdAt": "2019-06-21T02:26:03Z",
              "updatedAt": "2019-06-21T21:23:07Z"
            },
            {
              "originalPosition": 39,
              "body": "I would add \"When these optimizations are employed, this procedure does not generally add latency in comparison to an ordinary A/AAAA lookup.\".  (But only if it's true.  I think it is, if recursives really follow SvcRecordType 0 chains.)",
              "createdAt": "2019-06-21T02:29:21Z",
              "updatedAt": "2019-06-21T21:23:07Z"
            },
            {
              "originalPosition": 34,
              "body": "I would add \"and proceed normally\"",
              "createdAt": "2019-06-21T02:29:51Z",
              "updatedAt": "2019-06-21T21:23:07Z"
            },
            {
              "originalPosition": 24,
              "body": "Any loop detection logic?  Could be as simple as \"subject to loop detection heuristics\".",
              "createdAt": "2019-06-21T02:33:15Z",
              "updatedAt": "2019-06-21T21:23:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUzMDM3ODU1",
          "commit": {
            "abbreviatedOid": "7f748d4"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-21T21:22:37Z",
          "updatedAt": "2019-06-21T21:22:37Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "I added:\r\n\"to reduce latency impact in comparison to ordinary AAAA/A lookups.\"\r\nI think we may want more experimental testing prior to making a stronger\r\nstatement as there are enough corner cases here.",
              "createdAt": "2019-06-21T21:22:37Z",
              "updatedAt": "2019-06-21T21:23:07Z"
            }
          ]
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "6efc05c52827330bfef52405485f6deb381591d0",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-resolution",
      "headRefOid": "af86759f1a9ffeaa8786030f8886cf87468a75f0",
      "mergeCommit": {
        "oid": "334d532d370e179e8ff1fd9f7847bf9aaa213a91"
      }
    },
    {
      "number": 22,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkxNzQxODQ5",
      "title": "Added some suggestions from Ian Swett.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/22",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Mention the HTTPS bootstrapping in the intro.\r\nRemind the importance of using the origin name for validating\r\nthe TLS server cert.",
      "createdAt": "2019-06-25T21:38:22Z",
      "updatedAt": "2019-06-26T00:50:16Z",
      "closedAt": "2019-06-26T00:50:10Z",
      "mergedAt": "2019-06-26T00:50:10Z",
      "mergedBy": "enygren",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me\n\nOn Tue, Jun 25, 2019, 5:38 PM Erik Nygren <notifications@github.com> wrote:\n\n> Mention the HTTPS bootstrapping in the intro.\n> Remind the importance of using the origin name for validating\n> the TLS server cert.\n> ------------------------------\n> You can view, comment on, or merge this pull request online at:\n>\n>   https://github.com/MikeBishop/dns-alt-svc/pull/22\n> Commit Summary\n>\n>    - Added some suggestions from Ian Swett.\n>\n> File Changes\n>\n>    - *M* draft-nygren-httpbis-httpssvc.md\n>    <https://github.com/MikeBishop/dns-alt-svc/pull/22/files#diff-0> (11)\n>\n> Patch Links:\n>\n>    - https://github.com/MikeBishop/dns-alt-svc/pull/22.patch\n>    - https://github.com/MikeBishop/dns-alt-svc/pull/22.diff\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/MikeBishop/dns-alt-svc/pull/22?email_source=notifications&email_token=AABO3SMUS3Q57UGA6ZLVPCTP4KF45A5CNFSM4H3MQJHKYY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4G3VBZ2Q>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AABO3SPSBSNEL3TT7PTUHKTP4KF45ANCNFSM4H3MQJHA>\n> .\n>\n",
          "createdAt": "2019-06-25T21:45:26Z",
          "updatedAt": "2019-06-25T21:45:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0MzA5MjYz",
          "commit": {
            "abbreviatedOid": "ec0dec9"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-25T22:50:10Z",
          "updatedAt": "2019-06-25T22:50:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "From a pure reading-flow point of view, can we do something other than \"It also provides\" twice in a row?\r\n```suggestion\r\nof a domain name.  Finally, it provides a way to indicate that the origin\r\n```",
              "createdAt": "2019-06-25T22:50:10Z",
              "updatedAt": "2019-06-26T00:49:28Z"
            }
          ]
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "f4f020d114756eba6a2780fa65c0ebf4ebfcbe86",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-ian-suggestions-1",
      "headRefOid": "585721cbbbfd0908ffd62be9d079d71ef9f52f80",
      "mergeCommit": {
        "oid": "d414f84d1e39faad199679cb4c15310dec5315b7"
      }
    },
    {
      "number": 25,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyNjAwMzAx",
      "title": "Change SvcDomainName to DNS format",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/25",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #23",
      "createdAt": "2019-06-27T20:57:05Z",
      "updatedAt": "2019-06-28T01:04:51Z",
      "closedAt": "2019-06-28T01:04:43Z",
      "mergedAt": "2019-06-28T01:04:43Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTQ1NjAz",
          "commit": {
            "abbreviatedOid": "805728f"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-28T01:04:37Z",
          "updatedAt": "2019-06-28T01:04:37Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "82392badf02331c706eb2d226b128ee038bb04f0",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-format",
      "headRefOid": "805728fae405a8694b296d77aa8a8c91947d291f",
      "mergeCommit": {
        "oid": "70a349d569f57d100863b9a017ae82346c976d12"
      }
    },
    {
      "number": 26,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyNjA5MDcz",
      "title": "Move priority into the DNS",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/26",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #24",
      "createdAt": "2019-06-27T21:25:06Z",
      "updatedAt": "2019-06-28T00:58:21Z",
      "closedAt": "2019-06-28T00:58:20Z",
      "mergedAt": "2019-06-28T00:58:20Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTQ0NTgy",
          "commit": {
            "abbreviatedOid": "fbdfe03"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-28T00:58:11Z",
          "updatedAt": "2019-06-28T00:58:11Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "a5f0685d6007bacc03bdaa6b60239a408f61abd7",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-pri",
      "headRefOid": "fbdfe03293fe49e359f3c19f8cd6f7c9a417163b",
      "mergeCommit": {
        "oid": "82392badf02331c706eb2d226b128ee038bb04f0"
      }
    },
    {
      "number": 27,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyNjU1MjA2",
      "title": "Some more cleanups from moving pri to a field, with reorder",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/27",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Reorder SvcFieldPriority to be before SvcDomainName to be consistent with SRV and MX.\r\nAdd this in to some other examples.\r\nRemove the IANA instruction for pri.",
      "createdAt": "2019-06-28T01:19:15Z",
      "updatedAt": "2019-06-28T15:44:57Z",
      "closedAt": "2019-06-28T15:44:54Z",
      "mergedAt": "2019-06-28T15:44:54Z",
      "mergedBy": "enygren",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Perhaps leave it in for now but leave that as open discussion?  It may also make sense to just put it back into an Alt-Svc attribute.",
          "createdAt": "2019-06-28T15:44:41Z",
          "updatedAt": "2019-06-28T15:44:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1ODI5NzYx",
          "commit": {
            "abbreviatedOid": "ae724a5"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Oops, thanks for fixing the text that I broke.\r\n\r\nI do wonder whether it would be better to omit SvcFieldPriority from the textual representation when SvcRecordType == 0.  As the name suggests, SvcFieldPriority is mostly the priority for the SvcFieldValue.",
          "createdAt": "2019-06-28T15:20:33Z",
          "updatedAt": "2019-06-28T15:20:33Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "70a349d569f57d100863b9a017ae82346c976d12",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-pri-updates",
      "headRefOid": "ae724a5606930445ccd85c66b300d1afe5a402d7",
      "mergeCommit": {
        "oid": "f549f26e420a98297036c4269db66b1e96bb6dd4"
      }
    },
    {
      "number": 28,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyODgyOTEy",
      "title": "Add discussion to Open Issues on Priority/Weight",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/28",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-06-28T15:51:32Z",
      "updatedAt": "2019-06-28T16:02:05Z",
      "closedAt": "2019-06-28T16:02:02Z",
      "mergedAt": "2019-06-28T16:02:02Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1ODQ5MjUx",
          "commit": {
            "abbreviatedOid": "3e38a29"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-28T15:58:51Z",
          "updatedAt": "2019-06-28T15:58:51Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "f549f26e420a98297036c4269db66b1e96bb6dd4",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-open-discussion-pri",
      "headRefOid": "3e38a2922b6658c86c0578178f494bf6f4ea17fd",
      "mergeCommit": {
        "oid": "fef3e1a24e3bc4a4c350b225d1dc052b8f45d7a4"
      }
    },
    {
      "number": 29,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyOTQ5Nzgz",
      "title": "Remove sni= parameter",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/29",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-06-28T19:49:17Z",
      "updatedAt": "2019-06-28T19:57:54Z",
      "closedAt": "2019-06-28T19:57:51Z",
      "mergedAt": "2019-06-28T19:57:51Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1OTQ5NzU0",
          "commit": {
            "abbreviatedOid": "7a39a1b"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-28T19:56:35Z",
          "updatedAt": "2019-06-28T19:56:35Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "fef3e1a24e3bc4a4c350b225d1dc052b8f45d7a4",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-remove-sni-param",
      "headRefOid": "7a39a1be39f5370996fa8773d956de938e391d40",
      "mergeCommit": {
        "oid": "aa6d0e3b95127cc4e926dd049f7b6f30b43a9330"
      }
    },
    {
      "number": 30,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyOTYwNTUy",
      "title": "Minor textual polish",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/30",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixing typos, improving consistency, and removing trailing whitespace that makes the linter complain.",
      "createdAt": "2019-06-28T20:31:36Z",
      "updatedAt": "2019-07-01T14:53:39Z",
      "closedAt": "2019-07-01T14:53:36Z",
      "mergedAt": "2019-07-01T14:53:36Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2Mzg4MzY5",
          "commit": {
            "abbreviatedOid": "593e8b4"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-01T14:52:54Z",
          "updatedAt": "2019-07-01T14:52:54Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "nygren-httpssvc",
      "baseRefOid": "aa6d0e3b95127cc4e926dd049f7b6f30b43a9330",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-typos",
      "headRefOid": "593e8b453e34b9a07d7a217af5f761e71856c7d0",
      "mergeCommit": {
        "oid": "c48304f1e70d5c9426a6695febfc27b1fae5c7b1"
      }
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0MjI4NDI4",
      "title": "Replace typos of \"HTTPSVC\" with \"HTTPSSVC\"",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/31",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Of course I noticed this just as we submitted the -00.",
      "createdAt": "2019-07-03T15:43:57Z",
      "updatedAt": "2019-07-03T16:00:36Z",
      "closedAt": "2019-07-03T16:00:36Z",
      "mergedAt": "2019-07-03T16:00:36Z",
      "mergedBy": "bemasc",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NTkwMDYz",
          "commit": {
            "abbreviatedOid": "a7ddcbe"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-03T16:00:29Z",
          "updatedAt": "2019-07-03T16:00:29Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "9a088ec47f656348b8d58366d86e4ccc38eadb5f",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-fix-httpsvc-to-httpssvc",
      "headRefOid": "a7ddcbe9133c7700bf6f06f2e04f2e845950d691",
      "mergeCommit": {
        "oid": "5d1da9338e8026df7bf3ac57ebef2a00e630a5b9"
      }
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0MzExMTM5",
      "title": "Suggestions from Ilari: Update tls13 reference.  Switch from 302 to 307 redirect.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/33",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-07-03T20:02:58Z",
      "updatedAt": "2019-07-08T21:03:21Z",
      "closedAt": "2019-07-08T21:03:15Z",
      "mergedAt": "2019-07-08T21:03:15Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTU1MTAx",
          "commit": {
            "abbreviatedOid": "4e52078"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T21:02:46Z",
          "updatedAt": "2019-07-08T21:02:46Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "242f0f7722303c02fb0b90e4897267e249c557fb",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-httpssvc-feedback-201907",
      "headRefOid": "4e52078d6a3c21bb6e94baea5d9486d2236149e4",
      "mergeCommit": {
        "oid": "c04513f7b2a9c457dd0f8e2bfbae8c505397691d"
      }
    },
    {
      "number": 35,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0ODY0OTI1",
      "title": "Remove redundancy from the wire format.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/35",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Address most issues in #32 \r\n\r\nWe should still land:\r\n\r\n\r\n## Special cases for SvcDomainName\r\n\r\nWhen SvcRecordType=1, there are some special cases to handle\r\nfor SvcDomainName:\r\n* How to indicate it should be equivalent to the RRNAME?\r\n* How to indicate it should be equivalent to the hostname?\r\n* What happens if it has the value \".\"?  SRV and MX have this\r\n  mean \"no service available.",
      "createdAt": "2019-07-05T12:49:45Z",
      "updatedAt": "2019-07-08T12:22:21Z",
      "closedAt": "2019-07-08T12:22:16Z",
      "mergedAt": "2019-07-08T12:22:16Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NTg2MjI5",
          "commit": {
            "abbreviatedOid": "9afd423"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-06T11:21:13Z",
          "updatedAt": "2019-07-06T11:26:32Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "This talks about SvcDomainName being empty, but SvcDomainName can't be empty in this serialization.",
              "createdAt": "2019-07-06T11:21:13Z",
              "updatedAt": "2019-07-08T12:19:44Z"
            },
            {
              "originalPosition": 54,
              "body": "I think we should resolve this before merging.  If SRV and MX special-case \".\", I think that we can do the same.\r\n\r\nI don't think we need a way to say \"equivalent to the hostname\".  The hostname has already been delegated to this RRNAME.",
              "createdAt": "2019-07-06T11:25:25Z",
              "updatedAt": "2019-07-08T12:19:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4ODQyNDEw",
          "commit": {
            "abbreviatedOid": "dd959ba"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T11:29:32Z",
          "updatedAt": "2019-07-08T12:00:34Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Missing \"the\".",
              "createdAt": "2019-07-08T11:29:33Z",
              "updatedAt": "2019-07-08T12:19:44Z"
            }
          ]
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "5d1da9338e8026df7bf3ac57ebef2a00e630a5b9",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-remove-wireformat-redundancy",
      "headRefOid": "97de449f1ddab4940458e18a4a9f2f8460c23ed1",
      "mergeCommit": {
        "oid": "1ef3d3a266627c2577a539d88e137c103ab7b096"
      }
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1MDQwNzEz",
      "title": "Missing semicolons in Alt-Svc records",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/36",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There should be a semicolon before esnikeys",
      "createdAt": "2019-07-06T13:50:35Z",
      "updatedAt": "2019-07-08T20:13:47Z",
      "closedAt": "2019-07-08T20:13:47Z",
      "mergedAt": "2019-07-08T20:13:47Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "8885fdd540604ef97d55d021977ab12251794250",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-missing-semicolons",
      "headRefOid": "ffae9befab3b60c9b01888517d81bde217bfd153",
      "mergeCommit": {
        "oid": "242f0f7722303c02fb0b90e4897267e249c557fb"
      }
    },
    {
      "number": 37,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1MzEyMjMx",
      "title": "Switch from \"hq\" to \"h3\"",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/37",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Per suggestion from Lucas Pardue.",
      "createdAt": "2019-07-08T12:26:03Z",
      "updatedAt": "2019-07-08T12:31:07Z",
      "closedAt": "2019-07-08T12:31:03Z",
      "mergedAt": "2019-07-08T12:31:02Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4ODY3MDc4",
          "commit": {
            "abbreviatedOid": "ae453a0"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T12:27:44Z",
          "updatedAt": "2019-07-08T12:27:44Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "64a678a09793e6f14e6f75f0f6a2c8071479197f",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-hq-h3",
      "headRefOid": "4f395e9ec0e2e81f2ef3c73e28e25cbb580ef55e",
      "mergeCommit": {
        "oid": "8885fdd540604ef97d55d021977ab12251794250"
      }
    },
    {
      "number": 38,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1MzIyNDky",
      "title": "Update README.md",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/38",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add httpssvc to the readme",
      "createdAt": "2019-07-08T12:54:39Z",
      "updatedAt": "2019-07-08T13:05:07Z",
      "closedAt": "2019-07-08T13:05:00Z",
      "mergedAt": "2019-07-08T13:05:00Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "8885fdd540604ef97d55d021977ab12251794250",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-readme-and-impl",
      "headRefOid": "88810c5d19507cf8f1e1c2fd15e4818ea0da90be",
      "mergeCommit": {
        "oid": "43eb6348486506ee925886c4946148f07671bc83"
      }
    },
    {
      "number": 43,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk3MjE2MzY2",
      "title": "fix title",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/43",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-07-12T20:39:24Z",
      "updatedAt": "2019-08-20T18:43:51Z",
      "closedAt": "2019-08-20T18:43:48Z",
      "mergedAt": "2019-08-20T18:43:48Z",
      "mergedBy": "bemasc",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc3MzY2NzIy",
          "commit": {
            "abbreviatedOid": "5aece38"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-20T18:43:41Z",
          "updatedAt": "2019-08-20T18:43:41Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "c04513f7b2a9c457dd0f8e2bfbae8c505397691d",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-fix-title",
      "headRefOid": "5aece38f5033f3d82899d5a51da8f54fe20a034b",
      "mergeCommit": {
        "oid": "6d8a728ec6133768283a1c19b647526955867fb2"
      }
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0MzEyNDk1MDk5",
      "title": "Full edit pass on SVCB",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/50",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc",
        "enygren"
      ],
      "labels": [],
      "body": "This includes a mix of syntactic, editorial, and\r\nsubstantive changes, with the goal of getting ready\r\nfor 00.",
      "createdAt": "2019-08-29T21:08:13Z",
      "updatedAt": "2019-09-20T21:08:38Z",
      "closedAt": "2019-09-20T21:08:30Z",
      "mergedAt": "2019-09-20T21:08:30Z",
      "mergedBy": "bemasc",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgzMTYxMzU1",
          "commit": {
            "abbreviatedOid": "f3b0a62"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-03T17:52:08Z",
          "updatedAt": "2019-09-03T17:52:09Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Reading through both the Abstract and the Intro, it would be nice to edit these a bit more heavily for length:\r\n- Abstract is quite long, would be nice to be one paragraph (minus the parts that will be removed)\r\n- While the note in the abstract does explain the name, it may be nice to explain a bit. Especially since SVCB isn't really obvious as a name.\r\n- The abstract mentions enhancements to performance and privacy, but these aren't summarized at all in the intro. I'd expect some explanation here to enhance the \"why should I care\".",
              "createdAt": "2019-09-03T17:52:09Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgzMjkxNjU3",
          "commit": {
            "abbreviatedOid": "f3b0a62"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-03T22:20:36Z",
          "updatedAt": "2019-09-03T22:20:37Z",
          "comments": [
            {
              "originalPosition": 469,
              "body": "Thanks for the reference!\r\n\r\nAs a nit, missing a period at the end of the sentence:\r\n```suggestion\r\nuse an approach such as {{!HappyEyeballsV2=RFC8305}}.\r\n```",
              "createdAt": "2019-09-03T22:20:36Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgzMjkyNzI1",
          "commit": {
            "abbreviatedOid": "f3b0a62"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-03T22:23:50Z",
          "updatedAt": "2019-09-03T22:23:50Z",
          "comments": [
            {
              "originalPosition": 625,
              "body": "```suggestion\r\nThe SvcParamKey for ESNI is \"esnikeys\".  Its value is defined in\r\n```",
              "createdAt": "2019-09-03T22:23:50Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg0NDE4NTY1",
          "commit": {
            "abbreviatedOid": "72ea181"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-05T17:22:35Z",
          "updatedAt": "2019-09-05T17:22:35Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Done and done.",
              "createdAt": "2019-09-05T17:22:35Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1MTI0NjQy",
          "commit": {
            "abbreviatedOid": "72ea181"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This looks generally quite good!  See a bunch of questions throughout, although many are just ideas/suggestions/clarifications and some we can defer for later.  I'm also going to submit a PR against this from enygren-svcb-generalization-2 with a bunch of additional minor edits. ",
          "createdAt": "2019-09-06T22:24:18Z",
          "updatedAt": "2019-09-07T03:17:05Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Do we still want to mention extensibility somewhere in the intro?  I think that would be helpful to give context for some of the design decisions.  (ie, that this also may allow future use-cases to be covered without needing to add additional DNS lookups.)",
              "createdAt": "2019-09-06T22:24:18Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 152,
              "body": "It only is functionally equivalent for the services it specifies.  Hence why the \"for alternative service endpoints including HTTPS\" was there.  Is there a better way to phrase this compactly?",
              "createdAt": "2019-09-06T22:27:55Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 268,
              "body": "Do we want to include all of ALPHA or just:\r\n\r\n          ALPHA_LC          =  %x61-7A   ;  a-z\r\n\r\n?  (Since case insensitive.)",
              "createdAt": "2019-09-06T22:34:19Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 275,
              "body": "\"SHOULD NOT \"?\r\nShould clients use the first or last instance of a parameter that violates this and appears more than once if the specification doesn't allow this?  Perhaps MUST use just the first?  ",
              "createdAt": "2019-09-06T22:36:37Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 417,
              "body": "Isn't it possible that it can contain all of these? \r\nPerhaps:\r\n\r\n> The SvcDomainName MUST point to a domain name that contains\r\n> another SVCB record, address (AAAA and/or A) records,\r\n> or both address records and a ServiceForm SVCB record.\r\n",
              "createdAt": "2019-09-06T23:03:27Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 465,
              "body": "Should we have something more consistent here?  For example:\r\n\r\n> Unless specified otherwise by the protocol mapping, clients MUST ignore\r\n> SvcFieldValue parameters that they do not understand.\r\n",
              "createdAt": "2019-09-06T23:06:26Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 478,
              "body": "Adding an example here would be helpful.  For example:\r\n\r\n> For example, in the following example \"svc2.example.net\"\r\n> is the effective SvcDomainName:\r\n> \r\n>     www.example.com.  7200  IN HTTPSSVC svc.example.net.\r\n>     svc.example.net.  7200  IN CNAME    svc2.example.net.\r\n>     svc2.example.net. 7200  IN HTTPSSVC 0 . ( alpn=h2\r\n>                                          port=8002 esnikeys=\"...\" )\r\n>     svc2.example.net. 300   IN A         192.0.2.2\r\n>     svc2.example.net. 300   IN AAAA      2001:db8::2\r\n",
              "createdAt": "2019-09-06T23:12:10Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 503,
              "body": "Is the duplicate SvcFieldValue a typo?",
              "createdAt": "2019-09-07T02:04:40Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 1182,
              "body": "Meta:  \r\n\r\nI guess we should pick \"an SVCB\" or \"a SVCB\" and then replace consistently throughout. Which depends on whether it is pronounced \"a Service B record\" or \"an S.V.C.B. record\".\r\n",
              "createdAt": "2019-09-07T02:12:07Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 652,
              "body": "Should we rename this as \"proto\"?  That might be more human-friendly?",
              "createdAt": "2019-09-07T02:34:57Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 659,
              "body": "Should we allow multiple \"alpn\" entries?  One specific use-case would be to allow both h2 and http1.1 to be listed compactly as options in the same entry, which might be a common case?  (In this case, the first one listed should be defined to take preference.)  Or is this too much complexity?",
              "createdAt": "2019-09-07T02:38:51Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 821,
              "body": "Do we want to exclude \"a\" and \"aaaa\" from this?  (If anything, the defined format won't work within Alt-Svc.)",
              "createdAt": "2019-09-07T02:54:02Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 933,
              "body": "Do we not need any of this?",
              "createdAt": "2019-09-07T02:58:30Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 1085,
              "body": "Do we want a column for \"Repeats\" to indicate whether it is allowed to repeat?  (Or maybe just leave that with the definition?)",
              "createdAt": "2019-09-07T03:01:43Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 478,
              "body": "(This is included in my PR)",
              "createdAt": "2019-09-07T03:15:42Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1NTQ2MTkx",
          "commit": {
            "abbreviatedOid": "72ea181"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-09T14:25:09Z",
          "updatedAt": "2019-09-09T15:08:43Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "OK, I've modified this text to note that.",
              "createdAt": "2019-09-09T14:25:09Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 152,
              "body": "Clarified.",
              "createdAt": "2019-09-09T14:26:22Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 275,
              "body": "Done",
              "createdAt": "2019-09-09T14:36:16Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 417,
              "body": "Resolved in your edit",
              "createdAt": "2019-09-09T14:36:28Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 465,
              "body": "Done",
              "createdAt": "2019-09-09T14:37:31Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 503,
              "body": "Fixed in your edit.",
              "createdAt": "2019-09-09T14:38:04Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 652,
              "body": "I think \"proto\" sounds like something that would apply to any \"protocol\" that uses SVCB, but in fact this field is specific to TLS-based protocols.  For example, one might be tempted to use \"proto=ssh\" for a SVCB-for-SSH, but of course that is nonsense.\r\n\r\nIf you want we could change it to \"tls-proto\", but I think \"ALPN\" is the usual nomenclature in the TLS and HTTP world.",
              "createdAt": "2019-09-09T14:46:09Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 659,
              "body": "I see the appeal, but I'd rather preserve the 1:1 mapping with Alt-Svc.  Allowing multiple ALPNs significantly complicates the Alt-Svc synthesis algorithm.\r\n\r\nIn practice, I think the only ALPNs in play are \"h2\" and \"h3\", so we're not talking about an enormous amount of duplication.",
              "createdAt": "2019-09-09T14:46:57Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 821,
              "body": "They are excluded by virtue of not having a defined mapping.  However, I don't want to rule out a future draft defining a mapping.\r\n\r\nI think the format will work fine in Alt-Svc; it just requires quotes around the value.",
              "createdAt": "2019-09-09T14:54:25Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 933,
              "body": "On closer inspection, it looks like I lost the bit about the trailing \".\".  I added that back in.\r\n\r\nI tried to remove the parts of this section that were restating information that was already defined: our resolution procedure, the conceptual mapping in `#map2altsvc`, and the Alt-Svc syntax from RFC 7838.  I think we should lean toward brevity until we get a request for clarification.\r\n\r\nI did preserve the portion about ordering, which did not appear to be duplicated anywhere else.",
              "createdAt": "2019-09-09T14:59:16Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 1085,
              "body": "I don't think it's necessary at this time.",
              "createdAt": "2019-09-09T14:59:58Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            },
            {
              "originalPosition": 1182,
              "body": "There was only one instance of \"a SVCB\", so I went with the majority.",
              "createdAt": "2019-09-09T15:00:45Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1NTc5NTAx",
          "commit": {
            "abbreviatedOid": "cdcaef2"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-09T15:09:22Z",
          "updatedAt": "2019-09-09T15:09:22Z",
          "comments": [
            {
              "originalPosition": 268,
              "body": "It sounds like you want registered keys to be lower-case, but display-form to be case-insensitive.  I attempted to capture that.",
              "createdAt": "2019-09-09T15:09:22Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1NzE2NDc5",
          "commit": {
            "abbreviatedOid": "cdcaef2"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "Partial review, but these generally look like improvements.  I'll read further tomorrow.",
          "createdAt": "2019-09-09T18:59:24Z",
          "updatedAt": "2019-09-09T21:04:46Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "Maybe easier to just say \"Support non-default TCP and UDP ports\"?",
              "createdAt": "2019-09-09T18:59:24Z",
              "updatedAt": "2019-09-12T20:57:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg3NzAwODAx",
          "commit": {
            "abbreviatedOid": "cdcaef2"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "@MikeBishop, please let me know if you have any other comments.  I would like to get this finalized for -00 as soon as possible.",
          "createdAt": "2019-09-12T20:58:13Z",
          "updatedAt": "2019-09-12T20:58:47Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "Done",
              "createdAt": "2019-09-12T20:58:13Z",
              "updatedAt": "2019-09-12T20:58:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNTYxODQ5",
          "commit": {
            "abbreviatedOid": "b85bdcd"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T13:23:15Z",
          "updatedAt": "2019-09-19T13:23:16Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "I'm not seeing this or am I missing this.  Did this not get committed/merged?",
              "createdAt": "2019-09-19T13:23:16Z",
              "updatedAt": "2019-09-19T13:23:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNTYzNDky",
          "commit": {
            "abbreviatedOid": "b85bdcd"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T13:25:38Z",
          "updatedAt": "2019-09-19T13:25:38Z",
          "comments": [
            {
              "originalPosition": 933,
              "body": "I'm not seeing this or am I missing this.  Did this not get committed/merged?",
              "createdAt": "2019-09-19T13:25:38Z",
              "updatedAt": "2019-09-19T13:25:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNTY0MjI1",
          "commit": {
            "abbreviatedOid": "b85bdcd"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T13:26:40Z",
          "updatedAt": "2019-09-19T13:26:40Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "I'm not seeing this or am I missing this.  Did this not get committed/merged?",
              "createdAt": "2019-09-19T13:26:40Z",
              "updatedAt": "2019-09-19T13:26:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNTY1NzM1",
          "commit": {
            "abbreviatedOid": "b85bdcd"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T13:28:49Z",
          "updatedAt": "2019-09-19T13:28:49Z",
          "comments": [
            {
              "originalPosition": 1182,
              "body": "I think this may be because it used to be \"an ALTSVC\" and then \"an HTTPS\" so when I did the query-replace I didn't fix/replace.  This can get cleaned up later.",
              "createdAt": "2019-09-19T13:28:49Z",
              "updatedAt": "2019-09-19T13:28:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNjcwMzMz",
          "commit": {
            "abbreviatedOid": "b85bdcd"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T15:51:33Z",
          "updatedAt": "2019-09-19T15:51:33Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "The current commit says \"Enables CNAME-like functionality at a zone apex (such as \"example.com\") for participating protocols, and generally enables delegation of operational authority for an origin within the DNS to an alternate name.\"\r\n\r\n",
              "createdAt": "2019-09-19T15:51:33Z",
              "updatedAt": "2019-09-19T15:51:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNjcxNzE0",
          "commit": {
            "abbreviatedOid": "b85bdcd"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T15:53:43Z",
          "updatedAt": "2019-09-19T15:53:43Z",
          "comments": [
            {
              "originalPosition": 933,
              "body": "The current commit has the text \"The SvcDomainName is mapped into the uri-host portion of alt-authority with the trailing \".\" removed.\", at the top of `#map2altsvc`.",
              "createdAt": "2019-09-19T15:53:43Z",
              "updatedAt": "2019-09-19T15:53:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNjczMzMy",
          "commit": {
            "abbreviatedOid": "b85bdcd"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T15:56:08Z",
          "updatedAt": "2019-09-19T15:56:08Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "I believe this is covered by lines 100-107.  It sounds like some changes aren't showing for you, so you might need to select \"Changes from all commits\" in the \"Files changed\" tab.",
              "createdAt": "2019-09-19T15:56:08Z",
              "updatedAt": "2019-09-19T15:56:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkxMzg4NjQz",
          "commit": {
            "abbreviatedOid": "b85bdcd"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me!  Ship it.",
          "createdAt": "2019-09-20T20:45:45Z",
          "updatedAt": "2019-09-20T20:45:45Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "enygren-svcb-generalization-1",
      "baseRefOid": "d34ff409b6d49573acec2b7caaeab4b198934b25",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-generalization-1",
      "headRefOid": "b85bdcd3f091b1271f7a68347d73f27249969f19",
      "mergeCommit": {
        "oid": "97ba8ae51e6c957d256dfd31160c2c31da1e63f3"
      }
    },
    {
      "number": 51,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE1MTYyMDM1",
      "title": "Proposed edits to Ben's edits.  Most are minor.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/51",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "Minor typo fixes and edits.  Add proxy behavior.  Add a/aaaa param clarifications.",
      "createdAt": "2019-09-07T03:18:45Z",
      "updatedAt": "2019-09-09T14:22:36Z",
      "closedAt": "2019-09-09T14:22:36Z",
      "mergedAt": "2019-09-09T14:22:36Z",
      "mergedBy": "bemasc",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1NTQwNDI3",
          "commit": {
            "abbreviatedOid": "71adab4"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I have some thoughts on the substantive changes but I'll propose further revisions in another PR.",
          "createdAt": "2019-09-09T14:17:29Z",
          "updatedAt": "2019-09-09T14:22:20Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "It sounds like you are proposing to chase the SVCB chain outside the proxy, and then use the final SvcDomainName in the request-target.  That seems like a fine idea to me, but I think the recommendation should be weaker.  I don't want anyone to think that we're telling them to leak DNS queries to an untrusted resolver when using a proxy for privacy purposes.",
              "createdAt": "2019-09-09T14:17:29Z",
              "updatedAt": "2019-09-09T14:22:20Z"
            },
            {
              "originalPosition": 144,
              "body": "I think this requirement already exists, regardless of whether the client is IPv6-only.",
              "createdAt": "2019-09-09T14:21:01Z",
              "updatedAt": "2019-09-09T14:22:20Z"
            }
          ]
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "bemasc-generalization-1",
      "baseRefOid": "e8662772d0dc217842e546917510b21d0d5d18ab",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-svcb-generalization-2",
      "headRefOid": "71adab4b3f62dd5b275327e7d90b8537fa923009",
      "mergeCommit": {
        "oid": "cdb286768e431fd274ca9707163de27e4a87fa22"
      }
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE1NTk0NzE2",
      "title": "Proxy and DNS64 text proposals",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/52",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-09-09T15:39:44Z",
      "updatedAt": "2019-09-09T20:23:04Z",
      "closedAt": "2019-09-09T20:23:04Z",
      "mergedAt": "2019-09-09T20:23:04Z",
      "mergedBy": "bemasc",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1NjczMjg0",
          "commit": {
            "abbreviatedOid": "7c6a390"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-09-09T17:43:37Z",
          "updatedAt": "2019-09-09T17:48:10Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Mention \"unless SVCB queries are also issued via the proxy (eg, via DoH)\"?\r\n\r\nPart of the need to specify the proxy behavior is to get ESNI to work properly.  Should we spell this out here (to explain why this proxy behavior is important), or perhaps later?  ie, part of getting ESNI to work means the keys and SvcDomainName corresponding to the connect need to match up.",
              "createdAt": "2019-09-09T17:43:37Z",
              "updatedAt": "2019-09-09T19:46:41Z"
            },
            {
              "originalPosition": 63,
              "body": "I'm still solidly in the \"if you are skipping your local DNS resolver's DNS64, you MUST do rfc7050 synthesis\" camp.  There are tens (hundreds?) of millions of mobile end-users who will be broken otherwise for IPv4-only sites.  An alternative would be to say that a \"aaaa\" parameter MUST be included if an \"a\" parameter is present?  (Which puts the onus on the server-side.)  If we don't have a MUST on the client or the server, recursive resolvers will do DNS64 synthesis here so having a MUST NOT there is unrealistic.",
              "createdAt": "2019-09-09T17:47:55Z",
              "updatedAt": "2019-09-09T19:46:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1Njk4NTc2",
          "commit": {
            "abbreviatedOid": "33a6aa0"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-09T18:27:54Z",
          "updatedAt": "2019-09-09T18:27:55Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "OK, I added an explanation of motivations for the proxy section.",
              "createdAt": "2019-09-09T18:27:54Z",
              "updatedAt": "2019-09-09T19:46:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1Njk5Nzkz",
          "commit": {
            "abbreviatedOid": "33a6aa0"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-09T18:29:53Z",
          "updatedAt": "2019-09-09T18:29:53Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "> I'm still solidly in the \"if you are skipping your local DNS resolver's DNS64, you MUST do rfc7050 synthesis\" camp.\r\n\r\nMe too.\r\n\r\n> There are tens (hundreds?) of millions of mobile end-users who will be broken otherwise for IPv4-only sites.\r\n\r\nI don't think anyone will be broken, because the alternative is to just ignore address hints you can't use.\r\n\r\n> If we don't have a MUST on the client or the server...\r\n\r\nWe have a MUST on the client: \"clients MUST perform A and/or AAAA queries for SvcDomainName as in {{client-behavior}}\"",
              "createdAt": "2019-09-09T18:29:53Z",
              "updatedAt": "2019-09-09T19:46:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1NzAzMTQy",
          "commit": {
            "abbreviatedOid": "33a6aa0"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-09T18:35:35Z",
          "updatedAt": "2019-09-09T18:35:36Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Good point.  So perhaps:\r\n\r\nWhen only \"a\" parameters are present, IPv6-only clients may either synthesize IPv6 addresses as specified in {{!RFC7050}} or fall back to resolving SvcDomainName. To avoid this, \"aaaa\" parameters SHOULD be published whenever \"a\" parameters are published.\r\n\r\n?",
              "createdAt": "2019-09-09T18:35:36Z",
              "updatedAt": "2019-09-09T19:46:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1NzA0MjQ1",
          "commit": {
            "abbreviatedOid": "33a6aa0"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-09T18:37:37Z",
          "updatedAt": "2019-09-09T18:37:37Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Sounds good.  Do we want to highlight that proxies trying to do content filtering and assuming that what they are connecting to is the Host/SNI could get confused?  (Which are the same proxies that ESNI will make sad.)",
              "createdAt": "2019-09-09T18:37:37Z",
              "updatedAt": "2019-09-09T19:46:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1NzA4Nzc5",
          "commit": {
            "abbreviatedOid": "33a6aa0"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-09T18:45:38Z",
          "updatedAt": "2019-09-09T18:45:39Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Works for me.",
              "createdAt": "2019-09-09T18:45:39Z",
              "updatedAt": "2019-09-09T19:46:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1NzM0NDAy",
          "commit": {
            "abbreviatedOid": "33a6aa0"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-09T19:34:19Z",
          "updatedAt": "2019-09-09T19:34:20Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I'd rather leave that alone if possible.  Using an \"affiliated resolver\" as described would cover that use case.",
              "createdAt": "2019-09-09T19:34:19Z",
              "updatedAt": "2019-09-09T19:46:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1NzQwNTky",
          "commit": {
            "abbreviatedOid": "1c2ae4b"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-09T19:46:48Z",
          "updatedAt": "2019-09-09T19:46:48Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "OK, I added a version of this.  Note that \"fallback\" is probably not an accurate depiction of what's going on here: the AAAA query MUST be issued regardless, and SHOULD be used as soon as it's ready, so the only question is whether to wait for it.",
              "createdAt": "2019-09-09T19:46:48Z",
              "updatedAt": "2019-09-09T19:46:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1NzU0MzY2",
          "commit": {
            "abbreviatedOid": "1c2ae4b"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-09T20:12:05Z",
          "updatedAt": "2019-09-09T20:12:05Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "bemasc-generalization-1",
      "baseRefOid": "cdcaef2b5ca6b356487930fe5bb074a1900c1a2f",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-generalization-2",
      "headRefOid": "1c2ae4b6475269e42a39825b7567a174071e2ad1",
      "mergeCommit": {
        "oid": "c6e3586285307168b1e489a788ed2fdd489c5a37"
      }
    },
    {
      "number": 53,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIwNDA1Mzcz",
      "title": "Minor changes from a fresh read",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/53",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* Use DNS terminology consistent with RFC 8499.\r\n* Renamed \"a\" and \"aaaa\" to \"ipv4hint\" and \"ipv6hint\"\r\n* Editorial changes for clarity and brevity.",
      "createdAt": "2019-09-23T17:40:49Z",
      "updatedAt": "2019-09-23T21:04:49Z",
      "closedAt": "2019-09-23T21:04:43Z",
      "mergedAt": "2019-09-23T21:04:43Z",
      "mergedBy": "bemasc",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkxOTYzMDYw",
          "commit": {
            "abbreviatedOid": "4a3761d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-23T18:15:22Z",
          "updatedAt": "2019-09-23T18:15:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkyMDUyNzYx",
          "commit": {
            "abbreviatedOid": "4a3761d"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Look good to me!",
          "createdAt": "2019-09-23T21:03:28Z",
          "updatedAt": "2019-09-23T21:03:28Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "6c51820908de2f41cdcfe44d54b307afff9a07c4",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-proofread",
      "headRefOid": "4a3761db3988362d51fe08790d36af906a6ab088",
      "mergeCommit": {
        "oid": "0b6486523ea9720693329ff64d08519f1acd2600"
      }
    },
    {
      "number": 54,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIwNDg5MTI4",
      "title": "Define SVCB only within the IN class (issue #41)",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/54",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-09-23T21:28:44Z",
      "updatedAt": "2019-09-23T22:54:11Z",
      "closedAt": "2019-09-23T22:54:01Z",
      "mergedAt": "2019-09-23T22:54:01Z",
      "mergedBy": "bemasc",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkyMDk2Nzcw",
          "commit": {
            "abbreviatedOid": "2c32c05"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-23T22:53:54Z",
          "updatedAt": "2019-09-23T22:53:54Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "0b6486523ea9720693329ff64d08519f1acd2600",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-issue-41",
      "headRefOid": "2c32c053d7d041f866adc586a366ff6711a7590a",
      "mergeCommit": {
        "oid": "d280fdfee16bd03d8ec01a7de13e1b869a6f59da"
      }
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIxNDA5NDM5",
      "title": "Clarify racing behavior for A/AAAA and SVCB parallel queries. Give rationale to A/AAAA answer preference.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/56",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We have text in the ESNI draft which describes what to do when A/AAAA arrives before ESNI (equivalently SVCB). This attempts to port that text over. Please have a look!\r\n\r\n@enygren @MikeBishop @bemasc ",
      "createdAt": "2019-09-25T19:49:20Z",
      "updatedAt": "2019-10-09T14:26:14Z",
      "closedAt": "2019-09-27T13:51:24Z",
      "mergedAt": "2019-09-27T13:51:24Z",
      "mergedBy": "bemasc",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for identifying this optimization and writing it up!",
          "createdAt": "2019-09-26T17:52:57Z",
          "updatedAt": "2019-09-26T17:52:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzMzI3NDc1",
          "commit": {
            "abbreviatedOid": "d87fbb7"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-25T19:58:41Z",
          "updatedAt": "2019-09-25T19:58:42Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Since you pronounce this \"Ess Vee Cee Bee\" it should remain \"an\"",
              "createdAt": "2019-09-25T19:58:41Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzMzI0OTg2",
          "commit": {
            "abbreviatedOid": "d87fbb7"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-25T19:54:08Z",
          "updatedAt": "2019-09-26T14:13:07Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "The current logic just requires the client to wait for the SVCB response.  As you note, the SVCB response contains security-relevant information, so it's important not to miss it.\r\n\r\nIs the goal here to handle [DNS non-response](https://tools.ietf.org/html/draft-ietf-dnsop-no-response-issue-13)?  Even the most ancient DNS servers will return an error if there is a problem with the SVCB query.  Total non-response is a serious bug, but it does happen.\r\n\r\nAs that draft notes, the client [can measure this behavior](https://tools.ietf.org/html/draft-ietf-dnsop-no-response-issue-13#section-3.1.2).  If you think it's worth documenting a solution for this case, I'd prefer that approach, and I'd suggest doing it in a separate \"Compatibility\" section.",
              "createdAt": "2019-09-26T14:09:41Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            },
            {
              "originalPosition": 50,
              "body": "I think this would have a very high false-positive rate due to iterative lookups required to walk the SVCB chain.",
              "createdAt": "2019-09-26T14:10:22Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzNzc0OTE1",
          "commit": {
            "abbreviatedOid": "cbaca38"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T14:39:32Z",
          "updatedAt": "2019-09-26T14:39:33Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "> Is the goal here to handle DNS non-response?\r\n\r\nNot quite! The goal is to handle answers received out of order. It\u2019s an optimization. ",
              "createdAt": "2019-09-26T14:39:32Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzNzc4MzUy",
          "commit": {
            "abbreviatedOid": "cbaca38"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T14:44:03Z",
          "updatedAt": "2019-09-26T14:44:03Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "This is the delay in waiting for the first SVCB response, not the delay in abandoning ESNI altogether. The value is meant to give the SVCB answer time to arrive since, presumably, clients would prefer using that over the A/AAAA answer(s). Maybe I\u2019m misunderstanding your point. ",
              "createdAt": "2019-09-26T14:44:03Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzNzg3NTQ0",
          "commit": {
            "abbreviatedOid": "cbaca38"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T14:55:37Z",
          "updatedAt": "2019-09-26T14:55:37Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "This should also reference {#optimizations} and also allow the use of responses in the client DNS cache, not just hints.  In-particular due to this it may often be possible that the hint values aren't needed if the SvcDomainName already has valid A/AAAA records in-cache (eg, due to being part of the CNAME chain from the A/AAAA lookups issued in-parallel):\r\n\r\n> To avoid a delay for clients using a nonconforming recursive resolver, domain owners SHOULD use a single SVCB record whose SvcDomainName is in the origin hostname's CNAME chain if possible. This will ensure that the required address records are already present in the client's DNS cache as part of the responses to the address queries that were issued in parallel.",
              "createdAt": "2019-09-26T14:55:37Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzNzg3NzQ0",
          "commit": {
            "abbreviatedOid": "cbaca38"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T14:55:52Z",
          "updatedAt": "2019-09-26T14:55:52Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Typo.  s/SVCR/SVCB/",
              "createdAt": "2019-09-26T14:55:52Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzNzk4NTQx",
          "commit": {
            "abbreviatedOid": "cbaca38"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T15:10:00Z",
          "updatedAt": "2019-09-26T15:10:01Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Will fix!",
              "createdAt": "2019-09-26T15:10:00Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzNzk4OTk2",
          "commit": {
            "abbreviatedOid": "cbaca38"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T15:10:38Z",
          "updatedAt": "2019-09-26T15:10:38Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Yes, great point! I'll specify that cached answers are viable. (This content already exists in the {#optimizations} section, so a citation seems redundant?)",
              "createdAt": "2019-09-26T15:10:38Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzNzkxMjE0",
          "commit": {
            "abbreviatedOid": "cbaca38"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T15:00:06Z",
          "updatedAt": "2019-09-26T15:12:14Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "OK.  As your text notes, SVCB covers a variety of transports and use cases, so I think we need to express this with more generality, like:\r\n> If an A or AAAA response arrives before an SVCB response, the client MAY begin connection as if the SVCB query returned NODATA, but MUST NOT transmit any information that could be altered by an SVCB response until the SVCB response arrives. For example, ...(esni)... .\r\n\r\nAnd then separately\r\n> If an SVCB RR is consistent with an active or in-progress connection, the client MAY prefer that RR.",
              "createdAt": "2019-09-26T15:00:07Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            },
            {
              "originalPosition": 50,
              "body": "OK, got it.",
              "createdAt": "2019-09-26T15:02:09Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzODIyODMy",
          "commit": {
            "abbreviatedOid": "c832436"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T15:44:17Z",
          "updatedAt": "2019-09-26T15:44:17Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Excellent suggestion! I tweaked your proposed text and added it. Please have a look!",
              "createdAt": "2019-09-26T15:44:17Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzODI4MTA2",
          "commit": {
            "abbreviatedOid": "c832436"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T15:51:58Z",
          "updatedAt": "2019-09-26T15:59:12Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I think \"ClientHello\" would be clearer than \"connection\"",
              "createdAt": "2019-09-26T15:51:58Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            },
            {
              "originalPosition": 58,
              "body": "I think changing between \"RR\" and \"record\" in this sentence is slightly confusing.",
              "createdAt": "2019-09-26T15:52:49Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            },
            {
              "originalPosition": 60,
              "body": "Maybe \"in-progress TCP connection\"?  \"proceed on that socket\"?  Also might want to mention ports...",
              "createdAt": "2019-09-26T15:53:47Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            },
            {
              "originalPosition": 64,
              "body": "I would prefer a definition of \"consistent\" where the SVCB record is also consistent with a socket if the AAAA for SvcDomainName matches the socket's IP.",
              "createdAt": "2019-09-26T15:55:57Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            },
            {
              "originalPosition": 66,
              "body": "This requirement is already present in the definition of `ipv*hint`.  Can we find a way to avoid having to repeat it?",
              "createdAt": "2019-09-26T15:58:25Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzODM5NzMz",
          "commit": {
            "abbreviatedOid": "c832436"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T16:09:27Z",
          "updatedAt": "2019-09-26T16:09:28Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I didn't want to bubble up too much of TLS, but if you're fine with it, that works for me!",
              "createdAt": "2019-09-26T16:09:27Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzODQwMDkw",
          "commit": {
            "abbreviatedOid": "c832436"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T16:10:02Z",
          "updatedAt": "2019-09-26T16:10:03Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "I'll stick with record! (And I'll make that change in the rest of this section, too.)",
              "createdAt": "2019-09-26T16:10:02Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzODQxMzQw",
          "commit": {
            "abbreviatedOid": "c832436"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T16:12:07Z",
          "updatedAt": "2019-09-26T16:12:08Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "I think a simplification is, \"TLS should proceed on that connection,\" so we don't need to get into socket or port details. Does that work?",
              "createdAt": "2019-09-26T16:12:08Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzODQ0MDYy",
          "commit": {
            "abbreviatedOid": "c832436"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T16:16:43Z",
          "updatedAt": "2019-09-26T16:16:43Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Hmm... is it? The paragraph here aims to say that if the hints are *not* present, then (1) look in the cache or (2) try to resolve. The definition of `ipv*hint` doesn't seem to cover this case since it assumes they're present, right?",
              "createdAt": "2019-09-26T16:16:43Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzODQ0MzM0",
          "commit": {
            "abbreviatedOid": "c832436"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T16:17:12Z",
          "updatedAt": "2019-09-26T16:17:13Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": ":+1: ",
              "createdAt": "2019-09-26T16:17:12Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzODQ5MTc0",
          "commit": {
            "abbreviatedOid": "e55a034"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T16:25:24Z",
          "updatedAt": "2019-09-26T16:25:24Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Agreed -- I made an attempt at adding one. Please have a look!",
              "createdAt": "2019-09-26T16:25:24Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzODQ4NDQz",
          "commit": {
            "abbreviatedOid": "c832436"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T16:24:14Z",
          "updatedAt": "2019-09-26T16:40:23Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Maybe it would be clearer to say\r\n> if an SVCB record arrives with an \"esnikeys\" value and an IP address from \"ipv6hint\" or an attached AAAA record that matches an in-progress connection, ...\r\n\r\nThat doesn't cover every case it but clarifies what is meant by \"consistent\".",
              "createdAt": "2019-09-26T16:27:53Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            },
            {
              "originalPosition": 58,
              "body": "This definition is good but it leaves out ports and IP hints.",
              "createdAt": "2019-09-26T16:35:59Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            },
            {
              "originalPosition": 66,
              "body": "I don't think this paragraph is necessary.  The relevant requirements are already laid out in `{client-behavior}` and `{svcparamkeys-iphints}`.",
              "createdAt": "2019-09-26T16:37:30Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            },
            {
              "originalPosition": 49,
              "body": "The normative force here is unclear.  Is optimistic pre-connection RECOMMENDED?  What does it mean to wait for \"up to CD milliseconds\"?\r\n\r\nI would prefer for optimistic pre-connection to be OPTIONAL.",
              "createdAt": "2019-09-26T16:39:59Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzODYxNTc0",
          "commit": {
            "abbreviatedOid": "e55a034"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T16:47:37Z",
          "updatedAt": "2019-09-26T16:47:38Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "As mentioned above, I don't think `{svcparamkeys-iphints}` handles this case. (It handles the opposite one, namely, where hints are present.) I think it's important to include this case (paragraph) to be complete. ",
              "createdAt": "2019-09-26T16:47:38Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzODYyOTk3",
          "commit": {
            "abbreviatedOid": "e55a034"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T16:50:13Z",
          "updatedAt": "2019-09-26T16:50:13Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "I think this is OBE.",
              "createdAt": "2019-09-26T16:50:13Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzODY2MzE0",
          "commit": {
            "abbreviatedOid": "e55a034"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T16:55:50Z",
          "updatedAt": "2019-09-26T16:55:51Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "SHOULD and RECOMMENDED are the same per RFC2119, right? I'm fine bumping it down to optional advice, since it truly is optional.\r\n\r\n> What does it mean to wait for \"up to CD milliseconds\"?\r\n\r\nIs \"wait up to CD milliseconds before connecting\" not clear? It means, \"don't try and connect until CD ms go by.\" How can we make this more clear?",
              "createdAt": "2019-09-26T16:55:50Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzODY5MTUw",
          "commit": {
            "abbreviatedOid": "9665bf7"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T17:00:46Z",
          "updatedAt": "2019-09-26T17:00:46Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "I can add ports, but I don't think IP hints are part of the definition. (Or, rather, they don't change things.) There's two cases for hints:\r\n\r\n1. The hints match C's address: Continue using C's address.\r\n2. The hints do not match C's address: The definition of the hints says that C's address should be used since it corresponds to the A/AAAA of SvcDomainName.\r\n\r\nSo I left them out and just included the port.",
              "createdAt": "2019-09-26T17:00:46Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzODcwMTA1",
          "commit": {
            "abbreviatedOid": "9665bf7"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T17:02:25Z",
          "updatedAt": "2019-09-26T17:02:26Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "\"SHOULD wait ... before connecting\" is ambiguous.  Is it \"SHOULD wait and SHOULD connect\" or \"MAY connect but SHOULD wait\"?  I would prefer the latter.  If indirection (non-empty SvcDomainName) turns out to be the most common reason why SVCB is slow, the success rate for this trick might be too low to justify the complexity.\r\n\r\nIt sounds like \"wait *at least* CD milliseconds\" would better capture your meaning.",
              "createdAt": "2019-09-26T17:02:26Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzODc1NDAy",
          "commit": {
            "abbreviatedOid": "9665bf7"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T17:12:06Z",
          "updatedAt": "2019-09-26T17:19:33Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Under the current definition, this record is not consistent with this socket.  The IP hint matches, but consistency is defined in terms of the address record, not the IP hint.\r\n\r\nI think we should fix this by changing the definition, e.g.\r\n> An SVCB record is consistent with an active or in-progress connection if the client would attempt an equivalent connection when making use of that record.",
              "createdAt": "2019-09-26T17:12:06Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            },
            {
              "originalPosition": 72,
              "body": "Could you help me understand what the new requirement is here?  Or could we simplify this to \"If the SVCB record is not consistent with ... clients must proceed as described in step 3 of `{{client-behavior}}`.",
              "createdAt": "2019-09-26T17:19:29Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzODgxMTI0",
          "commit": {
            "abbreviatedOid": "9665bf7"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T17:22:08Z",
          "updatedAt": "2019-09-26T17:22:09Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "> It sounds like \"wait at least CD milliseconds\" would better capture your meaning.\r\n \r\nIndeed it would! I'll use that.",
              "createdAt": "2019-09-26T17:22:08Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzODgxNjk0",
          "commit": {
            "abbreviatedOid": "9665bf7"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T17:23:07Z",
          "updatedAt": "2019-09-26T17:23:07Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Simplifying like so is perfectly fine by me! I wanted to keep the blurb to close the dangling \"else\" case in this section. Good suggestion. :)",
              "createdAt": "2019-09-26T17:23:07Z",
              "updatedAt": "2019-09-26T17:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzODk1NzU4",
          "commit": {
            "abbreviatedOid": "e602609"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T17:47:19Z",
          "updatedAt": "2019-09-26T17:47:20Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Fixed -- thanks!",
              "createdAt": "2019-09-26T17:47:19Z",
              "updatedAt": "2019-09-26T17:47:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzODk4ODAz",
          "commit": {
            "abbreviatedOid": "e602609"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-26T17:52:30Z",
          "updatedAt": "2019-09-26T17:52:30Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk5NDUyOTY5",
          "commit": {
            "abbreviatedOid": "e602609"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-09T14:26:13Z",
          "updatedAt": "2019-10-09T14:26:14Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "@tfpauly, you can also pronounce it \"Service Bee,\" in which case it's \"a\".  Ah, the linguistic implications of how we read acronyms....\r\n\r\nUnless we're going to specify a pronunciation in the draft?  Would have headed off a whole lot of \"giff/jiff\" nonsense.",
              "createdAt": "2019-10-09T14:26:13Z",
              "updatedAt": "2019-10-09T14:26:14Z"
            }
          ]
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "d280fdfee16bd03d8ec01a7de13e1b869a6f59da",
      "headRepository": "chris-wood/dns-alt-svc",
      "headRefName": "caw/edits",
      "headRefOid": "e6026096e93ff6ca7316dbaa74972ce16d418dcb",
      "mergeCommit": {
        "oid": "6deadcf323780c220f21edc0d5c5064fcafe4b56"
      }
    },
    {
      "number": 62,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIyMjAwMTI1",
      "title": "Polish the performance optimization section",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/62",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-09-27T14:49:35Z",
      "updatedAt": "2019-10-10T20:39:22Z",
      "closedAt": "2019-10-10T20:39:19Z",
      "mergedAt": "2019-10-10T20:39:19Z",
      "mergedBy": "bemasc",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk5NTg0Mjcw",
          "commit": {
            "abbreviatedOid": "c249774"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Looks good.",
          "createdAt": "2019-10-09T17:43:29Z",
          "updatedAt": "2019-10-09T17:43:36Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Might want to just rewrap the paragraph.",
              "createdAt": "2019-10-09T17:43:29Z",
              "updatedAt": "2019-10-10T17:19:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwMjI4MDU1",
          "commit": {
            "abbreviatedOid": "e4d7531"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-10T17:20:56Z",
          "updatedAt": "2019-10-10T17:20:57Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Done",
              "createdAt": "2019-10-10T17:20:56Z",
              "updatedAt": "2019-10-10T17:20:57Z"
            }
          ]
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "6deadcf323780c220f21edc0d5c5064fcafe4b56",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-race",
      "headRefOid": "e4d7531c68f7d59acd613691efe2980006a8a834",
      "mergeCommit": {
        "oid": "94a17ceb976ae608e586ae1a1eeef8b9dd1b28cf"
      }
    },
    {
      "number": 64,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIyMzMwOTA0",
      "title": "Change the definition of AliasForm",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/64",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This makes checking the form of an RR faster and simpler,\r\nand ensures that sorting by priority does the right\r\nthing.\r\n\r\nFixes #55 ",
      "createdAt": "2019-09-27T21:16:26Z",
      "updatedAt": "2019-11-04T15:10:36Z",
      "closedAt": "2019-11-04T15:10:32Z",
      "mergedAt": "2019-11-04T15:10:32Z",
      "mergedBy": "bemasc",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3NTMxNjg5",
          "commit": {
            "abbreviatedOid": "79e10af"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-04T14:56:08Z",
          "updatedAt": "2019-10-04T14:56:08Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Do we still need to declare that SvcFieldValue must be empty for AliasForm?  Or that clients must ignore SvcFieldValue in AliasForm?\r\n\r\nGenerally I worry a little about overloading SvcFieldPriority...",
              "createdAt": "2019-10-04T14:56:08Z",
              "updatedAt": "2019-11-04T15:08:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3NTQ4NTE1",
          "commit": {
            "abbreviatedOid": "79e10af"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-04T15:22:25Z",
          "updatedAt": "2019-10-04T15:22:26Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "My thought is to lean toward \"clients must ignore\", which is already implicit in the client behavior specification.  That would be forward-compatible if we eventually discover a use for SvcFieldValue in AliasForm.\r\n\r\nI admit that this proposal special-cases \"0\", but I think \"0 is special\" is an ancient CS tradition.  I particularly like that clients can just sort by priority and then walk down the sorted list in a simple way.",
              "createdAt": "2019-10-04T15:22:25Z",
              "updatedAt": "2019-11-04T15:08:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODI2OTM0",
          "commit": {
            "abbreviatedOid": "79e10af"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This one would be good to get into a -01 version  (and may also be worth a discussion in dnsop to confirm this decision after the change is made).",
          "createdAt": "2019-11-03T16:43:55Z",
          "updatedAt": "2019-11-03T16:43:55Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "f22274b1a2289c33cd4f1b17488bfeca486ec28b",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-pri",
      "headRefOid": "52ccd9b5adf5c636fdd27eb9a55f4c2b7a93c4f7",
      "mergeCommit": {
        "oid": "a5c921ce10bdd3006b28edb73e5e2b11d7021d81"
      }
    },
    {
      "number": 65,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI1NDYzMDI1",
      "title": "Account for semicolon in the presentation format",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/65",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Semicolon is the comment character in zone files.\r\n\r\nFixes #61",
      "createdAt": "2019-10-07T19:45:00Z",
      "updatedAt": "2019-10-13T02:20:32Z",
      "closedAt": "2019-10-13T02:20:32Z",
      "mergedAt": "2019-10-13T02:20:31Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDI5Njcz",
          "commit": {
            "abbreviatedOid": "5a0141b"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-13T02:20:23Z",
          "updatedAt": "2019-10-13T02:20:23Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "6deadcf323780c220f21edc0d5c5064fcafe4b56",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-semicolon",
      "headRefOid": "5a0141bc4c777bfea75b8421f651ceba518def18",
      "mergeCommit": {
        "oid": "fd5feaa8e0807322448967768b8fc0e60979a5bd"
      }
    },
    {
      "number": 66,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI3MzgxNzQ0",
      "title": "Reduce the emphasis on conversion to Alt-Svc",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/66",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "HTTPSSVC is less nearly equivalent to Alt-Svc than\r\nit used to be, and conversion is not a requirement,\r\nnor does it seem to be the most likely path to\r\nimplementation.\r\n\r\nFixes #60 and #58.",
      "createdAt": "2019-10-11T22:00:54Z",
      "updatedAt": "2019-11-04T15:07:43Z",
      "closedAt": "2019-11-04T15:07:40Z",
      "mergedAt": "2019-11-04T15:07:40Z",
      "mergedBy": "bemasc",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDI5NDU0",
          "commit": {
            "abbreviatedOid": "bb19232"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Looks good, minus the comment on \"secure delivery\" being a not clearly defined term. ",
          "createdAt": "2019-10-13T02:09:58Z",
          "updatedAt": "2019-10-13T02:13:25Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "Do we need to define \"secure delivery\"?  That term seems hand-wavy.",
              "createdAt": "2019-10-13T02:09:58Z",
              "updatedAt": "2019-11-04T15:06:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDc3MTAx",
          "commit": {
            "abbreviatedOid": "bb19232"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-14T00:16:41Z",
          "updatedAt": "2019-10-14T00:16:41Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "True.  (So does \"untrusted channels\" below.)  I guess we're really talking about authenticity?  But maybe the thing to do is to repeat \"untrusted channels\" here...",
              "createdAt": "2019-10-14T00:16:41Z",
              "updatedAt": "2019-11-04T15:06:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDgyMzgy",
          "commit": {
            "abbreviatedOid": "bb19232"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-14T01:30:37Z",
          "updatedAt": "2019-10-14T01:30:37Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "Perhaps be consistent about \"untrusted channels\" but then define what that means somewhere, such as its first reference?",
              "createdAt": "2019-10-14T01:30:37Z",
              "updatedAt": "2019-11-04T15:06:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxOTQ0ODU4",
          "commit": {
            "abbreviatedOid": "27d6ce1"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-15T14:18:06Z",
          "updatedAt": "2019-10-15T14:18:07Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "OK, I've rephrased this to be about \"untrusted channels\".  Please review.",
              "createdAt": "2019-10-15T14:18:07Z",
              "updatedAt": "2019-11-04T15:06:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODI2ODY2",
          "commit": {
            "abbreviatedOid": "27d6ce1"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-03T16:42:32Z",
          "updatedAt": "2019-11-03T16:42:32Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "3743162190f58b01e22c631dac5d072adeeefcc2",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-lessalt",
      "headRefOid": "2e56380479cbdc40a782a280f1a1ace507a18352",
      "mergeCommit": {
        "oid": "f22274b1a2289c33cd4f1b17488bfeca486ec28b"
      }
    },
    {
      "number": 67,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI4MzU2NTU1",
      "title": "Explain the need for HTTPSSVC due to wildcards",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/67",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #59",
      "createdAt": "2019-10-15T16:19:05Z",
      "updatedAt": "2020-01-14T22:54:30Z",
      "closedAt": "2020-01-14T22:54:29Z",
      "mergedAt": "2020-01-14T22:54:29Z",
      "mergedBy": "enygren",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the explanation.  I've adjusted the text to include it.",
          "createdAt": "2019-11-04T16:07:54Z",
          "updatedAt": "2019-11-04T16:07:54Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODI2Nzkx",
          "commit": {
            "abbreviatedOid": "d67d32c"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Beyond wildcards, another major benefit and driver for HTTPSSVC is that it allows CDNs to start returning HTTPSSVC without requiring their customers to point additional CNAMEs to them.  We may want to add text to this effect as well:\r\n\r\n\"HTTPSSVC also allows the targets of existing CNAME chains to start returning it (such as for CDN integrations), whereas an separate {{?Attrleaf}} name would require an additional integration step.\"",
          "createdAt": "2019-11-03T16:40:34Z",
          "updatedAt": "2019-11-03T16:40:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODkzMzM5",
          "commit": {
            "abbreviatedOid": "0c4d689"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-14T22:53:55Z",
          "updatedAt": "2020-01-14T22:53:55Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "c72d6439f081bcfbeb8f65754896b3be9baaa657",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-wildcard",
      "headRefOid": "0c4d68919e391125398efe76fc563026f035c418",
      "mergeCommit": {
        "oid": "f72e4d2eadeb34c40cab09f5d463f5bfbefcefde"
      }
    },
    {
      "number": 68,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyMTYxNDQ5",
      "title": "Expand on ESNI requirements for the server.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/68",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-10-24T17:34:23Z",
      "updatedAt": "2019-10-25T21:21:53Z",
      "closedAt": "2019-10-25T21:21:52Z",
      "mergedAt": "2019-10-25T21:21:52Z",
      "mergedBy": "bemasc",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2Nzg0Njgw",
          "commit": {
            "abbreviatedOid": "acc13f8"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-24T18:39:21Z",
          "updatedAt": "2019-10-24T18:40:14Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Nit: attacker _who_",
              "createdAt": "2019-10-24T18:39:21Z",
              "updatedAt": "2019-10-24T18:46:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2Nzg4OTE1",
          "commit": {
            "abbreviatedOid": "6ee9bb3"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T18:46:30Z",
          "updatedAt": "2019-10-24T18:46:31Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "\ud83d\udc4d \r\n",
              "createdAt": "2019-10-24T18:46:30Z",
              "updatedAt": "2019-10-24T18:46:31Z"
            }
          ]
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "fd5feaa8e0807322448967768b8fc0e60979a5bd",
      "headRepository": "chris-wood/dns-alt-svc",
      "headRefName": "caw/esni-reqs",
      "headRefOid": "6ee9bb39748ae29be56d3a191be787efd7bfb91d",
      "mergeCommit": {
        "oid": "6b21e04f2e4f73b11f3205f5e97679ec1a28bcca"
      }
    },
    {
      "number": 69,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyNjc0MDY0",
      "title": "Relax the text around when to use ipv[46]hints and when to",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/69",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "switch to the SrvDomainName IPs. There are two normative\r\nchanges here:\r\n\r\n- Relax the MUST look up SrvDomainName to SHOULD\r\n- Relax the SHOULD switch as soon as possible to MAY and\r\n  leave the SHOULD for future connections.\r\n\r\nThis makes HTTPSVC more closely match the previous ESNI behavior, which\r\nis appropriate if we are going to replace it.",
      "createdAt": "2019-10-25T20:43:19Z",
      "updatedAt": "2019-10-25T21:02:42Z",
      "closedAt": "2019-10-25T21:02:42Z",
      "mergedAt": "2019-10-25T21:02:42Z",
      "mergedBy": "bemasc",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NDQ1NzYx",
          "commit": {
            "abbreviatedOid": "5d9e703"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-25T20:49:59Z",
          "updatedAt": "2019-10-25T20:49:59Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NDUwODE5",
          "commit": {
            "abbreviatedOid": "5d9e703"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-25T21:01:28Z",
          "updatedAt": "2019-10-25T21:01:28Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "fd5feaa8e0807322448967768b8fc0e60979a5bd",
      "headRepository": "ekr/dns-alt-svc",
      "headRefName": "relax_hints_text",
      "headRefOid": "5d9e70307e1e31fa8c200f5c5f21fff0dca35a3d",
      "mergeCommit": {
        "oid": "4fc26be1281dfe21bc3d90964a1ab3c4f9a799dd"
      }
    },
    {
      "number": 70,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyNjg0MzU0",
      "title": "Clarify utility of IP hints",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/70",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-10-25T21:17:53Z",
      "updatedAt": "2020-01-14T22:56:56Z",
      "closedAt": "2020-01-14T22:56:56Z",
      "mergedAt": "2020-01-14T22:56:56Z",
      "mergedBy": "enygren",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "That's true, but I think it's probably offset by (1) the likelihood of hints being a suboptimal IP and (2) the increased response size.\r\n\r\nI've adjusted the language to be a bit less absolute.",
          "createdAt": "2019-11-04T16:17:44Z",
          "updatedAt": "2019-11-04T16:17:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODI2NTE0",
          "commit": {
            "abbreviatedOid": "c81e581"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "The benefit might still come if one of the A/AAAA queries or responses was lost, or if the client is doing lookups synchronously.  (I think including this text/recommendation is fine, though?)  Maybe \"limited\" rather than \"no\"?",
          "createdAt": "2019-11-03T16:35:32Z",
          "updatedAt": "2019-11-03T16:35:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODk0NjI3",
          "commit": {
            "abbreviatedOid": "21976bf"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-14T22:56:48Z",
          "updatedAt": "2020-01-14T22:56:48Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "c72d6439f081bcfbeb8f65754896b3be9baaa657",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-hint",
      "headRefOid": "21976bf59fa9fca20f20515304c823900535d44f",
      "mergeCommit": {
        "oid": "9385e296539aea1c860e4e9dd9c0a5d0ec4c8804"
      }
    },
    {
      "number": 71,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMzMTc0Mzkz",
      "title": "ESNIKeys is now ESNIConfig",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/71",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Matches the terminology from https://github.com/tlswg/draft-ietf-tls-esni/pull/187\r\n\r\n@chris-wood FYI",
      "createdAt": "2019-10-28T15:22:58Z",
      "updatedAt": "2019-11-04T15:27:23Z",
      "closedAt": "2019-11-04T15:27:19Z",
      "mergedAt": "2019-11-04T15:27:19Z",
      "mergedBy": "bemasc",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM -- thanks, @bemasc!",
          "createdAt": "2019-10-28T15:24:08Z",
          "updatedAt": "2019-10-28T15:24:08Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "It looks like that PR hasn't landed yet, so this one should probably wait until it's merged.",
          "createdAt": "2019-10-28T15:29:44Z",
          "updatedAt": "2019-10-28T15:29:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bemasc the ESNI draft PR has been merged, so this one should be good to go. One thing we might want to consider is the option for the field to represent a set of configurations, so perhaps we can rename this to \"esniconfigs\" and note that it's the concatenation of one or more ESNIConfig structures?",
          "createdAt": "2019-11-04T14:55:18Z",
          "updatedAt": "2019-11-04T14:55:18Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the reviews.\r\n\r\n> unless we want to just call it \"esni\" ?\r\n\r\nI would be OK with renaming to \"esni\", but I do wonder if it could be confusing, because the contents of this field are not the \"encrypted SNI\".  I would defer to the ESNI authors on preferred terminology.\r\n\r\n> perhaps we can rename this to \"esniconfigs\" and note that it's the concatenation of one or more ESNIConfig structures\r\n\r\nI would be OK with this, but it seems like a nontrivial change so I'm not going to attempt it in this PR.  I would also want to think a bit about what the use case is.  It occurs to me that a client with multiple `ESNIConfig`s could potentially have some kind of fallback behavior (but how does that interact with `esni_retry_request`?) or it could even put multiple `encrypted_server_name` extensions in the ClientHello.",
          "createdAt": "2019-11-04T15:27:13Z",
          "updatedAt": "2019-11-04T15:27:13Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3OTMyODEy",
          "commit": {
            "abbreviatedOid": "3aa992b"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-28T15:24:11Z",
          "updatedAt": "2019-10-28T15:24:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODI2NDEx",
          "commit": {
            "abbreviatedOid": "3aa992b"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks fine to me unless we want to just call it \"esni\" ?",
          "createdAt": "2019-11-03T16:33:18Z",
          "updatedAt": "2019-11-03T16:33:18Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "a5c921ce10bdd3006b28edb73e5e2b11d7021d81",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-esniconfig",
      "headRefOid": "bd3f6d747b56de8bd38a89784cea21715da56baa",
      "mergeCommit": {
        "oid": "759d0c63b6d2bcd110b04b0e8356e035c9ff5204"
      }
    },
    {
      "number": 72,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2MzcyNDY2",
      "title": "Clean up handling of the \"http\" scheme",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/72",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-04T16:39:30Z",
      "updatedAt": "2020-01-15T22:47:41Z",
      "closedAt": "2020-01-15T22:47:41Z",
      "mergedAt": "2020-01-15T22:47:41Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODk2NjE3",
          "commit": {
            "abbreviatedOid": "53dcddb"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Other than the \"what to do with :80\" in a URL this looks fine to merge.",
          "createdAt": "2020-01-14T23:01:23Z",
          "updatedAt": "2020-01-14T23:01:50Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "What if a URL is:\r\nhttp://www.example.com:80/foo.html\r\ndo we drop/ignore the \":80\" ?  I'd assume so and this might be good to call out here explicitly.",
              "createdAt": "2020-01-14T23:01:24Z",
              "updatedAt": "2020-01-15T22:46:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMjg0MjMw",
          "commit": {
            "abbreviatedOid": "53dcddb"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-15T15:04:15Z",
          "updatedAt": "2020-01-15T15:04:16Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "The `{{hsts}}` link points to the section on \"HTTP Strict Transport Security\", which says \"If the \"http\" URL explicitly specifies port 80, specify port 443.\".  Do you think we need to repeat that instruction here?",
              "createdAt": "2020-01-15T15:04:15Z",
              "updatedAt": "2020-01-15T22:46:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTIxOTE4",
          "commit": {
            "abbreviatedOid": "53dcddb"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-15T21:08:11Z",
          "updatedAt": "2020-01-15T21:08:11Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Seems safer to include?  (perhaps copy the text and reference back.)",
              "createdAt": "2020-01-15T21:08:11Z",
              "updatedAt": "2020-01-15T22:46:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTYyOTU0",
          "commit": {
            "abbreviatedOid": "be58871"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-15T22:22:57Z",
          "updatedAt": "2020-01-15T22:22:58Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I'd like to avoid repeating the URL conversion algorithm, but I've rephrased this to avoid implying that the conversion is a simple replacement of the scheme.",
              "createdAt": "2020-01-15T22:22:57Z",
              "updatedAt": "2020-01-15T22:46:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTcxNjg1",
          "commit": {
            "abbreviatedOid": "be58871"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-15T22:41:31Z",
          "updatedAt": "2020-01-15T22:41:31Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTc0MjU3",
          "commit": {
            "abbreviatedOid": "5d2fc03"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Resolved conflicts and merged.",
          "createdAt": "2020-01-15T22:47:29Z",
          "updatedAt": "2020-01-15T22:47:29Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "c67737b96ac84347845f36c07ada1a1f6101bc00",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-hsts",
      "headRefOid": "5d2fc032974e1fb4f1f4ddcf24ecbd1f39cc26ef",
      "mergeCommit": {
        "oid": "cf37c85890f1d46ffebff7da6556d5d4028b040b"
      }
    },
    {
      "number": 76,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQwNjA2OTcx",
      "title": "Remove recommendation to shorten the TTL",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/76",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Shortening the TTL doesn't actually solve the problem,\r\nbecause some caches ignore small TTL values.  Regardless of TTL,\r\nservers have to be able to deal with occasional use of expired\r\nrecords.  Shortening TTL is also bad for efficiency, so we\r\nshouldn't encourage it.\r\n\r\nFixes #74",
      "createdAt": "2019-11-13T18:34:08Z",
      "updatedAt": "2020-01-15T22:51:41Z",
      "closedAt": "2020-01-15T22:51:41Z",
      "mergedAt": "2020-01-15T22:51:41Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyMDMxNzEx",
          "commit": {
            "abbreviatedOid": "777eaab"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-13T18:11:27Z",
          "updatedAt": "2019-12-13T18:11:28Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "\"MUST NOT\" seems wrong here.  Maybe this can be non-normative operational guidance or SHOULD NOT.",
              "createdAt": "2019-12-13T18:11:28Z",
              "updatedAt": "2020-01-15T22:43:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODk4ODcw",
          "commit": {
            "abbreviatedOid": "777eaab"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Change \"MUST NOT\" to something softer and then this looks good to merge.",
          "createdAt": "2020-01-14T23:06:56Z",
          "updatedAt": "2020-01-14T23:07:21Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Agreed, especially as ESNI key rotations need to assume that clients will at least eventually re-resolve and not extend the lifetime indefinitely.  Perhaps \"[...], so server operators should assume that clients will continue to use records for some amount of time past their expiration.\"   ?",
              "createdAt": "2020-01-14T23:06:56Z",
              "updatedAt": "2020-01-15T22:43:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMjk0MTcw",
          "commit": {
            "abbreviatedOid": "d7d9c81"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-15T15:17:06Z",
          "updatedAt": "2020-01-15T15:17:07Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I've adjusted the advice here.  PTAL.",
              "createdAt": "2020-01-15T15:17:07Z",
              "updatedAt": "2020-01-15T22:43:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTIzMzQ3",
          "commit": {
            "abbreviatedOid": "d7d9c81"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-01-15T21:10:51Z",
          "updatedAt": "2020-01-15T21:10:56Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Do we want to call out ESNI keys as well?\r\n\r\n\"Instead, server operators SHOULD continue operating the endpoints listed in expired records until they\r\nobserve that nearly all existing and new connections have migrated to the new endpoints (and are using new ESNI keys if applicable).\"",
              "createdAt": "2020-01-15T21:10:51Z",
              "updatedAt": "2020-01-15T22:43:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTcyNzUw",
          "commit": {
            "abbreviatedOid": "45567cc"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-15T22:43:58Z",
          "updatedAt": "2020-01-15T22:43:58Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I tried to capture this by changing the text to describe \"configurations\" instead of \"endpoints\".",
              "createdAt": "2020-01-15T22:43:58Z",
              "updatedAt": "2020-01-15T22:43:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTc2MTIz",
          "commit": {
            "abbreviatedOid": "45567cc"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-15T22:51:32Z",
          "updatedAt": "2020-01-15T22:51:32Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "973820db37d4577750bb23506eb23615bb6de5f7",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-ttl",
      "headRefOid": "45567cc2ee2af889e23482190d6e38445e04d0e6",
      "mergeCommit": {
        "oid": "30d65cb6e04e2dedbb0d368b87db575c3ee01119"
      }
    },
    {
      "number": 77,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQwNjI4ODk4",
      "title": "Clarify various recommendations",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/77",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #75 and addresses comments in #40\r\n\r\n@puneetsood FYI",
      "createdAt": "2019-11-13T19:32:01Z",
      "updatedAt": "2020-01-15T22:50:13Z",
      "closedAt": "2020-01-15T22:50:13Z",
      "mergedAt": "2020-01-15T22:50:12Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE2NTM4MDI5",
          "commit": {
            "abbreviatedOid": "aa7d5d1"
          },
          "author": "puneetsood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-13T20:35:40Z",
          "updatedAt": "2019-11-13T20:35:41Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "RRSIG, NSEC and NSEC3\r\n",
              "createdAt": "2019-11-13T20:35:41Z",
              "updatedAt": "2020-01-15T22:38:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE2NTQzNzYx",
          "commit": {
            "abbreviatedOid": "ac4ac48"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-13T20:45:52Z",
          "updatedAt": "2019-11-13T20:45:53Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Done",
              "createdAt": "2019-11-13T20:45:52Z",
              "updatedAt": "2020-01-15T22:38:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyOTAyNTQ5",
          "commit": {
            "abbreviatedOid": "ac4ac48"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks fine other than the two review comments.",
          "createdAt": "2020-01-14T23:16:34Z",
          "updatedAt": "2020-01-14T23:18:23Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Is the negative behavior actually possible?    (Is it possible to add an empty record additionals?  I'm forgetting whether this is valid, but I can't recall seeing it done?  It may be that neither is possible?)    Also, is there a distinction to be made here between NODATA/NOERROR (the RRType doesn't exist) and NXDOMAIN?  Certainly, I don't believe the latter can be added to the Additional section? ",
              "createdAt": "2020-01-14T23:16:34Z",
              "updatedAt": "2020-01-15T22:38:57Z"
            },
            {
              "originalPosition": 60,
              "body": "\"iterative\" or \"recursive\" ?  I typically see the latter used.",
              "createdAt": "2020-01-14T23:17:06Z",
              "updatedAt": "2020-01-15T22:38:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMzY3NjI3",
          "commit": {
            "abbreviatedOid": "ac4ac48"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-15T16:50:57Z",
          "updatedAt": "2020-01-15T16:53:58Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "I think you're right.  Changed to \"recursive\".",
              "createdAt": "2020-01-15T16:50:58Z",
              "updatedAt": "2020-01-15T22:38:57Z"
            },
            {
              "originalPosition": 67,
              "body": "> Is the negative behavior actually possible?\r\n\r\nI think it might be possible, but it's definitely not straightforward.  It would require the client to recapitulate the recursive resolution procedure, notice the absence of certain RRSets, and check for a corresponding SOA instead.  It's more obviously possible (but even more complicated) for signed zones.\r\n\r\nAnyway, I've significantly reworked this section to try to pin down the precise behavior of which records go where, what RCODE to return, etc.",
              "createdAt": "2020-01-15T16:53:22Z",
              "updatedAt": "2020-01-15T22:38:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTI5MzY0",
          "commit": {
            "abbreviatedOid": "70681f0"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-01-15T21:21:32Z",
          "updatedAt": "2020-01-15T21:21:49Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Perhaps add:\r\n\r\n\"Recursive resolvers MAY respond to the SVCB Answer with \r\nonly a subset of Additional RRs when the response would\r\nbe larger than is permitted or when responding before fully chasing \r\ndependencies would improve performance.  Additional information from\r\nhigher priority ServiceForm records SHOULD be prioritized over lower priority\r\nServiceForm records.\"",
              "createdAt": "2020-01-15T21:21:33Z",
              "updatedAt": "2020-01-15T22:38:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTcwODU4",
          "commit": {
            "abbreviatedOid": "d2b6c49"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-15T22:39:39Z",
          "updatedAt": "2020-01-15T22:39:39Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "OK.  I added this to the Performance Optimizations section.",
              "createdAt": "2020-01-15T22:39:39Z",
              "updatedAt": "2020-01-15T22:39:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTc1MzI2",
          "commit": {
            "abbreviatedOid": "d2b6c49"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-15T22:49:45Z",
          "updatedAt": "2020-01-15T22:49:45Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "973820db37d4577750bb23506eb23615bb6de5f7",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-clarity",
      "headRefOid": "d2b6c49297f6f28704f8357b357d799214926b1a",
      "mergeCommit": {
        "oid": "35ab6b46bd05ffcf354eaebbcc6b24a838de00dd"
      }
    },
    {
      "number": 78,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQwNjc4NDYw",
      "title": "Restore and clarify ALPN requirements",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/78",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #40",
      "createdAt": "2019-11-13T21:33:41Z",
      "updatedAt": "2019-11-14T18:17:02Z",
      "closedAt": "2019-11-14T18:16:59Z",
      "mergedAt": "2019-11-14T18:16:59Z",
      "mergedBy": "bemasc",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE2NjgwMjEz",
          "commit": {
            "abbreviatedOid": "069110e"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-14T02:29:57Z",
          "updatedAt": "2019-11-14T02:29:57Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "973820db37d4577750bb23506eb23615bb6de5f7",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-alpn",
      "headRefOid": "069110e07592011dc09aee7a1a7ab2e98a33244a",
      "mergeCommit": {
        "oid": "9c133e81c8932d4017a9cff040577c09273186c7"
      }
    },
    {
      "number": 85,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ1NDY4NTE4",
      "title": "Clarify examples",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/85",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #83, #84",
      "createdAt": "2019-11-25T23:31:09Z",
      "updatedAt": "2020-01-15T21:25:21Z",
      "closedAt": "2020-01-15T21:25:20Z",
      "mergedAt": "2020-01-15T21:25:20Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyOTA2NzA4",
          "commit": {
            "abbreviatedOid": "9a6507a"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good other than comments.",
          "createdAt": "2020-01-14T23:28:00Z",
          "updatedAt": "2020-01-14T23:40:36Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "replace \"new\" with \"added\" or \"additional\".  (\"new\" might imply that they replace the A and AAAA records.",
              "createdAt": "2020-01-14T23:28:00Z",
              "updatedAt": "2020-01-15T17:05:08Z"
            },
            {
              "originalPosition": 96,
              "body": "Perhaps explicitly call out that pool.svc.example. may be either the target of a CNAME chain or an alias?\r\nFor example:\r\n\r\n$ORIGIN example.com.\r\nwww    3600 IN CNAME pool.svc.example.\r\n .          3600 IN HTTPSSVC 0 pool.svc.example.\r\n",
              "createdAt": "2020-01-14T23:33:48Z",
              "updatedAt": "2020-01-15T17:05:08Z"
            },
            {
              "originalPosition": 96,
              "body": "It would also be good to clarify that neither form impacts the domain name in the origin.\r\nFor example:\r\n------\r\n\r\nSimilar to CNAME, HTTPSSVC aliases have no impact on the origin name.  When connecting, clients will continue to treat the authoritative origins as \"https://www.example.com\" and \"https://example.com\", respectively, and will validate TLS server certificates accordingly.",
              "createdAt": "2020-01-14T23:39:38Z",
              "updatedAt": "2020-01-15T17:05:08Z"
            },
            {
              "originalPosition": 89,
              "body": "Might be less confusing if we called it \"h3pool\" ?",
              "createdAt": "2020-01-14T23:40:23Z",
              "updatedAt": "2020-01-15T17:05:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMzc3OTAx",
          "commit": {
            "abbreviatedOid": "9a6507a"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-15T17:05:25Z",
          "updatedAt": "2020-01-15T17:06:19Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Done",
              "createdAt": "2020-01-15T17:05:25Z",
              "updatedAt": "2020-01-15T17:06:20Z"
            },
            {
              "originalPosition": 89,
              "body": "Done",
              "createdAt": "2020-01-15T17:05:31Z",
              "updatedAt": "2020-01-15T17:06:20Z"
            },
            {
              "originalPosition": 96,
              "body": "> Perhaps explicitly call out that pool.svc.example. may be either the target of a CNAME chain or an alias?\r\n\r\nThis is already in the preceding example.\r\n\r\n> It would also be good to clarify that neither form impacts the domain name in the origin.\r\n\r\nAdded.",
              "createdAt": "2020-01-15T17:06:12Z",
              "updatedAt": "2020-01-15T17:06:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTMxNDQ5",
          "commit": {
            "abbreviatedOid": "7df0771"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-15T21:25:11Z",
          "updatedAt": "2020-01-15T21:25:11Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "9c133e81c8932d4017a9cff040577c09273186c7",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-examples",
      "headRefOid": "7df0771f219813df4f7ca13b96f1bee19eff37ea",
      "mergeCommit": {
        "oid": "c67737b96ac84347845f36c07ada1a1f6101bc00"
      }
    },
    {
      "number": 89,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUwMjIyOTIw",
      "title": "Replace \"alpn\" with \"proto\"/\"no-proto\"",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/89",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change\r\n1. Makes it difficult for admins to accidentally drop support for HTTP/1.1 and HTTP/2\r\n2. Makes it easy for clients to determine the precise set of a protocols supported by an endpoint before attempting a connection.\r\n\r\nFixes #73",
      "createdAt": "2019-12-06T22:23:33Z",
      "updatedAt": "2020-01-24T16:16:45Z",
      "closedAt": "2020-01-24T16:16:45Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@enygren @MikeBishop I've updated this PR to reflect our conversation today.  PTAL.",
          "createdAt": "2019-12-13T21:13:28Z",
          "updatedAt": "2019-12-13T21:13:28Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Documenting here that I think we're leaning in the direction of transport/no-default-transport and will reject this alternate PR? ",
          "createdAt": "2020-01-24T14:41:06Z",
          "updatedAt": "2020-01-24T14:41:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI4NDkzMDkz",
          "commit": {
            "abbreviatedOid": "0f2b836"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-12-06T22:31:17Z",
          "updatedAt": "2019-12-06T22:31:25Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "What about DoH that mandates H2 support?  It also is entirely reasonable for service endpoints to support QUIC and not H2 or HTTP/1.1.  There are features of QUIC that make it attractive to have it on separate IPs that are QUIC-only.\r\n\r\nSpecial-casing http/1.1 seems reasonable, but I'm not sure this is the easiest way.  \r\nPerhaps:\r\nA service endpoint supporting \"h2\" SHOULD also support \"http/1.1\" unless either no service endpoints support \"http/1.1\" or a distinct service endpoint is specified for \"http/1.1\"\r\n\r\n?",
              "createdAt": "2019-12-06T22:31:17Z",
              "updatedAt": "2019-12-13T21:07:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI4NTA4NjAw",
          "commit": {
            "abbreviatedOid": "0f2b836"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-06T23:25:22Z",
          "updatedAt": "2019-12-06T23:25:23Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "> What about DoH that mandates H2 support?\r\n\r\nDoH doesn't recommend refusing connections over HTTP/1.1, so I don't think there's a conflict.\r\n\r\n> There are features of QUIC that make it attractive to have it on separate IPs that are QUIC-only.\r\n\r\nI'd be really interested to know more about this use case.  I've been hearing concerns from browser people that support for QUIC-only endpoints may be difficult to implement, because it complicates TCP fallback when UDP is failing.  I'm hoping that we can find a middle ground that addresses both needs.  (Feel free to switch to email if it's too long for this comment thread.)",
              "createdAt": "2019-12-06T23:25:22Z",
              "updatedAt": "2019-12-13T21:07:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM0NzUwMzA1",
          "commit": {
            "abbreviatedOid": "c4eebef"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "This looks good, with some small consistency nitpicks.",
          "createdAt": "2019-12-19T16:25:22Z",
          "updatedAt": "2019-12-19T16:30:13Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "This could go either way, but since there are existing implementations with supported protocols at codepoint 1, wouldn't it make sense to put `no-proto` at 0 instead?",
              "createdAt": "2019-12-19T16:25:22Z",
              "updatedAt": "2019-12-19T16:30:13Z"
            },
            {
              "originalPosition": 179,
              "body": "Slight nitpick -- TCP 8003 is not the same point as UDP 8003, so \"both ports\" might not be applicable.  This RRSET makes assertions about *three* ports.",
              "createdAt": "2019-12-19T16:27:12Z",
              "updatedAt": "2019-12-19T16:30:13Z"
            },
            {
              "originalPosition": 205,
              "body": "Also:\r\n\r\n- h2=\"svc3.example.net:8003\"; esniconfig=\"ABC...\"; ma=7200,\r\n- http/1.1=\"svc3.example.net:8003\"; esniconfig=\"ABC...\"; ma=7200,\r\n- http/1.1=\"svc.example.net:8002\"; esniconfig=\"123...\"; ma=7200",
              "createdAt": "2019-12-19T16:29:20Z",
              "updatedAt": "2019-12-19T16:30:13Z"
            }
          ]
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "9c133e81c8932d4017a9cff040577c09273186c7",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-alpn",
      "headRefOid": "c4eebef4f76ee1ac45e7a518e4e402bc46804c51",
      "mergeCommit": null
    },
    {
      "number": 93,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUzNzA3Nzky",
      "title": "Make HTTPSSVC imply fatal certificate errors",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/93",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "MikeBishop",
        "enygren"
      ],
      "labels": [],
      "body": "This is the other half of HSTS. Closes #87.",
      "createdAt": "2019-12-16T18:48:14Z",
      "updatedAt": "2019-12-19T16:50:21Z",
      "closedAt": "2019-12-19T16:50:21Z",
      "mergedAt": "2019-12-19T16:50:21Z",
      "mergedBy": "bemasc",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "HSTS uses MUST instead of SHOULD, but I've left it as SHOULD to align with the rest of HTTPSSVC.",
          "createdAt": "2019-12-16T18:48:41Z",
          "updatedAt": "2019-12-16T18:48:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyODU4MTAy",
          "commit": {
            "abbreviatedOid": "26e93ec"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Works for me.",
          "createdAt": "2019-12-16T20:53:08Z",
          "updatedAt": "2019-12-16T20:53:52Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Nit: \"the client\"",
              "createdAt": "2019-12-16T20:53:08Z",
              "updatedAt": "2019-12-17T03:53:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzMDEzNDc4",
          "commit": {
            "abbreviatedOid": "7f911ef"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-17T03:53:35Z",
          "updatedAt": "2019-12-17T03:53:36Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Fixed.",
              "createdAt": "2019-12-17T03:53:35Z",
              "updatedAt": "2019-12-17T03:53:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM0NzU0NjYw",
          "commit": {
            "abbreviatedOid": "7f911ef"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-19T16:31:38Z",
          "updatedAt": "2019-12-19T16:31:38Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "9c133e81c8932d4017a9cff040577c09273186c7",
      "headRepository": "davidben/dns-alt-svc",
      "headRefName": "hsts-part-two",
      "headRefOid": "7f911ef86f87fea50dd358f52339c2e9791a867e",
      "mergeCommit": {
        "oid": "127af38059c6eaa213c7b43edd86ad11108ec6cf"
      }
    },
    {
      "number": 94,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU0MjE3NjU3",
      "title": "Do not allow duplicate ipv4hint and ipv6hint parameters",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/94",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The contents already encode multiple addresses. We shouldn't have multiple ways to say the same thing.",
      "createdAt": "2019-12-17T17:10:45Z",
      "updatedAt": "2020-03-05T16:03:16Z",
      "closedAt": "2020-03-05T16:03:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@dmcardle FYI",
          "createdAt": "2019-12-18T21:19:29Z",
          "updatedAt": "2019-12-18T21:19:29Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@enygren I believe you added this language in https://github.com/MikeBishop/dns-alt-svc/commit/9e1726cd142d32dde32d18d5c86db16f2e60d61a.  Do you think it's still needed?",
          "createdAt": "2019-12-19T20:42:00Z",
          "updatedAt": "2019-12-19T20:42:00Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "I think if we address issue #95 and just recommend using a multi-value parameter (and have very clear specification that duplicate parameters must ignored in a deterministic manner) that this text isn't needed as-is.",
          "createdAt": "2019-12-19T20:53:18Z",
          "updatedAt": "2019-12-19T20:53:18Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Should we replace this with text elsewhere prohibiting the same parameter key from being used multiple times and specifying that one (first? last?) should be deterministically selected?",
          "createdAt": "2020-01-15T21:28:42Z",
          "updatedAt": "2020-01-15T21:28:42Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "(so pend this on #95 and close/wontfix if we merge that, or approve if we reject #95)",
          "createdAt": "2020-01-15T21:29:35Z",
          "updatedAt": "2020-01-15T21:29:35Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "This has been merged in #109.",
          "createdAt": "2020-03-05T16:03:16Z",
          "updatedAt": "2020-03-05T16:03:16Z"
        }
      ],
      "reviews": [],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "9c133e81c8932d4017a9cff040577c09273186c7",
      "headRepository": "davidben/dns-alt-svc",
      "headRefName": "duplicate-ip-hints",
      "headRefOid": "1c169dda92b382133f5c3b370f5f3b1c9ebc8aea",
      "mergeCommit": null
    },
    {
      "number": 97,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU1MzM2Mjg3",
      "title": "Replace \"alpn\" with \"transport\"/\"no-default-transport\"",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/97",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is an alternative to #89, based on our discussion in #73.\r\n\r\nThis is the \"maximalist\" approach, including a new IANA registry and a (backwards-compatible) update to RFC 7838.\r\n\r\nCurrent text is definitely a rough cut.  We can clean up the requirements language if we agree this is the right direction.",
      "createdAt": "2019-12-19T20:23:31Z",
      "updatedAt": "2020-02-15T06:27:39Z",
      "closedAt": "2020-02-14T21:28:50Z",
      "mergedAt": "2020-02-14T21:28:50Z",
      "mergedBy": "bemasc",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "NONE",
          "body": "In general I do like how this disconnects from Alt-Svc to address the problems mentioned by @davidben. However, I have two questions.\r\n\r\n1) I'm not sure what the purpose of `no-transport` is. Having a definition of default transports for a scheme sounds like something that will become very rapidly obsolete. Why not simply just use `transport`?\r\n\r\n2) How do we think this will interact with HTTP/3 or QUIC versions? In the TLS use-case, specifying `tls` is sufficient because TLS has an in-band version negotiation mechanism that does not cost round-trips, and ALPN also doesn't cost round trips. For QUIC, it's not quite certain we'll have that, so it might help to indicate the QUIC version? All that said, if we tighten this spec to have `quic` mean only QUICv1, then we can figure that out later.",
          "createdAt": "2019-12-19T22:25:45Z",
          "updatedAt": "2019-12-19T22:25:45Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "NONE",
          "body": "One thing to point out is that this causes the \"port\" parameter to have a dual meaning.   Suppose we build an HTTPSSVC record with `transport=quic transport=tls port=123` \u2014 the \"port\" parameter now applies to both UDP  and TCP!",
          "createdAt": "2019-12-19T22:30:13Z",
          "updatedAt": "2019-12-19T22:30:13Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "> Having a definition of default transports for a scheme sounds like something that will become very rapidly obsolete.\r\n\r\nIt quite possibly will.  The concern that prompted this set of designs was that someone might publish a record indicating H3 support and providing ESNI keys, and thereby restrict those keys to the H3 endpoint.  It then makes it possible to disable ESNI over TLS/TCP by blocking the QUIC connection.\r\n\r\nBy requiring the record to explicitly disclaim H1/H2 support if it intends not to offer them on a given record, this accidental misconfiguration and associated attack become harder.\r\n\r\nSpecifically, I think that a list of transports is likely to have more staying power than particular versions.  Even if, however unlikely this seems, H1 becomes obsolete in the near future, I suspect HTTP over TLS will still exist in some negotiable shape.",
          "createdAt": "2019-12-27T15:44:54Z",
          "updatedAt": "2019-12-27T15:44:54Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think `no-transport` addresses those concerns. They still apply, with or without this set manipulation complexity. It merely adds additional complexity concerns. Clients, in particular, parse untrusted input, so needless complexity in formats must be dropped.\r\n\r\nAt the end of the day, if it is possible to express an ESNI key for the QUIC path without an ESNI key for the TCP path, the client needs to do *something* in response to it. The draft currently says the interpretation is that you disable the TCP path, which is unacceptable (see https://github.com/MikeBishop/dns-alt-svc/issues/73#issuecomment-565681979). The alternative non-rejecting interpretation is to silently lose ESNI, which is also unacceptable.\r\n\r\nThus it *must* be considered a misconfiguration. Well-designed mechanisms make misconfigurations impossible to spell. Example: advertising QUIC is purely additive, without a `no-transport` option, like the original `Alternate-Protocol` header. `Alt-Svc`-like designs regress this.\r\n\r\nAlas, the reason for this regression was to support using different IPs for QUIC. We could do a two-level thing, with ESNI being specified at the top level, but this is perhaps a little goofy:\r\n```\r\ntcp.example.com; ipv4hint=1.2.3.4; port=443; esniconfigs=...; alt-transports={\r\n  quic={quic.example.com; ipv4hint=5.6.7.8; port=444},\r\n  fancyprotocol={fancyprotocol.example.com; ipv4hint=9.10.11.12; port=445},\r\n}\r\n```\r\n\r\nFailing that, we are left with a misconfiguration that is otherwise syntactically valid. This is unstable under ecosystem effects and, as noted, receivers still must do *something*. To counter this, the spec *must* define requirements to reject as loudly as feasible so administrators fix it. Here is a concrete possibility:\r\n* There is a single \"default\" transport: whatever you would have done with A/AAAA records. It is specified by omitting the `transport` parameter and doesn't need a name.\r\n* Remove the odd filtering and empty string rules around `esniconfig`. Optionally filtering an HTTPSSVC set complicates the rule below. If you want ESNI, you need to specify it on each HTTPSSVC arm. (A network attacker can always redirect you to the other machines, so having ESNI-capable and ESNI-incapable IPs that both speak for the public name is an inherently insecure configuration.)\r\n* In a set of HTTPSSVC records, there must be one entry for the default transport. If there isn't, this is a misconfiguration:\r\n  * Authoritative DNS servers reject this at config-time and do not advertise it at all.\r\n  * Config file formats SHOULD make it hard to express the misconfiguration. Maybe add a `no-default-transport` token and compile it out? This is a local decision, so pick something.\r\n  * If the authoritative DNS server is non-compliant, clients silently drop the record and fall back to A/AAAA. (Failing the HTTP request would be ideal but probably too much due to DNS caching.)",
          "createdAt": "2019-12-27T16:33:13Z",
          "updatedAt": "2019-12-27T16:42:58Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "> Thus it _must_ be considered a misconfiguration. Well-designed mechanisms make misconfigurations impossible to spell.\r\n\r\nAnd here, I think, is the distinction.  This isn't *necessarily* a misconfiguration, but it's potentially a misconfiguration.  The goal isn't to make H3-only impossible to say, it's to make it difficult to say accidentally.\r\n\r\nStill, I think it's probably a fair assertion that HTTP services are practically guaranteed to include a TCP endpoint for the foreseeable future, and making that sound alarm bells if violated is a goal we can all agree on.  Perhaps requiring you to have a TCP entry, even if that entry then says `null` as the destination, is a good compromise?",
          "createdAt": "2019-12-30T14:55:07Z",
          "updatedAt": "2019-12-30T14:55:07Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You quoted the conclusion without the rationale which led to it. The need for that to be a misconfiguration follows from the other two possible interpretations (drop TCP fallback or silently leak SNI) not working. A TCP entry with null destination would not work for browser scenarios, where site failures [impact users](https://www.w3.org/TR/html-design-principles/#priority-of-constituencies). I would push for Chrome to either ignore the spec and treat it as a misconfiguration regardless, or punt HTTPSSVC in favor of a more suitable record type.\r\n\r\nNote that, without ESNI, HTTPSSVC already doesn't allow an h3-only configuration anyway. A/AAAA path is always an implicit route. It only accidentally happens for ESNI-capable clients as a quirk of HTTPSSVC's ESNI filtering bits.",
          "createdAt": "2019-12-30T15:12:54Z",
          "updatedAt": "2019-12-30T15:15:32Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the comments.  I've uploaded a new version that tries to find a compromise between @MikeBishop and @davidben's suggestions.  I think the key line is:\r\n\r\n> clients MAY reject the entire SVCB RRSet and fall back to basic connection establishment if all of the RRs indicate \"no-default-transport\"\r\n\r\nThis is similar to some of @davidben's suggestions.\r\n\r\nWhile this doesn't make such RRSets non-compliant, it does clarify that clients are permitted to enforce such a requirement.  Assuming some popular clients adopt this behavior, such RRSets will be difficult to create accidentally, low-impact for end-users if admins do create them, and reasonably obvious to admins when testing or observing stats.\r\n\r\nI haven't made any changes to the \"esniconfig\" logic, because I believe it is a separable question, and probably best addressed in a different PR.\r\n\r\nPTAL!",
          "createdAt": "2020-01-03T22:09:26Z",
          "updatedAt": "2020-01-03T22:09:26Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "NONE",
          "body": "> One thing to point out is that this causes the \"port\" parameter to have a dual meaning. Suppose we build an HTTPSSVC record with `transport=quic transport=tls port=123` \u2014 the \"port\" parameter now applies to both UDP and TCP!\r\n\r\nAny thoughts on this problem?\r\n\r\nQuoting the introductory example from the latest patch:\r\n\r\n```\r\n    svc.example.net.  7200  IN HTTPSSVC 2 svc3.example.net. (\r\n        additional-transport=quic port=8003 esniconfig=\"...\" )\r\n    svc.example.net.  7200  IN HTTPSSVC 3 svc2.example.net. (\r\n                                        port=8002 esniconfig=\"...\" )\r\n```\r\nDoesn't the first HTTPSSVC record imply \"quic\" and \"tls\" are both available over port 8003 on svc3.example.net?  How would you express a different port for QUIC?",
          "createdAt": "2020-01-15T19:30:22Z",
          "updatedAt": "2020-01-15T19:30:22Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> > One thing to point out is that this causes the \"port\" parameter to have a dual meaning. Suppose we build an HTTPSSVC record with `transport=quic transport=tls port=123` \u2014 the \"port\" parameter now applies to both UDP and TCP!\r\n> \r\n> Any thoughts on this problem?\r\n\r\nI updated the text to allude to this (line 162).\r\n\r\n> Doesn't the first HTTPSSVC record imply \"quic\" and \"tls\" are both available over port 8003 on svc3.example.net?\r\n\r\nYes.  Sharing a port like this is a fairly common configuration (e.g. Google runs HTTPS over TLS and QUIC, both on port 443 on the same IPs).\r\n\r\n> How would you express a different port for QUIC?\r\n\r\nI would add `no-default-transport` to the QUIC RR, indicating that TLS is not supported.",
          "createdAt": "2020-01-15T19:38:24Z",
          "updatedAt": "2020-01-15T19:38:24Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "I am liking the direction of this, but this is a broad-reaching enough change that we should expand this proposal/discussion to include a larger audience when we're ready. A bunch of comments and questions:\r\n\r\n    Can we name this something easier to write?\r\n    The usability of \"additional-transport\" seems poor.\r\n    Also, it is bikeshedding, but having a good name that\r\n    these tokens and their registry can be referred\r\n    to with and distinguished from ALPN seems critical.\r\n    (So far \"TP\" is the best I've come up with as writing\r\n    tp=tls is more readable.)\r\n\r\n    I'm not sure all encodings / data types have\r\n    an empty value as meaningful.\r\n\r\n    We should talk about the relationship of {additional-transport /\r\n    transport protocol} to ALPN. If we are going to go this path, this\r\n    seems like a broader conversation to have that we should loop people\r\n    like Martin Thompson and Tommy Pauly into as well. (There may be a\r\n    question as to whether there is value to also supporting ALPN, but\r\n    that may be unneeded complexity.) How this relates to Alt-Svc is\r\n    something that should likely have discussion in the HTTP and QUIC\r\n    (and perhaps TAPS?) working groups as well once there is a concrete\r\n    proposal. A question may be whether this should get factored into\r\n    its own document as this is a significant enough change to Alt-Svc.\r\n\r\n    One way to frame the difference may be that:\r\n        $TP (whatever we call it) defines a transport layer\r\n        or transport+security layer protocol (eg, TCP+TLS, UDP+QUIC).\r\n        Each of these provide a way to communicate over the network\r\n        in a way that a secure connection can be negotiated and\r\n        initiated.\r\n        ALPN is an aggreement as part of the $TP negotiation\r\n        to agree on the upper application-layer protocol\r\n        (eg, HTTP-over-HTTP/1.1 vs HTTP-over-HTTP/2).\r\n\r\n    Closely related to this is the relation of the \"transport protocol\r\n    set\" with ALPN values. (ie, are there cases where the client\r\n    needs to be aware which ALPN protocols within the transport\r\n    protocol an endpoint supports prior to connecting?)\r\n\r\n    Does it make sense that the transport registry is HTTPS-specific\r\n    or should a single registry be shared across HTTPS\r\n    and other protocols? I'd be inclined towards a single registry,\r\n    especially given the uniqueness properites with ALPN.\r\n    Having a bunch of registries all sharing a key space\r\n    sounds like a disaster.\r\n\r\n    There are legitimate use-cases for no-default-transport\r\n    outside ot web browsers. It would be entirely reasonable\r\n    for web services in a closed ecosystem to only support HTTP/3.\r\n\r\n    Do we need to update something to indicate that\r\n    the ALPN registry also doesn't collide with this?\r\n    Does IANA have a precedent for this? Would merging\r\n    these into a single registry with a new column (for if\r\n    it is a $TP or an ALPN) be easier?\r\n\r\n    We may want to be clear in our initial registry entries\r\n    that these are \"TLS over TCP\" and \"QUIC over UDP\" ?\r\n\r\n    We should provide guidance for how servers make\r\n    a transition for Alt-Svc from alpn to these additional-transports.\r\n    (ie, recommend that they include both, and we should probably\r\n    show this in our example.)\r\n\r\n    For \"tls\", what ALPN protocols does a server need to support?\r\n    Could a server be HTTP/2 only or HTTP/1.1 only? I guess\r\n    this will get figured out during the TLS handshake negotiation?\r\n    (How this relates to Alt-Svc is also important.)\r\n",
          "createdAt": "2020-01-15T21:05:07Z",
          "updatedAt": "2020-01-15T21:05:07Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "ALPN and Transport Protocol are different layers.  TLS and QUIC share a common property:  They are able to agree on an application protocol as part of their handshake.  Thus, our need for $TP is merely to point at the correct transport, and let its internal negotiation mechanisms handle the rest.  The open question is what happens if we\u2019re pointing to a transport that does not have an internal protocol negotiation mechanism, but could nonetheless have several protocols (or incompatible protocol versions) on it.  I would suggest that\u2019s no different from the world in TCP today, and the protocol has to do version agreement internal to itself.\r\n \r\nHowever, there may also be cases like the QUIC version where having a hint in advance which version to pick would potentially speed up the process.  Those cases can just define a new parameter, I suppose.\r\n \r\nAs to whether it makes sense to require a particular ALPN value, I\u2019d argue that it doesn\u2019t.  ALPN is capable of restricting itself on either side \u2013 the client won\u2019t offer anything it\u2019s not willing to use, and the server won\u2019t choose anything it\u2019s not happy with.  The only value in knowing the \u201cexpected\u201d outcome in advance is to then fail the connection if you don\u2019t like what the server selected, even though you offered it as a valid choice.  (Or, potentially, for use with 0-RTT; but then you know in advance from the previous session without need of a SVCB record.)\r\n",
          "createdAt": "2020-01-16T19:03:39Z",
          "updatedAt": "2020-01-16T19:03:39Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "(Skipping questions addressed by Mike's comment and reordering a few things...)\r\n\r\n> Can we name this something easier to write?\r\n> The usability of \"additional-transport\" seems poor.\r\n\r\nOK, I changed it to \"transport\".  I think that's short enough, and a lot more human-readable than \"tp\".\r\n\r\n> Do we need to update something to indicate that\r\n> the ALPN registry also doesn't collide with this?\r\n\r\nI decided to try to solve this by taking a different approach.  In the latest commit, this draft now defines a new fake ALPN (\"any\") to indicate that ALPN should be negotiated.  This makes the HTTPS-Transport and ALPN registries completely independent (not sharing a keyspace, no need for conflict avoidance).\r\n\r\n> If we are going to go this path, this seems like a broader conversation to have...\r\n\r\nWhatever we do, it'll definitely become a bigger conversation, but I'd like to rev the draft to include our best consensus idea before soliciting input from other WGs.\r\n\r\n> Does it make sense that the transport registry is HTTPS-specific\r\n> or should a single registry be shared across HTTPS\r\n> and other protocols? I'd be inclined towards a single registry,\r\n> especially given the uniqueness properites with ALPN.\r\n> Having a bunch of registries all sharing a key space\r\n> sounds like a disaster.\r\n\r\nOK, I've changed the design to avoid that disaster.  I do think it makes sense to have separate transport registries.  If we have a single transport registry that describes the allowable transports for HTTP, HTTPS, SSH, and DNS, it's going to be a real mess to explain which ones you can use when.\r\n\r\n> There are legitimate use-cases for no-default-transport\r\n> outside ot web browsers. It would be entirely reasonable\r\n> for web services in a closed ecosystem to only support HTTP/3.\r\n\r\nThe relevant text is:\r\n```\r\nFor compatibility with clients that require default transports,\r\nzone operators SHOULD ensure that at least one RR in each RRSet supports the\r\ndefault transports.\r\n```\r\nI think it's clear enough that one is free to violate that SHOULD in a closed ecosystem.\r\n\r\n> We may want to be clear in our initial registry entries\r\n> that these are \"TLS over TCP\" and \"QUIC over UDP\" ?\r\n\r\nThe \"TLS\" line is referenced to RFC 2818, which seems like it ought to be the place for that to be specified.  I admit that RFC 2818 could be a little clearer about that, but personally I don't think it's ambiguous.  Hopefully the HTTP-over-QUIC RFC will be clearer.  If you think it's unclear, I guess we could add a \"meaning\" column to the registry.\r\n\r\n> We should provide guidance for how servers make\r\n> a transition for Alt-Svc from alpn to these additional-transports.\r\n> (ie, recommend that they include both,\r\n\r\nDone\r\n\r\n> and we should probably show this in our example.)\r\n\r\nI didn't add an example of this, but we can if you want.  It gets us back into some thorny territory with esniconfig...",
          "createdAt": "2020-01-17T21:30:47Z",
          "updatedAt": "2020-01-17T21:30:47Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "This has been rebased and substantially simplified. There is no longer any need for the \"any\" ALPN and other interaction with Alt-Svc.  PTAL.",
          "createdAt": "2020-01-24T19:41:07Z",
          "updatedAt": "2020-01-24T19:41:07Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "It sounds like we have a lot more to discuss in the finer details of this arrangement, but it's clear that this PR is closer to our consensus than what's in `master`, so I'm going merge this as-is.  We can improve the representation in followup PRs.",
          "createdAt": "2020-02-14T21:28:38Z",
          "updatedAt": "2020-02-14T21:28:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTAzNTky",
          "commit": {
            "abbreviatedOid": "65f3ba2"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-15T20:34:55Z",
          "updatedAt": "2020-01-15T21:05:24Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Not all SvcParm types have wire formats where \"empty value\" is meaningful or well-defined (eg, integers or IPs).  We should either qualify this here and later on.  Does this add too much complexity?",
              "createdAt": "2020-01-15T20:34:55Z",
              "updatedAt": "2020-02-14T19:34:20Z"
            },
            {
              "originalPosition": 129,
              "body": "nit: what is \"transport\" vs \"protocol\" here?  Perhaps say \"any compatible transport protocols\" ?",
              "createdAt": "2020-01-15T20:40:23Z",
              "updatedAt": "2020-02-14T19:34:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0ODQxOTc2",
          "commit": {
            "abbreviatedOid": "908c699"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-17T21:07:32Z",
          "updatedAt": "2020-01-17T21:07:33Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I added notes to the keys that don't support empty values.  Hopefully that should be enough to make it clear.\r\n\r\nI made this adjustment because `transport=quic no-default-transport` seemed a lot clearer than `transport=quic no-default-transport=\"\"`.  In general, I think its worth investing in clarity for zone file editors, since zone files get edited a lot more often than DNS software.",
              "createdAt": "2020-01-17T21:07:33Z",
              "updatedAt": "2020-02-14T19:34:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0ODQyMDE0",
          "commit": {
            "abbreviatedOid": "908c699"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-17T21:07:38Z",
          "updatedAt": "2020-01-17T21:07:38Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "Done.",
              "createdAt": "2020-01-17T21:07:38Z",
              "updatedAt": "2020-02-14T19:34:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3OTg1MzI4",
          "commit": {
            "abbreviatedOid": "908c699"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-24T14:24:12Z",
          "updatedAt": "2020-01-24T14:24:13Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Perhaps \"supports HTTPS-over-QUIC (HTTP/3) in addition to HTTPS over TLS\" ?",
              "createdAt": "2020-01-24T14:24:12Z",
              "updatedAt": "2020-02-14T19:34:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3OTk1OTgx",
          "commit": {
            "abbreviatedOid": "908c699"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-24T14:39:41Z",
          "updatedAt": "2020-01-24T14:39:42Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Adding a \"meaning\" column to the registry may make sense.\r\n\r\nIt seems like we're making enough changes to Alt-Svc here that we may need to split some of these out to an alt-svc-bis draft?   Switching Alt-Svc to use ALPN=any but focusing on transport may make sense.  At a minimum we likely should include a section here on how filtering works for Alt-Svc in a world where records are like:\r\n\r\n       Alt-Svc: any=\"pool.service.example:443\" transport=quic, any=\"pool.service.example:443\" transport=tls \r\n\r\nAs part of this change we should include a reminder that clients using HTTPSSVC or AltSvc with \"any\" MUST still send TLS SNI (or ESNI when esniconfig is specified).\r\n\r\nGoing back to a question from @MikeBishop, do we still want a hinting/filtering mechanism for ALPN?  This can be useful for letting clients using an experimental protocol know that it is available on a pool with a different name.  That has been one Alt-Svc use-case for ALPN.  Or does this add too much complexity?",
              "createdAt": "2020-01-24T14:39:41Z",
              "updatedAt": "2020-02-14T19:34:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMzA4MTQz",
          "commit": {
            "abbreviatedOid": "aaa918c"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-04T21:18:22Z",
          "updatedAt": "2020-02-04T22:25:47Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "> This can be useful for letting clients using an experimental protocol know that it is available on a pool with a different name.\r\n\r\nNote that such a deployment loses downgrade-protection of ALPN. So does a temporary heterogeneous deployment during rollout or rollback on a multi-instance service, but I think such situations are better understood to be temporary.",
              "createdAt": "2020-02-04T21:18:22Z",
              "updatedAt": "2020-02-14T19:34:20Z"
            },
            {
              "originalPosition": 127,
              "body": "Having one port parameter describe all transports is kind of odd, both when it's TCP vs UDP and UDP vs UDP. For TCP/TLS/H{1.1,2} the port is a TCP port. For UDP/QUIC/H3, the port is a UDP port. That maps TCP and UDP ports onto each other, which seems a little odd? But at least it's distinguishable because the endpoint layer branches.\r\n\r\nSuppose we were to later define UDP/VeryFancyProto/H4. This design more-or-less forces all new UDP-based protocols for transporting HTTP to share protocol invariants with QUIC. You get exactly two sets of protocol invariants, one for TCP and one for UDP, and then it starts getting very inconvenient. This is... odd.\r\n\r\nOn the other hand, if we were to define UDP/QUICv2/H3 such that QUIC and QUICv2 *did* expect to run together *but* benefited from an out-of-band version hint (if QUICv2 is purely in-band negotiation like TLS, then there is no need to incorporate it into HTTPSSVC at all), then this works as separate transports. Although it is interesting to note that, in that picture, UDP/QUIC and UDP/QUICv2 have a very different relationship from TCP/TLS. (I don't know how `Alternate-Protocol` expressed this, but Google's `Alt-Svc` advertisement for gQUIC seems to use a separate `v` attribute for denoting versions.)\r\n\r\nAn alternate design would have been to instead:\r\n1. Get rid of `no-default-transport`.\r\n2. `transport` is an optional single-valued token. If omitted, it is the default transport.\r\n3. `port` and other attributes modify just the one transport.\r\n4. Replace the \"if all of the RRs indicate `no-default-transport`\" with \"if none of the RRs indicates the default transport\".\r\n\r\nThis avoids the port oddities and flattens the structure a bit, which seems simpler to me. One wriggle is it requires duplicating the ESNI config per transport whereas this design avoids it *in cases where the port confusion is what you wanted*. (Clllleeeeaaarrly we need a more complicated encoding! :-D)\r\n\r\nAnother design would be some odd two-level thing where transports have associated attributes.\r\n\r\n@DavidSchinazi I'm curious what your thoughts on all this is. Most of the oddities pertain to QUIC.",
              "createdAt": "2020-02-04T21:29:36Z",
              "updatedAt": "2020-02-14T19:34:20Z"
            },
            {
              "originalPosition": 141,
              "body": "s/SHOULD/MUST/\r\n\r\nIt's a syntax error. Syntax errors are fatal.",
              "createdAt": "2020-02-04T22:24:18Z",
              "updatedAt": "2020-02-14T19:34:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzODk5ODUw",
          "commit": {
            "abbreviatedOid": "aaa918c"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T17:23:05Z",
          "updatedAt": "2020-02-05T17:23:05Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "> This design more-or-less forces all new UDP-based protocols for transporting HTTP to share protocol invariants with QUIC.\r\n\r\nI'm not quite sure what this means, or if it's true.  There may indeed be two UDP transports that can't share a port.  That's fine; they can just go in separate RRs with different port numbers.\r\n\r\nWe could certainly restructure this to require one transport per RR, or to express multiple ports per RR (TCP and UDP or per-transport), but the former seems inefficient, and the latter seems overcomplicated.  Sharing a port number between TCP and UDP may not be precisely principled, but in practice IANA [almost always](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers) assigns both ports to the same service, so I think it's fairly intuitive.\r\n\r\nAs you noted, sharing an RR is mostly a space optimization, especially with ESNIConfig.  My guess is that the majority of IPs that have QUIC and TLS with the same ESNIConfig will also have them at the same port number, so one-port-number-per-RR gets us most of the space savings with the least complexity.",
              "createdAt": "2020-02-05T17:23:05Z",
              "updatedAt": "2020-02-14T19:34:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzOTIxMDA3",
          "commit": {
            "abbreviatedOid": "fb79fba"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T17:55:32Z",
          "updatedAt": "2020-02-05T17:55:33Z",
          "comments": [
            {
              "originalPosition": 141,
              "body": "Done",
              "createdAt": "2020-02-05T17:55:32Z",
              "updatedAt": "2020-02-14T19:34:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzOTU3NzE1",
          "commit": {
            "abbreviatedOid": "aaa918c"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T18:52:07Z",
          "updatedAt": "2020-02-05T18:52:08Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "Sorry, I should have elaborated on \"more-or-less\". Encoding separate RRs for port purposes in this proposal is fussy (you need a no-default-transport) and costs a duplicate ESNI config. (Which we presumably care about or we'd go with the flattened design.) That means there will be pressure at the protocol design phase to share invariants, which means we effectively are saying this.\r\n\r\nThat's not to say this is fatal. Maybe each scheme only needs two sets of protocol invariants? QUIC folks have no doubt thought about this more than me so I'd like to know what they think. My main position is that, if we're strongly incentivizing this, we need to recognize that and decide we're okay with it, and not hide behind the verbose alternative existing.",
              "createdAt": "2020-02-05T18:52:07Z",
              "updatedAt": "2020-02-14T19:34:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjQ4MjQz",
          "commit": {
            "abbreviatedOid": "fb79fba"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-10T20:43:06Z",
          "updatedAt": "2020-02-10T20:43:06Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "> Encoding separate RRs for port purposes in this proposal is fussy (you need a no-default-transport) and costs a duplicate ESNI config. (Which we presumably care about or we'd go with the flattened design.)\r\n\r\nAgreed, although this syntax was also motivated by simplicity for zone owners when QUIC and TLS share all parameters, which we took to be the common case.\r\n\r\n> That means there will be pressure at the protocol design phase to share invariants, which means we effectively are saying this.\r\n\r\nI think this is at most a weak incentive, not a significant pressure on future designs.  Suppose NOTQUIC is a secure transport protocol over UDP that cannot share a port with QUIC.  (I think this is an unlikely scenario but we should nonetheless support it.)  In the current design, this would be written as\r\n```\r\n... port=1234 transport=quic esniconfig=\"abc...\" ; TLS and QUIC\r\n... port=4321 transport=notquic no-default-transport esniconfig=\"def...\" ; NOTQUIC\r\n```\r\nIn a flattened design, this would instead be\r\n```\r\n... port=1234 esniconfig=\"abc...\" ; TLS\r\n... port=1234 transport=quic esniconfig=\"abc...\" ; QUIC\r\n... port=4321 transport=notquic esniconfig=\"def...\" ; NOTQUIC\r\n```\r\nI don't see a major advantage in comprehensibility between these options.  On balance, I prefer the former; duplicating the ESNIConfig seems to invite typos and misconfigurations that will not easily be caught.\r\n\r\nBTW, even if NOTQUIC can't share a UDP port with QUIC, users can still avoid `no-default-transport` by running TLS on the TCP port of the same number.  This seems like a reasonable, perhaps likely configuration, for the same reasons that it appears to be popular with QUIC.",
              "createdAt": "2020-02-10T20:43:06Z",
              "updatedAt": "2020-02-14T19:34:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MzkzODE2",
          "commit": {
            "abbreviatedOid": "fb79fba"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-02-11T02:43:20Z",
          "updatedAt": "2020-02-11T02:43:33Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "The problem with the half-flattened scheme is this design is extremely inconsistent in its principles. It simultaneously believes `no-default-transport` is a rare misfeature only to be used for questionable deployment patterns, at the same time it is a pattern for new protocols. It then simultaneously believes duplicating the ESNIConfig is a problem and should be avoided, yet recommends it as a pattern for new protocols. All this mixup then pressures new protocols to share UDP ports to avoid all these design flaws, yet it also insists this pressure doesn't exist.\r\n\r\n> BTW, even if NOTQUIC can't share a UDP port with QUIC, users can still avoid no-default-transport by running TLS on the TCP port of the same number. This seems like a reasonable, perhaps likely configuration, for the same reasons that it appears to be popular with QUIC.\r\n\r\nNo, this is not a reasonable or likely configuration. Moreover, it's dangerous because it further incentivizes existing TCP HTTP servers to not check port numbers against the HTTP `Host` header. (This check is a security requirement for sites running different origins on different ports as it's the only thing preventing the network from mixing ports up.)\r\n\r\nIt's popular with QUIC because, barring any reason to pick another port, 443 is the natural one in order to match with the origin. HTTPSSVC having broken all these standard assumption is not going to suddenly make people want to deploy TCP over the corresponding port for NOTQUIC. That doesn't really make any sense at all.",
              "createdAt": "2020-02-11T02:43:20Z",
              "updatedAt": "2020-02-14T19:34:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2Nzk2OTQ4",
          "commit": {
            "abbreviatedOid": "fb79fba"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-11T16:20:37Z",
          "updatedAt": "2020-02-11T16:20:37Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "It sounds like you're proposing to drop the requirement that zone authors need to take an explicit action to disable TLS support, as in your flattened example in this thread.  If you're willing to drop that requirement, I agree that we can find a more principled design.\r\n\r\nPersonally, I would lean toward more multiplexing, e.g.\r\n```\r\n... ports=tls:1234,quic:1234 esniconfig=\"abc...\"\r\n... ports=notquic:4321 esniconfig=\"def...\"\r\n```",
              "createdAt": "2020-02-11T16:20:37Z",
              "updatedAt": "2020-02-14T19:34:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODE1OTUw",
          "commit": {
            "abbreviatedOid": "fb79fba"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-11T16:43:09Z",
          "updatedAt": "2020-02-11T16:43:09Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "I'm not a fan of multiplexing based on port and making it primary in the model.  There may be transports in the future that move away from numeric ports or have a different model that isn't port-based.  As an example, if we had a future L4 protocol assignment for some QUIC successor (rather than requiring it to be over UDP).",
              "createdAt": "2020-02-11T16:43:09Z",
              "updatedAt": "2020-02-14T19:34:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODQzMjkw",
          "commit": {
            "abbreviatedOid": "fb79fba"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-11T17:17:44Z",
          "updatedAt": "2020-02-11T17:17:44Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "I think extension to portless protocols would work fine in this model.  It would just require defining one or more new SvcParamKeys.  For example, we could have\r\n```\r\n... ports=tls:443,quic:443,quic:8443 l4quic esniconfig=\"abc...\"\r\n```\r\nwhere `l4quic` is a new empty-valued SvcParamKey indicating support for the (hypothetical) QUIC-at-L4 protocol.\r\n\r\nBasically, ServiceForm is extensible enough that we can probably convey whatever information we need to in the future.",
              "createdAt": "2020-02-11T17:17:44Z",
              "updatedAt": "2020-02-14T19:34:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MTExODYw",
          "commit": {
            "abbreviatedOid": "fb79fba"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-14T17:46:10Z",
          "updatedAt": "2020-02-14T17:46:11Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "Perhaps add:\r\n\"The wire format for the value of no-default-transport is empty (a SvcParamValue with a length of zero octets).\"\r\nor something else to be crystal clear that value is still present in the wire format but empty.",
              "createdAt": "2020-02-14T17:46:10Z",
              "updatedAt": "2020-02-14T19:34:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MTcyNjUx",
          "commit": {
            "abbreviatedOid": "566806a"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-14T19:34:39Z",
          "updatedAt": "2020-02-14T19:34:40Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "OK, I added clarifying text to this effect.",
              "createdAt": "2020-02-14T19:34:39Z",
              "updatedAt": "2020-02-14T19:34:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MjI2NDgw",
          "commit": {
            "abbreviatedOid": "566806a"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-14T21:22:53Z",
          "updatedAt": "2020-02-14T21:22:53Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MzI5Nzc3",
          "commit": {
            "abbreviatedOid": "566806a"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-15T06:27:39Z",
          "updatedAt": "2020-02-15T06:27:39Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "> It sounds like you're proposing to drop the requirement that zone authors need to take an explicit action to disable TLS support, as in your flattened example in this thread.\r\n\r\nI mean, I never requested that property to begin with. :-) I think something got lost in translation here.\r\n\r\nThe deployability requirement is that is *impossible* to disable the default transport. Possible with explicit action doesn't solve anything. It should either be syntactically impossible (preferred) or, if that can't be avoided, it needs to be easy to describe and detect (that's why I've been trying to avoid giving it a name that differs by scheme), with the expectation that authoritative servers reject it at the config level and clients reject it if they see it.\r\n\r\nFrom there, it would be nice if the wrong thing was easy to avoid, but if authoritatives perform the mandatory checks, that helps smooth things over a bit.\r\n\r\nLet's sync after the long weekend. GitHub PRs aren't a great medium for design discussions. I think we need something more synchronous and high-bandwidth. This DNS record has gotten far too complicated. We need to cut down the flexibility by an order of magnitude before this is viable.",
              "createdAt": "2020-02-15T06:27:39Z",
              "updatedAt": "2020-02-15T06:27:39Z"
            }
          ]
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "bc40093d09c5bcf09c827d2ab438266b781b26dd",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-transport",
      "headRefOid": "566806a329b5c326bff1de8a4268d4079bc929b8",
      "mergeCommit": {
        "oid": "21c1a83dcb298abe5758ccea4f45cc37a8bc0275"
      }
    },
    {
      "number": 102,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYzMTkxMzUy",
      "title": "Alt-Used example",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/102",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* Add an example for Alt-Used per issue #101  (although exact details may need to change depending on other PRs around alpn vs transport).\r\n* Fix reference to client-behavior",
      "createdAt": "2020-01-15T15:19:56Z",
      "updatedAt": "2020-06-18T07:09:47Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "9385e296539aea1c860e4e9dd9c0a5d0ec4c8804",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-alt-used-example",
      "headRefOid": "6d2598e9ce3c40356d1ad7d1e9bf670e0be4f9e1",
      "closedAt": "2020-04-13T20:55:28Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sending this header has some interesting tracking consequences. Your DNS resolver can unilaterally send a common cross-site identifier to every site by faking an HTTPSSVC name. The DNS resolver would answer for that name too, so it doesn't matter if the name is fake. More generally, this is feeding an insecure value into a header in a secure context, which is odd.\r\n\r\n(Chrome doesn't send `Alt-Used` for Alt-Svc either, though I don't know what the reasoning was at the time.)",
          "createdAt": "2020-01-15T22:51:23Z",
          "updatedAt": "2020-01-15T22:51:40Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "In Alt-Svc days, the argument was that the issuer of Alt-Svc could produce tracking anyway -- they give you a name that resolves to an IPv6 address with the host portion being the identifier they want to use, then serve over the whole prefix.  The argument was that Alt-Used didn't give them any additional information versus that structure.  (However, it permits it to work over IPv4, which seems like a sufficient increase in capability to warrant some caution.)\r\n\r\nHowever, that requires control of the actual IP address.  The recipient of Alt-Used need not be the issuer of the Alt-Svc record if the alternative can come from DNS.  Seems like another incarnation of these records not being authenticated as being from the affected domain.",
          "createdAt": "2020-01-16T19:08:24Z",
          "updatedAt": "2020-01-16T19:08:24Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Per #107, it looks like we're going to try a different direction for this. @enygren, would you like to close this PR?",
          "createdAt": "2020-01-24T20:01:52Z",
          "updatedAt": "2020-01-24T20:01:52Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Abandoning this for now, pending discussion of issue 107.",
          "createdAt": "2020-04-13T20:55:28Z",
          "updatedAt": "2020-04-13T20:55:28Z"
        },
        {
          "author": "bagder",
          "authorAssociation": "NONE",
          "body": "Not exactly the right place for this but note that `Alt-Used` is slightly flawed in that it doesn't mention protocol/alpn so when we switch *nothing but* h2 to h3 to the same host name and port number, Cloudflare for example will wrongly think it is a loop.",
          "createdAt": "2020-06-18T07:09:47Z",
          "updatedAt": "2020-06-18T07:09:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMzgyNDMx",
          "commit": {
            "abbreviatedOid": "e5dd062"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-15T17:12:01Z",
          "updatedAt": "2020-01-15T17:13:00Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I would suggest \"(and https://pool.svc.example, if it exists)\", since there's no particular need for that origin to exist.",
              "createdAt": "2020-01-15T17:12:01Z",
              "updatedAt": "2020-01-15T21:31:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 104,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYzNzg5NTc1",
      "title": "Generalize SERVFAIL handling for security",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/104",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #103",
      "createdAt": "2020-01-16T18:41:00Z",
      "updatedAt": "2020-02-03T23:37:06Z",
      "closedAt": "2020-01-27T21:08:45Z",
      "mergedAt": "2020-01-27T21:08:45Z",
      "mergedBy": "enygren",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is to address the attack we discussed where the attacker drops QUIC packets to time out the HTTPSSVC response, right? I think the rationale here should be in the draft, in case this fix fails. E.g., if many authoritative servers time out unexpected record types, HTTPSSVC would break sites and thus this would not be viable.\r\n\r\nHaving the reasoning documented means we won't forget to explore alternate fixes. (Perhaps we make some kind of \"combined query\" to the DoH resolver so it knows to pack the responses together?)",
          "createdAt": "2020-02-03T22:35:43Z",
          "updatedAt": "2020-02-03T22:35:43Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "The rationale is there:\r\n> A transport error or timeout can\r\n> occur if an active attacker between the client and the recursive resolver is\r\n> selectively dropping SVCB queries or responses, based on their size or\r\n> other observable patterns.",
          "createdAt": "2020-02-03T22:57:11Z",
          "updatedAt": "2020-02-03T22:57:11Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah oops! Apparently I can't read. :-)\r\n\r\n(We were discussing how we want to handle this and the risks associated.)",
          "createdAt": "2020-02-03T23:37:06Z",
          "updatedAt": "2020-02-03T23:37:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3OTY5NTU4",
          "commit": {
            "abbreviatedOid": "e96cf37"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-24T14:00:00Z",
          "updatedAt": "2020-01-24T14:00:00Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Can the client use a previous stale answer if it has one in-cache still? ",
              "createdAt": "2020-01-24T14:00:00Z",
              "updatedAt": "2020-01-24T15:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3OTcwNDEz",
          "commit": {
            "abbreviatedOid": "e96cf37"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-24T14:01:25Z",
          "updatedAt": "2020-01-24T14:01:25Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "The client may also wish to retry the query against another equally-trusted resolver?  (eg, if it has multiple resolver IPs.)",
              "createdAt": "2020-01-24T14:01:25Z",
              "updatedAt": "2020-01-24T15:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MDQzNDk5",
          "commit": {
            "abbreviatedOid": "cea004f"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-24T15:47:12Z",
          "updatedAt": "2020-01-24T15:47:13Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Good point, we don't necessarily want to rule out those options.  I've changed the text from \"MUST abandon\" to \"MUST NOT fall back\".",
              "createdAt": "2020-01-24T15:47:12Z",
              "updatedAt": "2020-01-24T15:47:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4OTc1NzU2",
          "commit": {
            "abbreviatedOid": "cea004f"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-27T21:08:37Z",
          "updatedAt": "2020-01-27T21:08:37Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "30d65cb6e04e2dedbb0d368b87db575c3ee01119",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-srvfail",
      "headRefOid": "cea004f1071604d3a335fa19c73ec04147516fa1",
      "mergeCommit": {
        "oid": "08bb96aca32a86c41805dcc8633ee8e0f1f8c82b"
      }
    },
    {
      "number": 106,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY1NDc2Mjky",
      "title": "Fully specify HTTPSSVC/Alt-Svc/ESNI interaction",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/106",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #105",
      "createdAt": "2020-01-21T19:41:06Z",
      "updatedAt": "2020-02-14T17:10:49Z",
      "closedAt": "2020-02-14T17:10:43Z",
      "mergedAt": "2020-02-14T17:10:43Z",
      "mergedBy": "bemasc",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "This proposal has been substantially simplified now that Alt-Svc changes are excluded from this draft.",
          "createdAt": "2020-01-24T19:59:39Z",
          "updatedAt": "2020-01-24T19:59:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMjk5NTc0",
          "commit": {
            "abbreviatedOid": "d4e4c66"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-04T21:03:58Z",
          "updatedAt": "2020-02-04T21:09:49Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "This text still allows clients to short-circuit HTTPSSVC if an Alt-Svc cache entry exists, which means all the issues from #105 apply. (Is this just a mistake? The ESNI client behavior below seems to suggest HTTPSSVC goes first.)\r\n\r\nOr is the intent that the ESNI client behavior overrides this paragraph? It's probably worth writing this a bit more explicitly. The combination is also weird because that text isn't additional requirements on top of the base algorithm. It completely changes it. (The base algorithm, while not explicitly spelled out, implies that the Alt-Svc integration point is before HTTPSSVC while the ESNI algorithm says it's after.)",
              "createdAt": "2020-02-04T21:03:58Z",
              "updatedAt": "2020-02-14T16:49:20Z"
            },
            {
              "originalPosition": 83,
              "body": "Marking it more preferred means ESNI is still not downgrade-protected, right? I.e. the prioirty thing is just to be opportunistically okay? It's probably worth clarifying. This confused me at first.",
              "createdAt": "2020-02-04T21:09:11Z",
              "updatedAt": "2020-02-14T16:49:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0NjM1ODgw",
          "commit": {
            "abbreviatedOid": "ef7fa4c"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-06T17:28:13Z",
          "updatedAt": "2020-02-06T17:28:13Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "> Or is the intent that the ESNI client behavior overrides this paragraph? It's probably worth writing this a bit more explicitly.\r\n\r\nYes.  I've pushed a change to clarify this.",
              "createdAt": "2020-02-06T17:28:13Z",
              "updatedAt": "2020-02-14T16:49:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0NjM2MDk0",
          "commit": {
            "abbreviatedOid": "ef7fa4c"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-06T17:28:30Z",
          "updatedAt": "2020-02-06T17:28:30Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "OK, I've added a clarification on this point.",
              "createdAt": "2020-02-06T17:28:30Z",
              "updatedAt": "2020-02-14T16:49:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MDcwMjY5",
          "commit": {
            "abbreviatedOid": "ef7fa4c"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-14T16:37:44Z",
          "updatedAt": "2020-02-14T16:37:45Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "It seems like we should be explicit around whether DNS lookups for the Alt-Svc host are done only for A/AAAA records or also for SVCB/HTTPSSVC records?\r\nApproaches:\r\n1) Be explicit that the host in Alt-Svc is just resolved for A/AAAA records/\r\n2) Have an Alt-Svc attribute of \"svcb=1\" which would indicate that the Alt-Svc name is to a HTTPSSVC record?  In the behavior ordering, we could include then allow these to go before HTTPSSVC DNS lookups.  This might make sense in a separate AltSvc-bis/rfc7838bis draft that updates this and 7838 (along with other changes).",
              "createdAt": "2020-02-14T16:37:44Z",
              "updatedAt": "2020-02-14T16:49:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MDgxMzM4",
          "commit": {
            "abbreviatedOid": "6645082"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-14T16:53:49Z",
          "updatedAt": "2020-02-14T16:53:50Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I think your option 1 is our only choice at this point.  I've uploaded a sentence to clarify that.\r\n\r\nSome kind of interaction between Alt-Svc and SVCB could be very interesting in the future, but as it stands, I don't see how to make that delegation work.  For example, there could be very complex interactions between Alt-Svc and HTTPSSVC values that can disagree (e.g. ALPN/\"transport\", \"persist\", \"esniconfig\").\r\n\r\nI think Alt-Svc-bis is beginning to sound like a good idea, but first we should get this draft finalized.",
              "createdAt": "2020-02-14T16:53:49Z",
              "updatedAt": "2020-02-14T16:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MDkxNTc4",
          "commit": {
            "abbreviatedOid": "6645082"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-14T17:09:57Z",
          "updatedAt": "2020-02-14T17:09:57Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "bc40093d09c5bcf09c827d2ab438266b781b26dd",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-fallback",
      "headRefOid": "66450828406dcc0e67d72aad6f40316cd6fc8bc9",
      "mergeCommit": {
        "oid": "343eac0b3b115d8064958fbbd1393d791ba704d6"
      }
    },
    {
      "number": 108,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY2OTU3MTEw",
      "title": "Remove normative references to Alt-Svc",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/108",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This simplifies the draft, and allows any changes\r\nto Alt-Svc to happen in a separate draft.  Substantive\r\ntext relating HTTPSSVC to Alt-Svc has been moved into\r\na new file of notes for posterity.",
      "createdAt": "2020-01-24T18:18:06Z",
      "updatedAt": "2020-01-24T19:34:52Z",
      "closedAt": "2020-01-24T19:34:52Z",
      "mergedAt": "2020-01-24T19:34:52Z",
      "mergedBy": "bemasc",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "It's a good start.  I still think we should define precedence when clients implement both Alt-Svc and HTTPSSVC, though we can potentially handle that separately.",
          "createdAt": "2020-01-24T19:05:03Z",
          "updatedAt": "2020-01-24T19:05:03Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> I still think we should define precedence when clients implement both Alt-Svc and HTTPSSVC, though we can potentially handle that separately.\r\n\r\nAgreed.  I'm hoping to handle that in a followup PR.",
          "createdAt": "2020-01-24T19:11:36Z",
          "updatedAt": "2020-01-24T19:11:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MTYxOTk5",
          "commit": {
            "abbreviatedOid": "7b31937"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-24T19:05:14Z",
          "updatedAt": "2020-01-24T19:05:14Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "30d65cb6e04e2dedbb0d368b87db575c3ee01119",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-split",
      "headRefOid": "f1f25ae8ed0dc0ded50507be5bfe00833f461c60",
      "mergeCommit": {
        "oid": "bc40093d09c5bcf09c827d2ab438266b781b26dd"
      }
    },
    {
      "number": 109,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc2ODc5OTYw",
      "title": "Only allow each SvcParamKey to appear once",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/109",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This includes some adjustments to make repeated keys\r\nunnecessary.\r\n\r\nIncorporates #94 by @davidben\r\nAddresses #95",
      "createdAt": "2020-02-18T23:01:39Z",
      "updatedAt": "2020-03-05T02:30:08Z",
      "closedAt": "2020-03-05T02:30:08Z",
      "mergedAt": "2020-03-05T02:30:08Z",
      "mergedBy": "enygren",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "> This is over specification on ungrounded fears that people will generate bad RRs that need to be debugged through resolvers. This change is not driven by consensus.\r\n\r\n@marka63 : which particular part of this are you concerned about?  (There are lots of items in this thread now.)",
          "createdAt": "2020-02-21T15:52:07Z",
          "updatedAt": "2020-02-21T15:52:07Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Did we have any remaining issues here before we merge?\r\n",
          "createdAt": "2020-03-04T21:37:26Z",
          "updatedAt": "2020-03-04T21:37:26Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "(I'm ready to merge after approval from one of the authors.)",
          "createdAt": "2020-03-04T22:40:18Z",
          "updatedAt": "2020-03-04T22:40:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjIyMTI1",
          "commit": {
            "abbreviatedOid": "ceb71a3"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-20T20:48:35Z",
          "updatedAt": "2020-02-20T20:48:36Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Should we mention that clients SHOULD instead use other non-malformed RRs in the RRSET if possible?  (We want to avoid forward compat issues where a client implementation bug or some change causes entire rrsets to get rejected.)\r\n\r\nWould it be safer for some of these to have deterministic behavior rather than \"reject the RR\"?",
              "createdAt": "2020-02-20T20:48:35Z",
              "updatedAt": "2020-02-21T17:52:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjMzODUz",
          "commit": {
            "abbreviatedOid": "ceb71a3"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-20T21:06:14Z",
          "updatedAt": "2020-02-20T21:06:14Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "If a RR is malformed the entire RRset should be rejected.  One cannot safely use partial RRsets.   Operators should not depend on RRsets getting through a recursive server if a RR is malformed.\r\n\r\nSTD 13 says to reject the entire zone if a single RR is malformed when loading a zone. \r\nRecursive servers that are aware of the structure of these records should be rejecting answers that contain malformed RRs (they are not permitted to filter out individual RRs).",
              "createdAt": "2020-02-20T21:06:14Z",
              "updatedAt": "2020-02-21T17:52:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjM2MjE4",
          "commit": {
            "abbreviatedOid": "ceb71a3"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-20T21:10:26Z",
          "updatedAt": "2020-02-20T21:10:26Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "That would seem to argue in-favor of having deterministic handling of certain types of errors rather than rejecting the RR? \r\nFor example, in the case of a parameter appearing multiple times, clients MUST use only the first instance.\r\nOverly strict rejection (rather than deterministic handling) could make extensibility much harder in the future?",
              "createdAt": "2020-02-20T21:10:26Z",
              "updatedAt": "2020-02-21T17:52:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjUxMjYx",
          "commit": {
            "abbreviatedOid": "ceb71a3"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-20T21:36:47Z",
          "updatedAt": "2020-02-20T21:36:48Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Does this restrict us to only one address of each family?",
              "createdAt": "2020-02-20T21:36:47Z",
              "updatedAt": "2020-02-21T17:52:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjU2NjU3",
          "commit": {
            "abbreviatedOid": "ceb71a3"
          },
          "author": "dmcardle",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-20T21:46:02Z",
          "updatedAt": "2020-02-20T21:46:02Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Both ipv4hint and ipv6hint are meant to contain an unordered set of addresses.\r\n\r\nLooks like it was not included in the diff context, but this appears earlier in the section:\r\n\r\n> The wire format for each parameter is a sequence of IP addresses in network\r\nbyte order.  Like an A or AAAA RRSet, the list of addresses represents an\r\nunordered collection, and clients SHOULD pick addresses to use in a random order.\r\nAn empty list of addresses is invalid.",
              "createdAt": "2020-02-20T21:46:02Z",
              "updatedAt": "2020-02-21T17:52:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjY3MTIz",
          "commit": {
            "abbreviatedOid": "ceb71a3"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-20T22:03:39Z",
          "updatedAt": "2020-02-20T22:03:39Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "There are exactly 4 conditions listed here.\r\n\r\n1 the last TLV being malformed (incomplete tag, length or value)\r\n2 TLVs not being sorted on T\r\n3 multiple T with the same value\r\n4 L being incorrect for a given T\r\n\r\nNamed already implements 1.\r\nNamed already implements 4 for some T.\r\n\r\ne.g. for port L == 2, for hint4 L != 0 && L % 4 == 0.\r\n\r\nThis checks are done as named parses a record learn off the wire or after loading with unknown record format.   All the tools which lookup records also perform these checks. \r\n\r\nNone of these currently implemented checks actually prevent new Ts being deployed. ",
              "createdAt": "2020-02-20T22:03:39Z",
              "updatedAt": "2020-02-21T17:52:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjc2ODQ0",
          "commit": {
            "abbreviatedOid": "ceb71a3"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-20T22:21:11Z",
          "updatedAt": "2020-02-20T22:21:12Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "I would have been worried about invalid SVCBs breaking everything until I came to accept the suggestion from a couple weeks ago that the client would handle an SVCB timeout by disallowing fallback to A/AAAA.  So we're already into the territory that a resolver doing something bad or a bad config can completely break resolving the name, and not just the SVCB response.\r\n\r\nSpecific to the case of repeating keys, as long as we have good standardized semantics for list values, I don't see any reason we'd ever need to switch to allowing repeated keys.  So I don't see any reason to ever treat it as anything other than malformed and thus reject the RRSet.  Better for completely invalid things to get noticed by brokenness, so people fix them.\r\n\r\nBut in general, anywhere that we have good reason to want future extensibility, yes, deterministic handling of things that are \"valid but unknown\" is often reasonable.  The obvious example is the \"clients MUST ignore SvcFieldValue parameters that they do not recognize\" rule.",
              "createdAt": "2020-02-20T22:21:12Z",
              "updatedAt": "2020-02-21T17:52:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjg5MTg1",
          "commit": {
            "abbreviatedOid": "466c0cc"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-20T22:45:28Z",
          "updatedAt": "2020-02-20T22:45:29Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "> If a RR is malformed the entire RRset should be rejected. One cannot safely use partial RRsets.\r\n\r\nI think this is reasonable.  I've updated the PR with that logic.\r\n\r\nTechnically, I don't think it's a security issue, but this situation should never happen so it makes sense to be cautious.  Who knows what else might have gotten corrupted if one RR is malformed?  Rejecting the whole RRSet seems like a clearer signal to the zone owner that something is wrong with (e.g.) their authoritative server.\r\n\r\n> Operators should not depend on RRsets getting through a recursive server if a RR is malformed.\r\n> Recursive servers that are aware of the structure of these records should be rejecting answers that contain malformed RRs (they are not permitted to filter out individual RRs).\r\n\r\nI disagree with this.  I've updated the PR to clarify that we don't want recursive resolvers even thinking about the TLVs.  If recursive resolvers are dropping whole RRSets, it will be harder for clients to debug this class of problems (SERVFAIL can mean almost anything).  It's also bad for consistency between resolvers, bad for performance, and could encourage laziness on the part of clients.\r\n\r\n> That would seem to argue in-favor of having deterministic handling of certain types of errors rather than rejecting the RR?\r\n\r\nI agree that determinism is important, and the text was unclear on what was supposed to happen.  I've updated the PR to clarify the intended client behavior.\r\n\r\n> For example, in the case of a parameter appearing multiple times, clients MUST use only the first instance.\r\n> Overly strict rejection (rather than deterministic handling) could make extensibility much harder in the future?\r\n\r\nI'm open to this kind of change, but I think if we impose the single-value requirement now, the chances of us wanting to remove it later are very slim.  If we did do something like what you describe, I think we would also need to GREASE it, because clients could easily implement the \"first value wins\" logic incorrectly (e.g. by rejecting the RR, or using the last value instead of the first) without visibly different behavior in any normal case.\r\n\r\nAs @marka63 notes, extension by adding new types should continue to work as expected, and seems to cover all of our anticipated needs.",
              "createdAt": "2020-02-20T22:45:29Z",
              "updatedAt": "2020-02-21T17:52:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjkyNjM3",
          "commit": {
            "abbreviatedOid": "466c0cc"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-20T22:52:41Z",
          "updatedAt": "2020-02-20T22:52:42Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "yeah, it's really the support for new SvcParamTypes that is most important.  (Do we want to encourage greasing of them and allocating a range for greased ones?)",
              "createdAt": "2020-02-20T22:52:41Z",
              "updatedAt": "2020-02-21T17:52:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjk1NTY2",
          "commit": {
            "abbreviatedOid": "466c0cc"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-20T22:58:43Z",
          "updatedAt": "2020-02-20T23:05:33Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "This one is redundant with the one above it (which is why increasing numeric order is nice). To avoid folks missing this and adding an unnecessary extra check, what if we said:\r\n\r\n----\r\nClients MUST consider an RR malformed if\r\n* the parser reaches [...]\r\n* SvcParamKeys are not in strictly increasing numeric order.\r\n* a SvcParamValue for [...]\r\n\r\nNote the second condition implies there are no duplicate SvcParamKeys.",
              "createdAt": "2020-02-20T22:58:43Z",
              "updatedAt": "2020-02-21T17:52:37Z"
            },
            {
              "originalPosition": 113,
              "body": "Replace this with fixed-width length prefixes. A client parsing DNS (and TLS for that matter) already has tons of routines for such formats. Nothing the client parses in this spec may use separators.\r\n\r\nThen revert the change to `protocol-id`. It should be an 8-bit-clean opaque byte string, like ALPN, so we do not have random implementation variations around people remembering to and forgetting to check, getting the check subtle wrong, and weird bugs in the corners.",
              "createdAt": "2020-02-20T23:05:18Z",
              "updatedAt": "2020-02-21T17:52:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjk4OTQ4",
          "commit": {
            "abbreviatedOid": "466c0cc"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-20T23:06:34Z",
          "updatedAt": "2020-02-20T23:06:35Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Great, thanks!",
              "createdAt": "2020-02-20T23:06:34Z",
              "updatedAt": "2020-02-21T17:52:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzA2OTA4",
          "commit": {
            "abbreviatedOid": "466c0cc"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-20T23:26:12Z",
          "updatedAt": "2020-02-20T23:26:12Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "> > If a RR is malformed the entire RRset should be rejected. One cannot safely use partial RRsets.\r\n> \r\n> I think this is reasonable. I've updated the PR with that logic.\r\n> \r\n> Technically, I don't think it's a security issue, but this situation should never happen so it makes sense to be cautious. Who knows what else might have gotten corrupted if one RR is malformed? Rejecting the whole RRSet seems like a clearer signal to the zone owner that something is wrong with (e.g.) their authoritative server.\r\n> \r\n> > Operators should not depend on RRsets getting through a recursive server if a RR is malformed.\r\n> > Recursive servers that are aware of the structure of these records should be rejecting answers that contain malformed RRs (they are not permitted to filter out individual RRs).\r\n> \r\n> I disagree with this. I've updated the PR to clarify that we don't want recursive resolvers even thinking about the TLVs. If recursive resolvers are dropping whole RRSets, it will be harder for clients to debug this class of problems (SERVFAIL can mean almost anything). It's also bad for consistency between resolvers, bad for performance, and could encourage laziness on the part of clients.\r\n\r\nYes, SERVFAIL can mean almost anything which is why there are tools like DiG that are designed to follow delegations and talk directly to authoritative servers.  They can even dump malformed responses as hex blobs.\r\n\r\nNamed has been rejecting malformed RR content for over a decade now and I guarantee you that it has been a net plus.  I think there has been 1 bug report in that entire time where someone put garbage into a record in a zone and expected named to serve it rather than rejecting it or expected it to get through a resolver. \r\n\r\nI also think that you are worrying way too much about malformed records being there in the first place.  People will use tools to generate the records.  The tools will get it right from the start or will be very quickly fixed to get it right.  SERVFAIL from the recursive server is a great motivator to fix tools.\r\n\r\nAs for lazy clients, whether the resolver rejects malformed records or not it won't make a difference.\r\n\r\nI also don't want to have to do the validation of the record as I am printing it out.  Validation on data entry is much safer.\r\n\r\n",
              "createdAt": "2020-02-20T23:26:12Z",
              "updatedAt": "2020-02-21T17:52:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzEyNzEw",
          "commit": {
            "abbreviatedOid": "466c0cc"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-20T23:37:57Z",
          "updatedAt": "2020-02-20T23:37:57Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Also if it isn't the recursive server checking the content it will end up being the firewall and once it is validation the record content debugging becomes just about impossible.",
              "createdAt": "2020-02-20T23:37:57Z",
              "updatedAt": "2020-02-21T17:52:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzIzNjUz",
          "commit": {
            "abbreviatedOid": "466c0cc"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "This is over specification on ungrounded fears that people will generate bad RRs that need to be debugged through resolvers.  This change is not driven by consensus.",
          "createdAt": "2020-02-21T00:08:28Z",
          "updatedAt": "2020-02-21T00:08:28Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNzI4NDQ0",
          "commit": {
            "abbreviatedOid": "466c0cc"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-21T15:53:06Z",
          "updatedAt": "2020-02-21T15:53:06Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Makes sense to use fixed-width length prefixes to be consistent with everything else.",
              "createdAt": "2020-02-21T15:53:06Z",
              "updatedAt": "2020-02-21T17:52:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyODA4MDc4",
          "commit": {
            "abbreviatedOid": "7f26432"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-21T17:52:59Z",
          "updatedAt": "2020-02-21T17:52:59Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "Done",
              "createdAt": "2020-02-21T17:52:59Z",
              "updatedAt": "2020-02-21T17:52:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyODA4MzM0",
          "commit": {
            "abbreviatedOid": "7f26432"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-21T17:53:26Z",
          "updatedAt": "2020-02-21T17:53:26Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Done.  I made them 1-byte prefix, so the max size is 255.",
              "createdAt": "2020-02-21T17:53:26Z",
              "updatedAt": "2020-02-21T17:53:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyODEwNTY1",
          "commit": {
            "abbreviatedOid": "7f26432"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-21T17:57:15Z",
          "updatedAt": "2020-02-21T17:57:15Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "@marka63 Thanks for sharing your experience with malformed records in practice.  I've removed the recommendation regarding recursive server behavior.\r\n\r\nI think that this draft is negotiating a culture clash between the flexibility of DNSOP and the paranoia of TLS, but I'm optimistic that we'll be able to find a middle ground on the question of specificity.",
              "createdAt": "2020-02-21T17:57:15Z",
              "updatedAt": "2020-02-21T17:57:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MjU5MDg5",
          "commit": {
            "abbreviatedOid": "7f26432"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-05T02:29:55Z",
          "updatedAt": "2020-03-05T02:29:55Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "21c1a83dcb298abe5758ccea4f45cc37a8bc0275",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-singular",
      "headRefOid": "7f26432a43d40399be51457d57eb25b8e96d8f45",
      "mergeCommit": {
        "oid": "e8966ec2f0b94572380328a9857bb04c37233706"
      }
    },
    {
      "number": 110,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc3NDUyMDc0",
      "title": "Add reference to the GitHub",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/110",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Warren Kumari suggests on dnsop:\r\n=======================\r\n\r\nCould I suggest adding something like:\r\n[ RFC Editor - please remove before publication. This document is being\r\ncollaborated on in Github at:\r\nhttps://github.com/MikeBishop/dns-alt-svc.  The most\r\nrecent version of the document, open issues, etc should all be\r\navailable here.  The authors (gratefully) accept pull requests.]\r\n\r\nto the abstract - that way, people reading the draft know where submit PRs, etc.",
      "createdAt": "2020-02-19T23:38:13Z",
      "updatedAt": "2020-02-20T15:10:08Z",
      "closedAt": "2020-02-20T15:10:08Z",
      "mergedAt": "2020-02-20T15:10:08Z",
      "mergedBy": "bemasc",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": ":+1: ",
          "createdAt": "2020-02-20T15:10:00Z",
          "updatedAt": "2020-02-20T15:10:00Z"
        }
      ],
      "reviews": [],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "21c1a83dcb298abe5758ccea4f45cc37a8bc0275",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-wkumari-github-reference",
      "headRefOid": "1c9d44f4af33797977d229be0f089d5de0878d2a",
      "mergeCommit": {
        "oid": "8c9ab4f5fcd579c256b05e42fbd8075cc89edb99"
      }
    },
    {
      "number": 114,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgyNzQyNzAw",
      "title": "Update links to adopted version",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/114",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-03T04:52:24Z",
      "updatedAt": "2020-03-03T15:55:07Z",
      "closedAt": "2020-03-03T15:55:07Z",
      "mergedAt": "2020-03-03T15:55:07Z",
      "mergedBy": "bemasc",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MTAwMDQ2",
          "commit": {
            "abbreviatedOid": "9209c68"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-03T15:55:00Z",
          "updatedAt": "2020-03-03T15:55:00Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "8c9ab4f5fcd579c256b05e42fbd8075cc89edb99",
      "headRepository": "martinthomson/dns-alt-svc",
      "headRefName": "patch-1",
      "headRefOid": "9209c686c30e97b40821e5d7d39f6b8f68e33356",
      "mergeCommit": {
        "oid": "974bbf9510769e39da5e1d0157276b3e984862f3"
      }
    },
    {
      "number": 116,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0MDQxNDIx",
      "title": "Switch from transport= back to alpn=",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/116",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Per discussion in issue #115, switch back to using ALPN but with clarifications.",
      "createdAt": "2020-03-05T03:04:48Z",
      "updatedAt": "2020-03-09T19:43:44Z",
      "closedAt": "2020-03-09T19:43:44Z",
      "mergedAt": "2020-03-09T19:43:44Z",
      "mergedBy": "bemasc",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the text needs to address the question of ALPNs indicating a transport, e.g.\r\n```suggestion\r\nThis specification requires that each ALPN value unambiguously indicates a single protocol suite.  If an ALPN value is specified for use with multiple protocol suites (e.g. both TLS and DTLS), it MUST NOT be included in the SvcParamValue.\r\n```\r\nAlternatively, this restriction could be documented as a requirement specific to HTTPSSVC.\r\n\r\nIdeally, I would define a new \"ALPN Context\" registry with values \"TLS\", \"DTLS\", and \"QUIC\", and add a column to the ALPN registry indicating which context each ALPN is allowed in.  However, I worry that will create delay if we add it to this draft, and it runs into a problem with the \"stun\" ALPNs (which are allowed in both TLS and DTLS).",
          "createdAt": "2020-03-05T16:30:14Z",
          "updatedAt": "2020-03-05T16:30:14Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5Mjg1OTA4",
          "commit": {
            "abbreviatedOid": "d926967"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks for putting this together.  This seems to be the right direction.",
          "createdAt": "2020-03-05T04:15:27Z",
          "updatedAt": "2020-03-05T04:22:55Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "```suggestion\r\nhandshake, clients MUST be willing to use protocols negotiated\r\nduring a handshake even if they do not match an ALPN value from the\r\nset of values indicated in the \"alpn\" parameter.\r\n```",
              "createdAt": "2020-03-05T04:15:28Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            },
            {
              "originalPosition": 131,
              "body": "```suggestion\r\nIn cases where the ALPN set is a list of multiple values,\r\n```",
              "createdAt": "2020-03-05T04:15:47Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            },
            {
              "originalPosition": 133,
              "body": "```suggestion\r\nby the default ALPN identifier if-present.\r\n```",
              "createdAt": "2020-03-05T04:15:56Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            },
            {
              "originalPosition": 145,
              "body": "```suggestion\r\nRegistry defined for HTTPS.  The only default ALPN value \r\n```",
              "createdAt": "2020-03-05T04:16:14Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            },
            {
              "originalPosition": 155,
              "body": "I would prefer to correct Alt-Svc on this point.  But that requires more work.  Perhaps you could leave a marker here indicating a desire to fix that aspect of 7838.",
              "createdAt": "2020-03-05T04:17:22Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            },
            {
              "originalPosition": 105,
              "body": "```suggestion\r\nendpoint (the \"ALPN set\"), the client parses the set of ALPN identifiers in\r\nthe \"alpn\" parameter, and then adds the default set unless the\r\n```",
              "createdAt": "2020-03-05T04:18:38Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            },
            {
              "originalPosition": 93,
              "body": "Separately, I think that `no-default-alpn` is the wrong default.  If a server wants to support HTTP/1.1 in this way, the bits it spends on saying that (I count 9 bytes) isn't that much.  I suspect that we'll want to prioritize space for servers that support other protocols in future, and burdening them with an additional attribute is not great.",
              "createdAt": "2020-03-05T04:20:35Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            },
            {
              "originalPosition": 86,
              "body": "```suggestion\r\nIn the wire format for \"alpn\", each alpn-value is prefixed by its\r\n```\r\n\r\n```suggestion\r\nIn the wire format for \"alpn\", each ALPN identifier (alpn-value) is prefixed by its\r\n```",
              "createdAt": "2020-03-05T04:21:03Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            },
            {
              "originalPosition": 67,
              "body": "```suggestion\r\nThe actual application-layer protocol negotiated during \r\n```",
              "createdAt": "2020-03-05T04:21:27Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\nClients use the set of ALPN identifiers\r\n```",
              "createdAt": "2020-03-05T04:21:47Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\r\nprotocol identifiers {{?ALPN=RFC7301}} \r\n```",
              "createdAt": "2020-03-05T04:22:12Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NzAwNTU3",
          "commit": {
            "abbreviatedOid": "d926967"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-05T16:05:13Z",
          "updatedAt": "2020-03-05T16:17:28Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "```suggestion\r\nalpn set does not contain any compatible protocol suites.  To ensure\r\n```",
              "createdAt": "2020-03-05T16:05:14Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            },
            {
              "originalPosition": 131,
              "body": "```suggestion\r\nIn cases where the alpn set contains multiple values,\r\n```",
              "createdAt": "2020-03-05T16:05:52Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            },
            {
              "originalPosition": 132,
              "body": "If the order matters then this isn't a set, and we need to define, where the default ALPN is inserted, for example.  However, I don't understand what value we are gaining for this complexity.  Why would a server need to tell the client which supported transport should be preferred?",
              "createdAt": "2020-03-05T16:08:56Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            },
            {
              "originalPosition": 127,
              "body": "I think this paragraph should be replaced by the text we previously had on this point: https://github.com/MikeBishop/dns-alt-svc/commit/9c133e81c8932d4017a9cff040577c09273186c7#diff-6a78b06198e2a4dd4bb7dc07a558a5adR696.  That text essentially states this requirement in the opposite way, which I think is clearer.  It could also be combined with the paragraph at Line 797 to reduce repetition.",
              "createdAt": "2020-03-05T16:12:41Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            },
            {
              "originalPosition": 93,
              "body": "This structure isn't intended to increase efficiency.  The additional attribute is there to make it hard to disable TLS accidentally.  Otherwise, a zone owner could easily write \"alpn=h3\", observe that everything works in their testing, and deploy without realizing that they've created an outage for all their non-QUIC-capable clients.",
              "createdAt": "2020-03-05T16:17:28Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NzY0OTAw",
          "commit": {
            "abbreviatedOid": "d926967"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-05T17:21:56Z",
          "updatedAt": "2020-03-05T17:21:56Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "The text currently allows a scheme to have _multiple_ default ALPNs, so this needs to be a plural, and instead of a \"default set\" we would presumably need a \"default list\" in a specified order.  (As above, I don't think this is worthwhile.)",
              "createdAt": "2020-03-05T17:21:56Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5Nzg2Mjcy",
          "commit": {
            "abbreviatedOid": "18831c7"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-05T17:53:03Z",
          "updatedAt": "2020-03-05T17:53:04Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Agreed. I'd drop this sentence.",
              "createdAt": "2020-03-05T17:53:04Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5Nzg3NDMy",
          "commit": {
            "abbreviatedOid": "18831c7"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks, @enygren! This looks good, pending suggestions (and in particular the bit about server suite preference).",
          "createdAt": "2020-03-05T17:54:46Z",
          "updatedAt": "2020-03-05T17:54:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTg2NTMy",
          "commit": {
            "abbreviatedOid": "18831c7"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-05T23:32:23Z",
          "updatedAt": "2020-03-05T23:32:23Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "Sounds good.  Go ahead and drop that version in.",
              "createdAt": "2020-03-05T23:32:23Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTg2ODY3",
          "commit": {
            "abbreviatedOid": "18831c7"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-05T23:33:23Z",
          "updatedAt": "2020-03-05T23:33:23Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Sounds good to me to drop this.",
              "createdAt": "2020-03-05T23:33:23Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTg4Mjg0",
          "commit": {
            "abbreviatedOid": "18831c7"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-05T23:37:22Z",
          "updatedAt": "2020-03-05T23:37:23Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "How do we want to resolve ambiguity here?  ie, if alpn=h3 (and implicit http/1.1) why would a client prefer to connect over QUIC?  I don't think we really want it to be an unordered set?",
              "createdAt": "2020-03-05T23:37:23Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMDAzNzI2",
          "commit": {
            "abbreviatedOid": "18831c7"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T00:19:43Z",
          "updatedAt": "2020-03-06T00:19:43Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "I think that it's fine to say that this is an expression of the server's preferences.\r\n\r\nOrdering relative to the default is another reason why I would prefer to see no default value.",
              "createdAt": "2020-03-06T00:19:43Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMDA0MTc2",
          "commit": {
            "abbreviatedOid": "18831c7"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T00:20:59Z",
          "updatedAt": "2020-03-06T00:21:00Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "One caution there: \"For example, when using a SvcFieldValue with an \"alpn\" of \"h2\", the client MAY also\" has a \"MAY\" in a \"For example\".  The word \"could\" is better.",
              "createdAt": "2020-03-06T00:20:59Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNjE3NTUw",
          "commit": {
            "abbreviatedOid": "4ed728e"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T20:49:46Z",
          "updatedAt": "2020-03-06T20:49:46Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "OK, I added a marker.",
              "createdAt": "2020-03-06T20:49:46Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNjE3Nzgz",
          "commit": {
            "abbreviatedOid": "4ed728e"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T20:50:11Z",
          "updatedAt": "2020-03-06T20:50:12Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "Done",
              "createdAt": "2020-03-06T20:50:12Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNjE3ODcy",
          "commit": {
            "abbreviatedOid": "4ed728e"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T20:50:23Z",
          "updatedAt": "2020-03-06T20:50:23Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Done",
              "createdAt": "2020-03-06T20:50:23Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNDY3MDk0",
          "commit": {
            "abbreviatedOid": "4ed728e"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Minor corrections",
          "createdAt": "2020-03-09T19:28:30Z",
          "updatedAt": "2020-03-09T19:33:32Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "```suggestion\r\nALPN set does not contain any compatible protocol suites.  To ensure\r\n```",
              "createdAt": "2020-03-09T19:28:30Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            },
            {
              "originalPosition": 126,
              "body": "```suggestion\r\nEach scheme that uses this SvcParamKey defines a\r\n```",
              "createdAt": "2020-03-09T19:29:01Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            },
            {
              "originalPosition": 219,
              "body": "```suggestion\r\n| 1           | alpn            | Additional supported protocols  | (This document) |\r\n```",
              "createdAt": "2020-03-09T19:31:45Z",
              "updatedAt": "2020-03-09T19:34:38Z"
            }
          ]
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "e8966ec2f0b94572380328a9857bb04c37233706",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-alpn-revisited",
      "headRefOid": "a720d38cae0e73517fac6f3193cdca3c1b0e26df",
      "mergeCommit": {
        "oid": "db3e29b4e108a3c13fa7ec6e88ba56e391541b87"
      }
    },
    {
      "number": 118,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1ODI2MzUx",
      "title": "Simplify AliasForm wording",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/118",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The previous phrasing was redundant.",
      "createdAt": "2020-03-09T21:24:43Z",
      "updatedAt": "2020-06-11T02:49:19Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "db3e29b4e108a3c13fa7ec6e88ba56e391541b87",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-alias-wording",
      "headRefOid": "b43c17ad9bb930b073859829d452d6a9f1061995",
      "closedAt": "2020-06-11T02:24:49Z",
      "mergedAt": "2020-06-11T02:24:49Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "c22b30623f664504283ca5094ccb83d1f1d77c94"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> @ 3600 IN SVBC foo\r\n> \r\n> should be perfectly fine in a master file.\r\n\r\nGood point.  I've updated the PR to allow that.",
          "createdAt": "2020-03-10T02:04:37Z",
          "updatedAt": "2020-03-10T02:04:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNTc1OTQ4",
          "commit": {
            "abbreviatedOid": "92fc430"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "\"full-qualified\" is redundant in a DNS record.   All domain names in DNS records are fully qualified.\r\n\r\nAdditionally are you really wanting to tell master file parsers that they can't use a relative name in the master file.\r\n\r\n@ 3600 IN SVBC foo\r\n\r\nshould be perfectly fine in a master file.",
          "createdAt": "2020-03-09T22:40:57Z",
          "updatedAt": "2020-03-09T22:40:57Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNDMyMDE3",
          "commit": {
            "abbreviatedOid": "b43c17a"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I guess adding the comment about the encoding of \".\" earlier would be redundant?  This is fine for now unless we get feedback.",
          "createdAt": "2020-04-13T20:54:25Z",
          "updatedAt": "2020-06-11T02:24:41Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "If we're going to have this special handling should we also mention it up in the wire format definition?  For example earlier:\r\n\r\n* the uncompressed, fully-qualified SvcDomainName, represented as a sequence of length-prefixed labels as in Section 3.1 of {{!RFC1035}}.  For the special case of a SvcDomainName with the value of \".\" (see {{svcdomainnamedot}}) this is represented as a single zero-legth label.",
              "createdAt": "2020-04-13T20:54:25Z",
              "updatedAt": "2020-06-11T02:24:41Z"
            },
            {
              "originalPosition": 32,
              "body": "(Did we want to make this addition?  Looks good otherwise.)",
              "createdAt": "2020-05-14T02:47:36Z",
              "updatedAt": "2020-06-11T02:24:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NTU2OTI4",
          "commit": {
            "abbreviatedOid": "b43c17a"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-11T02:49:19Z",
          "updatedAt": "2020-06-11T02:49:19Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "From an encoding point of view, this isn't a special case.  The encoding of \".\" is always the zero-length label in DNS.\r\n\r\nThere's a logical special case here (\".\" means the RR name), but I don't think we need to repeat that more than we already do.",
              "createdAt": "2020-06-11T02:49:19Z",
              "updatedAt": "2020-06-11T02:49:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 119,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1ODMwMjQ4",
      "title": "Remove redundant requirement on AliasForm values",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/119",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-09T21:35:15Z",
      "updatedAt": "2020-03-10T01:34:43Z",
      "closedAt": "2020-03-10T01:34:39Z",
      "mergedAt": "2020-03-10T01:34:39Z",
      "mergedBy": "bemasc",
      "comments": [],
      "reviews": [],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "bemasc-alias-wording",
      "baseRefOid": "92fc43010801eff33479df80461de07a6b834f16",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-alias-dot",
      "headRefOid": "086b1c0bc69ebdcbc763ef5243ac17f9f5cd2390",
      "mergeCommit": {
        "oid": "590cc7d90672baaeb554b571c70c1fed6d4d52cb"
      }
    },
    {
      "number": 126,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1ODkyNzU5",
      "title": "Add missing SvcFieldPriority",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/126",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #121",
      "createdAt": "2020-03-10T01:33:49Z",
      "updatedAt": "2020-04-13T20:48:02Z",
      "closedAt": "2020-04-13T20:48:01Z",
      "mergedAt": "2020-04-13T20:48:01Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNDI3OTEw",
          "commit": {
            "abbreviatedOid": "077e8b8"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-13T20:47:56Z",
          "updatedAt": "2020-04-13T20:47:56Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "db3e29b4e108a3c13fa7ec6e88ba56e391541b87",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-missing-priority",
      "headRefOid": "077e8b82a989e49a4979d5f4d13924c89cbda684",
      "mergeCommit": {
        "oid": "c4ca7f85fe3c45bcf837430e5cb148d5831881e8"
      }
    },
    {
      "number": 127,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg2NzIzNzQ2",
      "title": "Change \"ESNI\" to \"ECHO\" to match tls-esni-06",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/127",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-11T14:28:53Z",
      "updatedAt": "2020-05-13T03:50:50Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "b33e43e0640829e0c6491ff06e61598da00a8ede",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-echo",
      "headRefOid": "b0fdcad8400fa7381e55e5b13471b50eea859e30",
      "closedAt": "2020-05-13T03:50:50Z",
      "mergedAt": "2020-05-13T03:50:50Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "65ab9f5c91b53c31a046a16c36b9381d4315d3bd"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> Did we intend to remove \"## Differences from the proposed ESNI record \"?\r\n\r\nI removed it because the ESNI record proposal no longer appears in the ESNI (now ECHO) draft, so there's no longer anything to compare against.  Ultimately, I hope to get rid of all of these comparisons before RFC.\r\n\r\n> Would we be better off with calling this \"tlsecho\" instead of \"echoconfig\" ?\r\n(I think either is fine.)\r\n\r\nI prefer \"echoconfig\", since (a) it's closer to the ECHO draft terminology, and (b) it avoids possible confusion around TLS vs QUIC.",
          "createdAt": "2020-04-30T02:23:58Z",
          "updatedAt": "2020-04-30T02:23:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNTQ3NTk2",
          "commit": {
            "abbreviatedOid": "9283afa"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-12T13:21:12Z",
          "updatedAt": "2020-03-12T13:21:12Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "ECHO uses `ECHOConfig` to carry this data -- should we do the same here?",
              "createdAt": "2020-03-12T13:21:12Z",
              "updatedAt": "2020-05-13T02:19:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNTkzNTkx",
          "commit": {
            "abbreviatedOid": "9283afa"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-12T14:15:53Z",
          "updatedAt": "2020-03-12T14:15:53Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Given \"echo\" has other meetings, that's probably a good plan. \"echoconfig\" is a hair longer but a more unique string.",
              "createdAt": "2020-03-12T14:15:53Z",
              "updatedAt": "2020-05-13T02:19:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczODUxMDU3",
          "commit": {
            "abbreviatedOid": "3595076"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-12T19:44:44Z",
          "updatedAt": "2020-03-12T19:44:44Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Done",
              "createdAt": "2020-03-12T19:44:44Z",
              "updatedAt": "2020-05-13T02:19:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNDI3NjY2",
          "commit": {
            "abbreviatedOid": "c861788"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Did we intend to remove \"## Differences from the proposed ESNI record \"?\r\n\r\nWould we be better off with calling this \"tlsecho\" instead of \"echoconfig\" ?\r\n(I think either is fine.)",
          "createdAt": "2020-04-13T20:47:34Z",
          "updatedAt": "2020-04-13T20:47:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNTY5MTMy",
          "commit": {
            "abbreviatedOid": "b0fdcad"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Merging now and we can update if ECHO gets renamed.",
          "createdAt": "2020-05-13T03:50:44Z",
          "updatedAt": "2020-05-13T03:50:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 128,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk5OTkyOTky",
      "title": "Document why SVCB is a single type",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/128",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #125 ",
      "createdAt": "2020-04-07T01:54:35Z",
      "updatedAt": "2020-04-13T20:35:12Z",
      "closedAt": "2020-04-13T20:35:12Z",
      "mergedAt": "2020-04-13T20:35:12Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNDE5NzUx",
          "commit": {
            "abbreviatedOid": "311a4c3"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-13T20:35:06Z",
          "updatedAt": "2020-04-13T20:35:06Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "bemasc-echo",
      "baseRefOid": "35950761add3ba218d89826afbe0c4bb2cb941a6",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-twotypes",
      "headRefOid": "311a4c3586d4584f0d39e2df57a01216a239d5e8",
      "mergeCommit": {
        "oid": "c861788038df1a2672d41525cade47fa2dc7272b"
      }
    },
    {
      "number": 129,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk5OTk2ODQ0",
      "title": "Improve non-HTTP example text",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/129",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #124",
      "createdAt": "2020-04-07T02:11:43Z",
      "updatedAt": "2020-04-14T03:25:25Z",
      "closedAt": "2020-04-14T03:25:25Z",
      "mergedAt": "2020-04-14T03:25:25Z",
      "mergedBy": "enygren",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Done",
          "createdAt": "2020-04-13T22:23:43Z",
          "updatedAt": "2020-04-13T22:23:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNDE4OTg4",
          "commit": {
            "abbreviatedOid": "5b9f64d"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Can we remove the two words \"like\" before the examples?  (editorial nit)\r\nOtherwise seems fine to merge.",
          "createdAt": "2020-04-13T20:33:52Z",
          "updatedAt": "2020-04-13T20:33:52Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNTc4NzM3",
          "commit": {
            "abbreviatedOid": "16ab7a0"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-14T03:25:12Z",
          "updatedAt": "2020-04-14T03:25:12Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "bemasc-echo",
      "baseRefOid": "35950761add3ba218d89826afbe0c4bb2cb941a6",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-zones",
      "headRefOid": "16ab7a0d13cda774bd736ff5f6b8784376414fbf",
      "mergeCommit": {
        "oid": "ca8def2904fe6cbbe11fcb6cb2c7ecaed420afdf"
      }
    },
    {
      "number": 131,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAyNzc0NTQx",
      "title": "Improve description of IP hint requirements",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/131",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-13T18:28:44Z",
      "updatedAt": "2020-04-13T20:31:39Z",
      "closedAt": "2020-04-13T20:31:39Z",
      "mergedAt": "2020-04-13T20:31:39Z",
      "mergedBy": "enygren",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNDE3NTA5",
          "commit": {
            "abbreviatedOid": "a448658"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-13T20:31:34Z",
          "updatedAt": "2020-04-13T20:31:34Z",
          "comments": []
        }
      ],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "db3e29b4e108a3c13fa7ec6e88ba56e391541b87",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-hint",
      "headRefOid": "a448658375b60947252e7cade771889f24c6ee51",
      "mergeCommit": {
        "oid": "062727fb72474524a50dbc21ae3815b0798a4b98"
      }
    },
    {
      "number": 137,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA2MzEzODM5",
      "title": "Fix textual error: SvcParam -> SvcFieldValue",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/137",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-20T21:31:31Z",
      "updatedAt": "2020-05-07T21:00:25Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "c4ca7f85fe3c45bcf837430e5cb148d5831881e8",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-correction",
      "headRefOid": "9c928e9b7473d1e58bf3df770ec559155528b052",
      "closedAt": "2020-05-07T21:00:25Z",
      "mergedAt": "2020-05-07T21:00:25Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "b33e43e0640829e0c6491ff06e61598da00a8ede"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3ODMyOTM4",
          "commit": {
            "abbreviatedOid": "9c928e9"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-07T21:00:20Z",
          "updatedAt": "2020-05-07T21:00:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 139,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA2NDA4NTIw",
      "title": "Fix up ABNF to comply with RFC5234",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/139",
      "state": "MERGED",
      "author": "moonshiner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "in 5234, the rulename says it must contain a \"combination of alphabetics, digits, and hyphens (dashes)\"\r\n\r\nupdated ALPHA_LC\r\n\r\nalso, %5d-%FF was slightly incorrect.   ",
      "createdAt": "2020-04-21T02:59:32Z",
      "updatedAt": "2020-04-21T03:03:01Z",
      "closedAt": "2020-04-21T03:03:01Z",
      "mergedAt": "2020-04-21T03:03:01Z",
      "mergedBy": "bemasc",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": ":+1: ",
          "createdAt": "2020-04-21T03:02:56Z",
          "updatedAt": "2020-04-21T03:02:56Z"
        }
      ],
      "reviews": [],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "c4ca7f85fe3c45bcf837430e5cb148d5831881e8",
      "headRepository": "moonshiner/dns-alt-svc",
      "headRefName": "tjw-fix-abnf",
      "headRefOid": "18b57fd64fef24f20e4aa06f6ac2ff630b39d783",
      "mergeCommit": {
        "oid": "bfecec9cc95729cae973d57a89705560e7622544"
      }
    },
    {
      "number": 140,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA4MDE2MzY1",
      "title": "Clarify serialization of values of unknown SvcParamKeys",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/140",
      "state": "MERGED",
      "author": "DesWurstes",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I've added the following:\r\n\r\n```\r\nWhen decoding values of unrecognized keys in the presentation format:\r\n\r\n* a character other than \"\\\" represents its ASCII value in wire format.\r\n* the character \"\\\" followed by three decimal digits, up to 255, represents\r\n  an octet in the wire format.\r\n* the character \"\\\" followed by any allowed character, except a decimal digit,\r\n  represents the subsequent character's ASCII value.\r\n\r\n```\r\nand some other changes as discussed with bemasc in https://github.com/MikeBishop/dns-alt-svc/pull/140/commits/c69812c542fcdce466717f2f55e6ec0a5966e740\r\n\r\nPossible todo:\r\nTODO remove outside ascii characters from alpn, inherit escaping from values of private keys\r\n\r\n---\r\nResolved questions:\r\n\r\nAnd escaped alpn values in the presentation format can contain characters outside the ASCII range, non-visible characters or even the null character. Should I change that too?\r\n\r\nMoreover, some alpn values are in the gray area: They fit in 255 octets in wire format, but they are longer than 255 characters in the presentation format. (For example `,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,`) We should ban those alpn values too?\r\n\r\nSimilarly, *The presentation value of \"alpn\" is a comma-separated list of one or more \"alpn-id\"s.*, It should say at least one alpn value for the wire format as well?\r\n\r\nAnd since there's no requirement about the order of the pairs in the presentation format, duplicate pairs are allowed?\r\n\r\n---\r\nand I would like to add [my implementation](https://github.com/miekg/dns/pull/1067) and [this implementation](https://github.com/rthalley/dnspython/pull/452) to the list. That should be a separate pull request?",
      "createdAt": "2020-04-23T15:57:47Z",
      "updatedAt": "2020-05-01T14:18:27Z",
      "closedAt": "2020-04-30T18:45:19Z",
      "mergedAt": "2020-04-30T18:45:19Z",
      "mergedBy": "bemasc",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> And escaped alpn values in the presentation format can contain characters outside the ASCII range, non-visible characters or even the null character. Should I change that too?\r\n\r\nI guess so.  It's unlikely ever to be an issue (putting non-ASCII values in the ALPN registry would be very weird).\r\n\r\n> Moreover, some alpn values are in the gray area: They fit in 255 octets in wire format, but they are longer than 255 characters in the presentation format. (For example ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) We should ban those alpn values too?\r\n\r\nNo, we shouldn't have a length limit in the presentation format.\r\n\r\n> Similarly, The presentation value of \"alpn\" is a comma-separated list of one or more \"alpn-id\"s., It should say at least one alpn value for the wire format as well?\r\n\r\nIf you would prefer to make that a wire format syntax error, I'm fine with that.  I don't think it does any harm, but I suppose it's one less weird variation that could go unnoticed.\r\n\r\n> And since there's no requirement about the order of the pairs in the presentation format, duplicate pairs are allowed?\r\n\r\nNo, duplicate pairs are not allowed in the presentation format.  If the text is unclear on that point, please suggest a clarification.",
          "createdAt": "2020-04-30T02:20:43Z",
          "updatedAt": "2020-04-30T02:20:43Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": ":+1: ",
          "createdAt": "2020-04-30T18:45:11Z",
          "updatedAt": "2020-04-30T18:45:11Z"
        },
        {
          "author": "DesWurstes",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bemasc Thanks, but I've just found an undocumented feature/bug in markdown. This [webpage which I found from Github help pages says](https://daringfireball.net/projects/markdown/syntax#backslash), that the \\ escapes certain characters, which don't include double quotes. However the backslash in the output isn't rendered, it only escapes the next \". So **could you please replace the \\ in [those lines](https://github.com/MikeBishop/dns-alt-svc/blame/master/draft-ietf-dnsop-svcb-httpssvc.md#L396-L403) with \\\\\\\\**? Or is it easier for you if I open a pull request?",
          "createdAt": "2020-05-01T07:26:08Z",
          "updatedAt": "2020-05-01T07:26:29Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "It would be easier if you could get it rendering the way you want and send a PR.  Thanks!",
          "createdAt": "2020-05-01T14:18:27Z",
          "updatedAt": "2020-05-01T14:18:27Z"
        }
      ],
      "reviews": [],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "bfecec9cc95729cae973d57a89705560e7622544",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "c69812c542fcdce466717f2f55e6ec0a5966e740",
      "mergeCommit": {
        "oid": "f44f60a9abd9a5b33c13ac5709f61f39ad12eb1c"
      }
    },
    {
      "number": 141,
      "id": "MDExOlB1bGxSZXF1ZXN0NDExODA0OTI2",
      "title": "Clarifications to the key-value definition text",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/141",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #136",
      "createdAt": "2020-04-30T19:56:58Z",
      "updatedAt": "2020-05-13T03:51:37Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "f44f60a9abd9a5b33c13ac5709f61f39ad12eb1c",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-kv-text",
      "headRefOid": "e573f8f2eea555cbad86c9e223bcee3d2bef80c6",
      "closedAt": "2020-05-13T03:51:37Z",
      "mergedAt": "2020-05-13T03:51:37Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "011c37ccc3b15331c0ef353ddf1702f45a324a59"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3ODMwODk2",
          "commit": {
            "abbreviatedOid": "45dcf55"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good other than the comment above about comma nesting being confusing.",
          "createdAt": "2020-05-07T20:57:21Z",
          "updatedAt": "2020-05-07T20:58:22Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "The number of commas here is confusing.  Is there a way to reword this?\r\n\"When the value is omitted, or both the value and the \"=\" are omittied\", then the presentation value is the empty string.\"",
              "createdAt": "2020-05-07T20:57:21Z",
              "updatedAt": "2020-05-13T03:31:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNTY0MDM1",
          "commit": {
            "abbreviatedOid": "e573f8f"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-13T03:32:10Z",
          "updatedAt": "2020-05-13T03:32:11Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Done",
              "createdAt": "2020-05-13T03:32:10Z",
              "updatedAt": "2020-05-13T03:32:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNTY5MzU4",
          "commit": {
            "abbreviatedOid": "e573f8f"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-13T03:51:31Z",
          "updatedAt": "2020-05-13T03:51:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 142,
      "id": "MDExOlB1bGxSZXF1ZXN0NDExODA5MTg3",
      "title": "Move examples to after the specification",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/142",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This has been requested by multiple reviewers.\r\n\r\nFixes #135",
      "createdAt": "2020-04-30T20:06:53Z",
      "updatedAt": "2020-05-14T02:43:19Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "3dab5b9dc61b48877b39e7cd0459b43ca2e91bd0",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-move-examples",
      "headRefOid": "696a7476c4e789c54c2235c8d6e9ffe9b56a6096",
      "closedAt": "2020-05-14T02:43:19Z",
      "mergedAt": "2020-05-14T02:43:18Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "80624f4a7d0a7b5f65f5f5de37685598f65233cb"
      },
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "(I'll let you resolve conflicts on this one first since it may be easier to delete and re-do than safely resolve?)",
          "createdAt": "2020-05-13T03:58:56Z",
          "updatedAt": "2020-05-13T03:58:56Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks. Resolved!",
          "createdAt": "2020-05-14T00:55:47Z",
          "updatedAt": "2020-05-14T00:55:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNDI3ODY4",
          "commit": {
            "abbreviatedOid": "696a747"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-14T02:43:12Z",
          "updatedAt": "2020-05-14T02:43:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 143,
      "id": "MDExOlB1bGxSZXF1ZXN0NDExODExMjEx",
      "title": "Add warning text about non-default ports",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/143",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #134",
      "createdAt": "2020-04-30T20:11:48Z",
      "updatedAt": "2020-05-13T03:53:50Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "011c37ccc3b15331c0ef353ddf1702f45a324a59",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-ports",
      "headRefOid": "75621eb607e54b991429c4bdf1d704bf06896746",
      "closedAt": "2020-05-13T03:53:50Z",
      "mergedAt": "2020-05-13T03:53:50Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "3dab5b9dc61b48877b39e7cd0459b43ca2e91bd0"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've adjusted the wording similar to your suggestion",
          "createdAt": "2020-05-13T03:22:06Z",
          "updatedAt": "2020-05-13T03:22:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3Nzg5MTA0",
          "commit": {
            "abbreviatedOid": "51b5955"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Maybe:\r\n\"If port-restricting firewalls are in place between some client and the service\r\nendpoint, changing the port number can cause those clients to lose access to the service, so operators should exercise caution when using this SvcParamKey with non-default ports.\"\r\n?",
          "createdAt": "2020-05-07T19:54:17Z",
          "updatedAt": "2020-05-07T19:56:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNTY5NjI3",
          "commit": {
            "abbreviatedOid": "b21d55f"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-13T03:52:32Z",
          "updatedAt": "2020-05-13T03:52:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNTY5OTA4",
          "commit": {
            "abbreviatedOid": "75621eb"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-13T03:53:37Z",
          "updatedAt": "2020-05-13T03:53:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 144,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyMTU3ODk5",
      "title": "Clean up my rendering mess",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/144",
      "state": "MERGED",
      "author": "DesWurstes",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "@bemasc ",
      "createdAt": "2020-05-01T14:43:30Z",
      "updatedAt": "2020-05-01T16:03:03Z",
      "closedAt": "2020-05-01T16:03:03Z",
      "mergedAt": "2020-05-01T16:03:03Z",
      "mergedBy": "bemasc",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": ":+1: ",
          "createdAt": "2020-05-01T16:02:57Z",
          "updatedAt": "2020-05-01T16:02:57Z"
        }
      ],
      "reviews": [],
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "f44f60a9abd9a5b33c13ac5709f61f39ad12eb1c",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "e4137f4c645ef9b6dec1714ae8b22fcbdbcc4fea",
      "mergeCommit": {
        "oid": "366586190d9ea7b00296e54ca3741f5dadde6d52"
      }
    },
    {
      "number": 145,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyNTE1NTE3",
      "title": "Add some text clarifying echoconfig parameter usage.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/145",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "cc @bemasc ",
      "createdAt": "2020-05-02T22:15:19Z",
      "updatedAt": "2020-05-15T01:30:40Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "bemasc-echo",
      "baseRefOid": "b0fdcad8400fa7381e55e5b13471b50eea859e30",
      "headRepository": "chris-wood/dns-alt-svc",
      "headRefName": "caw/echo-extension-guidance",
      "headRefOid": "972c053ecca73b1c1fe82814bc6800855f7e547b",
      "closedAt": "2020-05-15T01:30:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "This clarification has been made in #148.",
          "createdAt": "2020-05-15T01:30:40Z",
          "updatedAt": "2020-05-15T01:30:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTY2ODM4",
          "commit": {
            "abbreviatedOid": "dd22a88"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-02T23:00:28Z",
          "updatedAt": "2020-05-02T23:04:48Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nextensions. That extension mechanism SHOULD NOT be used for any parameter that\r\n```",
              "createdAt": "2020-05-02T23:00:29Z",
              "updatedAt": "2020-05-07T14:49:24Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nother than \"echoconfig\" which affects the TLS ClientHello is directed at the\r\n```",
              "createdAt": "2020-05-02T23:00:52Z",
              "updatedAt": "2020-05-07T14:49:24Z"
            },
            {
              "originalPosition": 8,
              "body": "I think \"connection properties\" is not clear enough.  To me, the only way an ECHOConfig extension could not affect \"connection properties\" would be if it were ignored.",
              "createdAt": "2020-05-02T23:04:05Z",
              "updatedAt": "2020-05-07T14:49:24Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nother than \"echoconfig\" that affects the TLS ClientHello is directed at the\r\n```",
              "createdAt": "2020-05-02T23:04:36Z",
              "updatedAt": "2020-05-07T14:49:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MDY3NDI3",
          "commit": {
            "abbreviatedOid": "a7d68ef"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-04T14:56:14Z",
          "updatedAt": "2020-05-04T14:56:14Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "That may be true. How might you rephrase this?",
              "createdAt": "2020-05-04T14:56:14Z",
              "updatedAt": "2020-05-07T14:49:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MDg5NDU0",
          "commit": {
            "abbreviatedOid": "523d497"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-04T15:20:02Z",
          "updatedAt": "2020-05-04T15:20:03Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I took a stab at refactoring this. What do you think?",
              "createdAt": "2020-05-04T15:20:02Z",
              "updatedAt": "2020-05-07T14:49:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MTgwNjUz",
          "commit": {
            "abbreviatedOid": "523d497"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-04T17:08:33Z",
          "updatedAt": "2020-05-04T17:11:34Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nThe value of this parameter and any included ECHOConfig extensions are directed\r\n```",
              "createdAt": "2020-05-04T17:08:33Z",
              "updatedAt": "2020-05-07T14:49:24Z"
            },
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nClientHello when ECHO is in use SHOULD use other SVCB parameters, and any other\r\nrelevant SVCB parameters SHALL be applied to the inner ClientHello.\r\n```",
              "createdAt": "2020-05-04T17:10:42Z",
              "updatedAt": "2020-05-07T14:49:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MTg3ODkw",
          "commit": {
            "abbreviatedOid": "9e57f8d"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-04T17:18:20Z",
          "updatedAt": "2020-05-04T17:18:21Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I'd prefer to keep these separate sentences.",
              "createdAt": "2020-05-04T17:18:20Z",
              "updatedAt": "2020-05-07T14:49:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MTkwMzI2",
          "commit": {
            "abbreviatedOid": "9e57f8d"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-04T17:21:34Z",
          "updatedAt": "2020-05-04T17:21:35Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "That's fine with me, but I do think we ought to mention the second requirement somewhere in this draft.   (Currently it's only in the ECHO draft.)",
              "createdAt": "2020-05-04T17:21:34Z",
              "updatedAt": "2020-05-07T14:49:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MTk0NjUw",
          "commit": {
            "abbreviatedOid": "9e57f8d"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-04T17:27:19Z",
          "updatedAt": "2020-05-04T17:27:19Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "\ud83d\udc4d Do you want to merge and then make that change? (This PR targets your ESNI->ECHO branch.)",
              "createdAt": "2020-05-04T17:27:19Z",
              "updatedAt": "2020-05-07T14:49:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MjAzNTAw",
          "commit": {
            "abbreviatedOid": "9e57f8d"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-04T17:39:16Z",
          "updatedAt": "2020-05-04T17:39:16Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I think it's time for another round of review with the other coauthors.",
              "createdAt": "2020-05-04T17:39:16Z",
              "updatedAt": "2020-05-07T14:49:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2OTA4NTY2",
          "commit": {
            "abbreviatedOid": "9e57f8d"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-06T19:09:18Z",
          "updatedAt": "2020-05-06T19:09:19Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Calling @MikeBishop and @enygren!",
              "createdAt": "2020-05-06T19:09:19Z",
              "updatedAt": "2020-05-07T14:49:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NTA5MTQ3",
          "commit": {
            "abbreviatedOid": "9e57f8d"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-07T14:08:54Z",
          "updatedAt": "2020-05-07T14:08:54Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I feel like this discussion is about which way to overspecify.\r\n\r\nThe outer ClientHello is an artifact of ECHO: essentially fake and deliberately public.  Therefore, it's entirely legitimate to populate it with public information, e.g. information anyone can obtain over DNS anyway.  It's also legitimate to populate it with junk or lie.  Those are implementation choices; we don't need to specify them.\r\n\r\nThe contents of the SVCB record are a server's declarations about its own capabilities; they are useful in the inner ClientHello and might be usable in the outer ClientHello if the implementation so chooses, since they're public anyway.  This particular parameter is about how to conceal the \"true\" ClientHello using ECHO.  The point of this paragraph is that you don't need this parameter to construct the inner ClientHello; you would construct the inner one as if this parameter weren't there, then encapsulate it if you have an EchoConfig.",
              "createdAt": "2020-05-07T14:08:54Z",
              "updatedAt": "2020-05-07T14:49:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NTIxMzU4",
          "commit": {
            "abbreviatedOid": "9e57f8d"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-07T14:21:12Z",
          "updatedAt": "2020-05-07T14:21:12Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "@MikeBishop, I don't disagree with what you said, but... are you looking for a change? Suggestions welcome. :-)",
              "createdAt": "2020-05-07T14:21:12Z",
              "updatedAt": "2020-05-07T14:49:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NTQxNDU1",
          "commit": {
            "abbreviatedOid": "9e57f8d"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-07T14:40:50Z",
          "updatedAt": "2020-05-07T14:40:51Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nconstruction of the inner TLS ClientHello.\r\n```\r\nI'm suggesting we can do without this sentence entirely.",
              "createdAt": "2020-05-07T14:40:51Z",
              "updatedAt": "2020-05-07T14:49:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NTQ5OTE0",
          "commit": {
            "abbreviatedOid": "9e57f8d"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-07T14:49:20Z",
          "updatedAt": "2020-05-07T14:49:20Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Lovely -- thanks!",
              "createdAt": "2020-05-07T14:49:20Z",
              "updatedAt": "2020-05-07T14:49:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3ODI3OTAz",
          "commit": {
            "abbreviatedOid": "972c053"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-07T20:52:53Z",
          "updatedAt": "2020-05-07T20:52:54Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "The wording \"are directed at\" tripped me up a few times when first reading this.  I wonder if \"influence the construction of\" or similar might be more readable? \r\n\r\nWould giving an illustrative example help for people not as familiar with ECHO?  (\"For example, the echoconfig will specify the SNI and ALPN values to use in ClientHelloOuter but will have no impact on the SNI and ALPN values used in ClientHelloInner.\")",
              "createdAt": "2020-05-07T20:52:53Z",
              "updatedAt": "2020-05-07T20:52:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNTA0ODA4",
          "commit": {
            "abbreviatedOid": "972c053"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-13T00:09:04Z",
          "updatedAt": "2020-05-13T00:09:04Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "> The wording \"are directed at\" tripped me up a few times when first reading this. I wonder if \"influence the construction of\" or similar might be more readable?\r\n\r\nThat's a great suggestion. We should incorporate it.\r\n\r\n> Would giving an illustrative example help for people not as familiar with ECHO? \r\n\r\nProbably! @bemasc, do you want to take a crack at that? (I won't have time to get back to this PR for quite a while, I'm afraid.)",
              "createdAt": "2020-05-13T00:09:04Z",
              "updatedAt": "2020-05-13T00:09:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNTQ1NjAx",
          "commit": {
            "abbreviatedOid": "972c053"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-13T02:27:22Z",
          "updatedAt": "2020-05-13T02:27:23Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "OK, I gave it a try: https://github.com/MikeBishop/dns-alt-svc/pull/148",
              "createdAt": "2020-05-13T02:27:23Z",
              "updatedAt": "2020-05-13T02:27:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 146,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE0NDA2Mzgz",
      "title": "Clarify reference to a default protocol",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/146",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-07T01:03:11Z",
      "updatedAt": "2020-05-07T19:52:19Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "366586190d9ea7b00296e54ca3741f5dadde6d52",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-tls-tcp",
      "headRefOid": "189657499b12b39c416efa374ff0e40f8b22c6f1",
      "closedAt": "2020-05-07T19:52:19Z",
      "mergedAt": "2020-05-07T19:52:19Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "4ed64d9988685391cb236f95c3131615f48e25fd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3Nzg3NTQx",
          "commit": {
            "abbreviatedOid": "1896574"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-07T19:52:09Z",
          "updatedAt": "2020-05-07T19:52:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 148,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE3MDc1MjU0",
      "title": "Explain inner vs. outer ClientHello",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/148",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As requested here: https://github.com/MikeBishop/dns-alt-svc/pull/145#discussion_r424102426",
      "createdAt": "2020-05-13T02:27:00Z",
      "updatedAt": "2020-05-15T01:30:09Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "3dab5b9dc61b48877b39e7cd0459b43ca2e91bd0",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-echo-guidance",
      "headRefOid": "6d5b630527986d41384b21217cd3796cc978c681",
      "closedAt": "2020-05-14T02:38:45Z",
      "mergedAt": "2020-05-14T02:38:45Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "d9d7e49bcf66daed9260c37bb6b456a7dbfb2f0c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNTcxMTk2",
          "commit": {
            "abbreviatedOid": "2fcc1b9"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-13T03:58:20Z",
          "updatedAt": "2020-05-13T03:58:21Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Do we want to add to the example that the ECHOConfig could specify a dummy ALPN TLS extension for the outer client hello (for middlebox compatibility) but it is ignored for connection establishment?  Similarly, explaining how SNI fits in here might be helpful to readers.  (ie, that the \"outer\" contains a dummy SNI from the ECHOConfig and the \"inner\" contains the SNI from the Origin.) ",
              "createdAt": "2020-05-13T03:58:20Z",
              "updatedAt": "2020-05-14T00:50:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMzkyNjA4",
          "commit": {
            "abbreviatedOid": "ca478f0"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-14T00:45:53Z",
          "updatedAt": "2020-05-14T00:45:53Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "> Do we want to add to the example that the ECHOConfig could specify a dummy ALPN TLS extension for the outer client hello (for middlebox compatibility) but it is ignored for connection establishment?\r\n\r\nI don't think this is a good place to speculate on possible future extensions to a different draft.  (I also think that particular extension is unlikely to happen any time soon.)\r\n\r\n> Similarly, explaining how SNI fits in here might be helpful to readers. (ie, that the \"outer\" contains a dummy SNI from the ECHOConfig and the \"inner\" contains the SNI from the Origin.)\r\n\r\nAdded.\r\n",
              "createdAt": "2020-05-14T00:45:53Z",
              "updatedAt": "2020-05-14T00:50:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNDI2NDMy",
          "commit": {
            "abbreviatedOid": "6d5b630"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-14T02:37:58Z",
          "updatedAt": "2020-05-14T02:37:59Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Maybe I misread the ECHO draft, but I thought this was allowed? It's given as an example. But may be more detail than is needed here.",
              "createdAt": "2020-05-14T02:37:58Z",
              "updatedAt": "2020-05-14T02:37:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNDI2NjIy",
          "commit": {
            "abbreviatedOid": "6d5b630"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-14T02:38:40Z",
          "updatedAt": "2020-05-14T02:38:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 150,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxNTQ3Nzk1",
      "title": "Rename ECHO to ECH.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/150",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See https://github.com/tlswg/draft-ietf-tls-esni/pull/236/files for the related ECHO change.",
      "createdAt": "2020-05-21T19:50:04Z",
      "updatedAt": "2020-05-21T20:05:47Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "80624f4a7d0a7b5f65f5f5de37685598f65233cb",
      "headRepository": "chris-wood/dns-alt-svc",
      "headRefName": "caw/echo-to-ech",
      "headRefOid": "e09927ac003eb2ba6bd5e65756310b654b130498",
      "closedAt": "2020-05-21T20:05:32Z",
      "mergedAt": "2020-05-21T20:05:32Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "85717d7ddc6ae145da818fbed713ca0c1d78a176"
      },
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "(Looks good to me)",
          "createdAt": "2020-05-21T20:05:47Z",
          "updatedAt": "2020-05-21T20:05:47Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 151,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIyNTE2NDkw",
      "title": "Revise chain length limit description",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/151",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #57",
      "createdAt": "2020-05-25T02:43:35Z",
      "updatedAt": "2020-05-29T19:41:05Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "85717d7ddc6ae145da818fbed713ca0c1d78a176",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-limit",
      "headRefOid": "2f43dcb6156fca64f1aee8cb33c58e9e105147b5",
      "closedAt": "2020-05-29T19:41:04Z",
      "mergedAt": "2020-05-29T19:41:04Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "dc68db9bef708d22bb1ebd3bc6df40ca44c30d6c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMjM5OTQx",
          "commit": {
            "abbreviatedOid": "2f43dcb"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-29T19:40:59Z",
          "updatedAt": "2020-05-29T19:40:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 152,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI0MzM4MzQy",
      "title": "Use \"@\" for current origin, don't use the DNS root \".\" in example.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/152",
      "state": "MERGED",
      "author": "he32",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-28T08:41:58Z",
      "updatedAt": "2020-05-28T15:22:54Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "85717d7ddc6ae145da818fbed713ca0c1d78a176",
      "headRepository": "he32/dns-alt-svc",
      "headRefName": "example-fix",
      "headRefOid": "6b936f3fbdc3bceb89406a3d18605d118b98d34e",
      "closedAt": "2020-05-28T15:22:53Z",
      "mergedAt": "2020-05-28T15:22:53Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "1aa86cd4866dfd7c884c711e89908820b9ebeb80"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": ":+1: ",
          "createdAt": "2020-05-28T15:22:49Z",
          "updatedAt": "2020-05-28T15:22:49Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 153,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI0NDk4OTEz",
      "title": "Fix a couple of minor typos.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/153",
      "state": "MERGED",
      "author": "he32",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-28T13:49:04Z",
      "updatedAt": "2020-05-28T15:23:37Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "85717d7ddc6ae145da818fbed713ca0c1d78a176",
      "headRepository": "he32/dns-alt-svc",
      "headRefName": "typo-fix",
      "headRefOid": "d256e0b0b6fa5395e06a928d8b9be64f011e6c93",
      "closedAt": "2020-05-28T15:23:37Z",
      "mergedAt": "2020-05-28T15:23:37Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "6164ced2634e029b40929e262d0471103e49216a"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": ":+1: ",
          "createdAt": "2020-05-28T15:23:33Z",
          "updatedAt": "2020-05-28T15:23:33Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 155,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1NTI2MjUz",
      "title": "Clarify interaction with WebSocket",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/155",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This also covers the general case of WebSocket-like protocols.\r\n\r\nFixes #90",
      "createdAt": "2020-05-30T21:32:54Z",
      "updatedAt": "2020-06-11T02:22:29Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "dc68db9bef708d22bb1ebd3bc6df40ca44c30d6c",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-websocket",
      "headRefOid": "11e9efbd5adf334bf9607e3dd879414babd63e2f",
      "closedAt": "2020-06-11T02:22:29Z",
      "mergedAt": "2020-06-11T02:22:29Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "a91c02c5ec21adb5a349d88e63d6bf5b2130c770"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Coincidentally, we were looking at WebSockets recently for cookies. It's a mess. :-( Whether this definition of \"HTTP-based\" works is... unclear. RFC 6455 does *not* map WebSockets to its corresponding http/https scheme. It believes WebSockets is an entirely independent protocol with an HTTP-looking handshake for convenience.\r\n\r\n>   The WebSocket Protocol is an independent TCP-based protocol.  Its\r\n>   only relationship to HTTP is that its handshake is interpreted by\r\n>   HTTP servers as an Upgrade request.\r\n\r\nBut this is an unhelpful way to specify it and was probably a mistake. It doesn't tell you how WebSockets interacts with cookies, HTTP auth, or redirects, and led to a mess of interop issues.\r\n\r\nFetch, accordingly, [overrides this](https://fetch.spec.whatwg.org/#websocket-protocol) and [maps the schemes to HTTP](https://fetch.spec.whatwg.org/#websocket-opening-handshake). This is partially a no-op because cookies don't check schemes, but we should [fix that](https://tools.ietf.org/html/draft-west-cookie-incrementalism-01). At that point we'll be in a weird situation where, without the WHATWG override of the IETF spec, WebSockets' interactions with cookies will be somewhere between incorrect and insufficiently specified. :-(\r\n\r\nHow that translates to what this specification should do, I don't know. It may make sense to just special-case WebSockets and declare the RFC 6455 specification strategy was a mistake and we shouldn't do it again. Then again, that still means new \"webby\" protocols that are less HTTP-adjacent (WebTransport?) will require separate SVCB records, which also seems poor. Every extra thing we stick in the query (scheme, port, etc.) weakens the security benefits (HTTPS upgrade, ECH).",
          "createdAt": "2020-05-30T22:01:50Z",
          "updatedAt": "2020-05-30T22:02:47Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben Thanks for flagging the discrepancy.  I've tweaked the text to try to be more precise (without explaining the whole situation).",
          "createdAt": "2020-06-07T17:06:08Z",
          "updatedAt": "2020-06-07T17:06:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NTQ5MDE5",
          "commit": {
            "abbreviatedOid": "11e9efb"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-11T02:22:20Z",
          "updatedAt": "2020-06-11T02:22:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 156,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1NTI4MTYy",
      "title": "Clarify conditions for enabling HSTS",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/156",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #91",
      "createdAt": "2020-05-30T21:52:55Z",
      "updatedAt": "2020-06-11T14:32:57Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "dc68db9bef708d22bb1ebd3bc6df40ca44c30d6c",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-hsts-fallback",
      "headRefOid": "4cfb3035ed167a0ed86e99a8827f994555b5b842",
      "closedAt": "2020-06-11T14:32:57Z",
      "mergedAt": "2020-06-11T14:32:57Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "9d29bfc8d1b413294278c14310460e5de9857212"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This PR seems reasonable, though @enygren's comment has now confused me. What does fallback mean here? (Did you mean another comment of mine? Doesn't look like I've commented on #79.)",
          "createdAt": "2020-06-11T02:47:51Z",
          "updatedAt": "2020-06-11T02:47:51Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Oops, I meant #91   (no idea why the typo)",
          "createdAt": "2020-06-11T02:54:36Z",
          "updatedAt": "2020-06-11T02:54:36Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah. No, a fallback wouldn't make sense, both semantically and for security. Semantically, by the time you've done an HSTS-like upgrade, you've had to pop up many layers to trigger something like a redirect. That no longer looks like the HTTPSSVC vs. A/AAAA alternate routes. (The client needs to actually change the URL here.) And, in terms of security, if the network can undo the upgrade by blocking the HTTPS upgrade, what was the point? Maybe as well do a plain 302 redirect at that point.",
          "createdAt": "2020-06-11T05:02:06Z",
          "updatedAt": "2020-06-11T05:02:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NTQ4NDk5",
          "commit": {
            "abbreviatedOid": "1232c2d"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Did we want to allow clients to fallback?\r\nPerhaps I misunderstood @davidben's comment in #91.  David, do you have any concerns with where this lands?",
          "createdAt": "2020-06-11T02:20:40Z",
          "updatedAt": "2020-06-11T02:54:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4OTcyODY2",
          "commit": {
            "abbreviatedOid": "4cfb303"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-11T14:32:51Z",
          "updatedAt": "2020-06-11T14:32:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 157,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1NTMzNDc1",
      "title": "Clarify port-related requirements",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/157",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #111 and #122",
      "createdAt": "2020-05-30T22:53:11Z",
      "updatedAt": "2020-06-11T02:14:01Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "dc68db9bef708d22bb1ebd3bc6df40ca44c30d6c",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-port",
      "headRefOid": "f309c0d7e58ff2d00286400eb9d9e2f37f03844b",
      "closedAt": "2020-06-11T02:14:01Z",
      "mergedAt": "2020-06-11T02:14:01Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "2248c49c022e000afbfe40a90e5ab09f490926b6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NTQ2NDk0",
          "commit": {
            "abbreviatedOid": "f309c0d"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-11T02:13:55Z",
          "updatedAt": "2020-06-11T02:13:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 158,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1NTQxOTE1",
      "title": "Exclude parentheses from basic-visible",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/158",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #120",
      "createdAt": "2020-05-31T00:36:41Z",
      "updatedAt": "2020-06-11T14:37:31Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "dc68db9bef708d22bb1ebd3bc6df40ca44c30d6c",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-abnf",
      "headRefOid": "6e0e097ff4a86f8ff7cbf0d97e30b19ba27d410a",
      "closedAt": "2020-06-11T14:37:31Z",
      "mergedAt": "2020-06-11T14:37:30Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "4bc31b26ae28241145aa9a9512fda90b762ced97"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@marka63 Could you confirm that this addresses the ABNF problem in #120?",
          "createdAt": "2020-06-11T02:43:25Z",
          "updatedAt": "2020-06-11T02:43:25Z"
        },
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "It appears to.",
          "createdAt": "2020-06-11T08:05:43Z",
          "updatedAt": "2020-06-11T08:05:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NTQ0ODM0",
          "commit": {
            "abbreviatedOid": "6e0e097"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Might be good for someone who deeply understands this ABNF definition to review more deeply.",
          "createdAt": "2020-06-11T02:08:08Z",
          "updatedAt": "2020-06-11T02:08:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4OTc3MjA4",
          "commit": {
            "abbreviatedOid": "6e0e097"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Merged following @marka63's review",
          "createdAt": "2020-06-11T14:37:23Z",
          "updatedAt": "2020-06-11T14:37:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 159,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1NTQyNjc1",
      "title": "Clarify transport proxy behavior",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/159",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #147",
      "createdAt": "2020-05-31T00:46:32Z",
      "updatedAt": "2020-06-11T02:05:30Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "dc68db9bef708d22bb1ebd3bc6df40ca44c30d6c",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-proxy",
      "headRefOid": "c32458b34ffcb8330a19ec053b890cdb9ff2384c",
      "closedAt": "2020-06-11T02:05:30Z",
      "mergedAt": "2020-06-11T02:05:29Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "27bf3549b27475b4f67d7ff7d79bec6b50da9d32"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NTQ0MDEz",
          "commit": {
            "abbreviatedOid": "c32458b"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-11T02:05:22Z",
          "updatedAt": "2020-06-11T02:05:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 160,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1NzAxNDEy",
      "title": "Adjust CamelCase names",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/160",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This (purely editorial) change replaces the unambiguous but\r\nidiosyncratic CamelCase terms with capitalized standard terms.\r\nIt also removes some duplicated language and changes \"form\" to \"mode\",\r\nsince there is really only one SVCB wire format.\r\n\r\nRelevant issues: #99, #82",
      "createdAt": "2020-06-01T01:06:18Z",
      "updatedAt": "2020-07-13T17:12:11Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "ba6fef7b3ad0de83b12d6b2135cb5c16293a8b55",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-names",
      "headRefOid": "761fddaba42daa1ec31056583729f97690b4a974",
      "closedAt": "2020-07-13T17:12:11Z",
      "mergedAt": "2020-07-13T17:12:11Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "9a84da196629ad0e9a42f987c90c040f7170f2a8"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR is firmly in bikeshed territory, and has no particular deadline, so it's a lower priority than any substantive PRs.",
          "createdAt": "2020-06-01T01:08:01Z",
          "updatedAt": "2020-06-01T01:08:01Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sold yet.  It's an interesting idea, but I think there is value in using the camelcase names for unambiguous references to fields and forms.  Common terms have more chances for confusion and ambiguity.  This may be a style thing.  I'd be more in-favor of just simplifying some of the camelcase terms that are overly long.",
          "createdAt": "2020-06-11T02:03:53Z",
          "updatedAt": "2020-06-11T02:03:53Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @enygren that the more common names seem a bit too generic, and liable for confusion when referenced out of context. I'd prefer to keep with the existing style.",
          "createdAt": "2020-06-22T20:37:16Z",
          "updatedAt": "2020-06-22T20:37:16Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I've changed this PR to match the names discussed in #82, so the initial description comment is no longer accurate.",
          "createdAt": "2020-07-07T03:27:48Z",
          "updatedAt": "2020-07-07T03:27:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODQzNTA0",
          "commit": {
            "abbreviatedOid": "a98b5a7"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This is generally looking good.  My primary concern is whether we should use\r\nSvcParamKey/SvcParamValue (including using those in the ABNF) rather than key/value as normal English words.  The former is less ambiguous especially as both key and value have potential for confusion depending on the context they're used in.",
          "createdAt": "2020-07-12T03:43:26Z",
          "updatedAt": "2020-07-12T03:51:30Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\n3. SvcParams (optional): A list of key=value pairs\r\n   describing the alternative endpoint at\r\n   TargetName (only used in ServiceMode and otherwise ignored). \r\n   Described in {{svcparams}}.\r\n```",
              "createdAt": "2020-07-12T03:43:26Z",
              "updatedAt": "2020-07-13T04:15:22Z"
            },
            {
              "originalPosition": 640,
              "body": "```suggestion\r\nFollowing of HTTPS AliasMode RRs and CNAME aliases is unchanged from SVCB.\r\n```",
              "createdAt": "2020-07-12T03:49:39Z",
              "updatedAt": "2020-07-13T04:15:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTU5MTg1",
          "commit": {
            "abbreviatedOid": "5dab608"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-13T03:24:08Z",
          "updatedAt": "2020-07-13T03:24:08Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "While repetitive with what is below, this does provide important background context.  Should we see if we can include this even if we condense this down some?  Or just leave this as-is?",
              "createdAt": "2020-07-13T03:24:08Z",
              "updatedAt": "2020-07-13T04:15:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTU5NTY0",
          "commit": {
            "abbreviatedOid": "5dab608"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Almost there!",
          "createdAt": "2020-07-13T03:25:55Z",
          "updatedAt": "2020-07-13T03:40:14Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "```suggestion\r\nValues are in a format specific to the SvcParamKey.\r\n```",
              "createdAt": "2020-07-13T03:25:55Z",
              "updatedAt": "2020-07-13T04:15:22Z"
            },
            {
              "originalPosition": 108,
              "body": "Why did we drop the \"The presentation format for SvcFieldValue is a whitespace-separated list of key=value pairs\" ?  Having a textual description is helpful?\r\n\r\n",
              "createdAt": "2020-07-13T03:27:32Z",
              "updatedAt": "2020-07-13T04:15:22Z"
            },
            {
              "originalPosition": 109,
              "body": "```suggestion\r\nThe presentation format for SvcParams is a whitespace-separated\r\nlist of parameters which are either SvcParamKey=value pairs or \r\nstandalone SvcParamKey parameters.\r\nWhen the value is omitted, or both the value and\r\n```",
              "createdAt": "2020-07-13T03:29:20Z",
              "updatedAt": "2020-07-13T04:15:22Z"
            },
            {
              "originalPosition": 261,
              "body": "This is somewhat confusing in the new text as AliasMode can be an alias to a AAAA or A record.",
              "createdAt": "2020-07-13T03:33:59Z",
              "updatedAt": "2020-07-13T04:15:22Z"
            },
            {
              "originalPosition": 621,
              "body": "```suggestion\r\n* Number: SvcParamKey wire format numeric identifier (range 0-65535)\r\n```",
              "createdAt": "2020-07-13T03:38:08Z",
              "updatedAt": "2020-07-13T04:15:22Z"
            },
            {
              "originalPosition": 622,
              "body": "```suggestion\r\n* Name: Service ParamKey presentation name\r\n```",
              "createdAt": "2020-07-13T03:38:42Z",
              "updatedAt": "2020-07-13T04:15:22Z"
            },
            {
              "originalPosition": 627,
              "body": "```suggestion\r\nSvcParamKey entries to be added to this namespace\r\n```",
              "createdAt": "2020-07-13T03:39:25Z",
              "updatedAt": "2020-07-13T04:15:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTY1NTUw",
          "commit": {
            "abbreviatedOid": "5dab608"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-13T03:52:01Z",
          "updatedAt": "2020-07-13T04:04:30Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "OK, restored",
              "createdAt": "2020-07-13T03:52:02Z",
              "updatedAt": "2020-07-13T04:15:22Z"
            },
            {
              "originalPosition": 109,
              "body": "I've incorporated this adjustment at line 262 to avoid repetition.",
              "createdAt": "2020-07-13T03:56:54Z",
              "updatedAt": "2020-07-13T04:15:22Z"
            },
            {
              "originalPosition": 261,
              "body": "The old text arguably has the same problem.  Changed to \"AliasMode records only apply to queries for the specific RR type.\".",
              "createdAt": "2020-07-13T03:59:52Z",
              "updatedAt": "2020-07-13T04:15:22Z"
            },
            {
              "originalPosition": 622,
              "body": "Committed as \"SvcParamKey presentation name\"",
              "createdAt": "2020-07-13T04:04:26Z",
              "updatedAt": "2020-07-13T04:15:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NDQyNjE0",
          "commit": {
            "abbreviatedOid": "761fdda"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-13T17:12:03Z",
          "updatedAt": "2020-07-13T17:12:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 161,
      "id": "MDExOlB1bGxSZXF1ZXN0NDMyODAyOTUy",
      "title": "Clarify need for SNI",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/161",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #92 \r\n\r\n(text derived from rfc7838 and rfc7540 which have a similar requirement)",
      "createdAt": "2020-06-11T02:36:57Z",
      "updatedAt": "2020-06-11T03:30:40Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "c22b30623f664504283ca5094ccb83d1f1d77c94",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-sni",
      "headRefOid": "b24ef37471b2906081d1d19eca79e1d975a2be70",
      "closedAt": "2020-06-11T03:30:39Z",
      "mergedAt": "2020-06-11T03:30:39Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "b36fcc1b1198252d9214fb16a60c6b44ecc4df4c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NTU3OTY3",
          "commit": {
            "abbreviatedOid": "d262a88"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-11T02:52:44Z",
          "updatedAt": "2020-06-11T02:52:45Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nNote that the TLS SNI (and also the HTTP \"Host\" or \":authority\") will indicate \r\nthe origin, not the SvcDomainName.\r\n```",
              "createdAt": "2020-06-11T02:52:44Z",
              "updatedAt": "2020-06-11T02:56:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NTU5Njkx",
          "commit": {
            "abbreviatedOid": "b24ef37"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-11T02:58:43Z",
          "updatedAt": "2020-06-11T02:58:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 162,
      "id": "MDExOlB1bGxSZXF1ZXN0NDMyODA2NTU0",
      "title": "Different IANA policies for different SvcParamKey ranges",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/162",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #154",
      "createdAt": "2020-06-11T02:50:26Z",
      "updatedAt": "2020-06-11T02:55:45Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "c22b30623f664504283ca5094ccb83d1f1d77c94",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-iana-ranges",
      "headRefOid": "abc4f6f1128e3c39c1de9c3ddbbff053d5b7538a",
      "closedAt": "2020-06-11T02:55:45Z",
      "mergedAt": "2020-06-11T02:55:45Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "c1dcfcc0fe75febd76926ed410c164f2b5137954"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NTU4NzY0",
          "commit": {
            "abbreviatedOid": "abc4f6f"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-11T02:55:36Z",
          "updatedAt": "2020-06-11T02:55:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 163,
      "id": "MDExOlB1bGxSZXF1ZXN0NDMyODEyODgy",
      "title": "SVCB-Used HTTP header",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/163",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "future draft"
      ],
      "body": "Fixes #107 \r\nMay want working group discussion in dnsop and/or httpbis",
      "createdAt": "2020-06-11T03:15:39Z",
      "updatedAt": "2020-07-09T21:15:35Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "c1dcfcc0fe75febd76926ed410c164f2b5137954",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-svcb-used",
      "headRefOid": "740389a633ff6a16daceb9653048f4ebf16cef4d",
      "closedAt": "2020-07-09T21:15:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I would choose one option for the behavior, and leave it at MAY.  I also think we probably don't want to do this unless we can convince people that it's not a privacy risk at all.",
          "createdAt": "2020-06-11T03:58:00Z",
          "updatedAt": "2020-06-11T03:58:00Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "After giving this some more thought, I think there is enough complexity here that we shouldn't delay this draft while we figure it out.  For example, it might make sense to say that the record ID is a 16-bit value indicated by a SvcParamKey (`record-id=12345`), and that `record-id` and `port` must not appear together.  That would (arguably) make this unambiguously privacy-positive: it reduces the exposed entropy without increasing the total entropy.\r\n\r\nI'm not sure that formulation would fly, but we should take our time and get this right.",
          "createdAt": "2020-06-11T18:09:31Z",
          "updatedAt": "2020-06-11T18:09:31Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Proposing to defer this to a future draft.  It may make sense to do this as part of Alt-Svc-bis",
          "createdAt": "2020-07-09T21:15:35Z",
          "updatedAt": "2020-07-09T21:15:35Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 164,
      "id": "MDExOlB1bGxSZXF1ZXN0NDMyODE2NTEy",
      "title": "disable-https-upgrade SvcParamKey",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/164",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "future draft"
      ],
      "body": "Fixes #100 \r\nWill want working group discussion before merging.\r\n(End resolution may be to reject this.)",
      "createdAt": "2020-06-11T03:28:59Z",
      "updatedAt": "2020-07-10T17:25:01Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "c1dcfcc0fe75febd76926ed410c164f2b5137954",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-disable-https-upgrade",
      "headRefOid": "084ab4f4a9782a3c2f51f2fcde30e1e6658f44e1",
      "closedAt": "2020-07-10T17:25:01Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> How strongly is there a need for such a key? It seems a bit odd to define the key and then strongly discourage it.\r\n\r\nI agree: it's odd, at best.  The argument in favor is: imagine 10 million domains are CNAMEd to cdn.example.net, and 1% of them don't support HTTPS.  Currently, that means example.net can't deploy ECH for the other 99%.  Instead, they have to create cdn2.example.net, with HTTPSSVC, and convince them all to update their CNAMEs.\r\n\r\nI'm not sure how to feel about this problem.\r\n\r\n> If deployments need something like this in the future, I\u2019d prefer to see it as an extension.\r\n\r\nUnfortunately, this can't easily be done as a future extension, because, in the situation where it's needed, it only works if all clients support it.  Since clients ignore unrecognized SvcParamKeys, that means older clients would continue to enforce HSTS, thus breaking all the non-HTTPS domains.",
          "createdAt": "2020-06-11T19:10:44Z",
          "updatedAt": "2020-06-11T19:10:44Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see the incentive of getting everything on a given CNAME supporting TLS at the same time as a positive thing. Isn't it still possible in a deployment to choose to separate out CNAMEs differently if you need only some to support ECH? That way, the burden of disabling uniform encryption is placed upon the server DNS deployment, not on the clients that now need to write codepaths to pass up ECH keys but also consider that the connection may not support TLS.\r\n\r\nIt feels like we should make things easy to be secure, but not optimize for cases that are insecure and should long-term be fixed.",
          "createdAt": "2020-06-11T19:49:18Z",
          "updatedAt": "2020-06-11T19:49:18Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "\r\n> I agree: it's odd, at best. The argument in favor is: imagine 10 million domains are CNAMEd to cdn.example.net, and 1% of them don't support HTTPS. Currently, that means example.net can't deploy ECH for the other 99%. Instead, they have to create cdn2.example.net, with HTTPSSVC, and convince them all to update their CNAMEs.\r\n\r\nBut don't the 99% then lose the upgrade behavior? I'd call that much worse than forcing the last 1% to upgrade (or for them to switch to cdn2.example.net to keep working).\r\n\r\nOverall, I'm not a fan of disabling the upgrade, even with the newer \"compromise\" of only supporting it with ECH.  It's overall a good thing if HTTPSSVC and ECH force more HTTPS usage, and it seems a reasonable requirement in 2020.  The ECH-only part just adds an unnecessary (and kinda weird) complication that I'd really rather not support.",
          "createdAt": "2020-06-11T20:39:57Z",
          "updatedAt": "2020-06-11T20:39:57Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "This comes down to the ability to make a risk/reward business case for enabling ECH for existing shared domains.  With this capability there may be a chance to make a business case from a risk/effort trade-off.  Without this capability I don't see those large shared domains ever getting ECH enabled.   ie, who is going to care enough and push hard enough to force taking the risk of breaking sites or risk making customers unhappy?  I could see CDNs with \"free tiers\" just enabling ECH for shared domains, but the risk/reward and business drivers may not exist yet in the commercial space.\r\n\r\nIt may be a reasonable decision to decide not to do this from a complexity perspective, but with the understanding that we should not then expect default ECH enablement for existing sites in some of the environments that would most benefit.",
          "createdAt": "2020-06-11T21:32:14Z",
          "updatedAt": "2020-06-11T21:32:14Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Getting HTTPSSVC on those domains is still a benefit for load balancing, HTTP/3 deployment, and the HTTPS upgrade, no? And any risks around ECH itself would be there regardless.\r\n\r\nThis would make sense if moving to another CNAME to weather the HTTPS upgrade was the limiting factor against a hosting provider offering ECH by default. Is that really the case here?",
          "createdAt": "2020-06-11T21:38:40Z",
          "updatedAt": "2020-06-11T21:38:40Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "It's not just an issue of moving CNAMEs.  The issue is that some \"bulk\" CDN configurations have a mixture of HTTP-only, HTTPS-only, and HTTP+HTTPS mixed hostnames.  There's not always a clear differentiator between these, so enabling HSTS-style behavior must be opt-in which then precludes enabling ECH in anything other than an opt-in manner.",
          "createdAt": "2020-06-11T21:47:28Z",
          "updatedAt": "2020-06-11T21:47:28Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to using the proposal in #166 to address this as an extension.",
          "createdAt": "2020-06-17T22:11:59Z",
          "updatedAt": "2020-06-17T22:11:59Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Does that (or this PR, for that matter) actually disable the upgrade? #156 says you redirect to HTTPS on the mere presence of the HTTPS record, without following alias forms or anything.",
          "createdAt": "2020-06-17T22:25:43Z",
          "updatedAt": "2020-06-17T22:25:43Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Presumably, a client that has to discard the entire RR would not interpret it as being \"present\"?\r\n",
          "createdAt": "2020-06-17T22:55:51Z",
          "updatedAt": "2020-06-17T22:55:51Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If it needs to follow an alias form to find the critical extension, it won't notice.",
          "createdAt": "2020-06-18T01:44:02Z",
          "updatedAt": "2020-06-18T01:44:02Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Presumably at that point  (if it just followed the Alias) and found the effectively-empty HTTPS RRset and A/AAAA records then it would just use the A/AAAA records.\r\n",
          "createdAt": "2020-06-18T02:15:45Z",
          "updatedAt": "2020-06-18T02:15:45Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "If we had support for mandatory=, then that would allow clients to not implement disable-https-upgrade but for servers to specify that records are only available to clients implementing support which might make it safe to include here?",
          "createdAt": "2020-06-18T02:18:23Z",
          "updatedAt": "2020-06-18T02:18:23Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The behavior is that it *doesn't* follow the alias form records. That the second DNS query might hit A/AAAA records and miss the service form is exactly why the redirect should fire without following.",
          "createdAt": "2020-06-18T02:36:45Z",
          "updatedAt": "2020-06-18T02:36:45Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "disable-https-upgrade can't be present on an Alias form record.\r\nIf you want to use Alias form you have to be ok with the upgrade to HTTPS.",
          "createdAt": "2020-06-18T02:50:45Z",
          "updatedAt": "2020-06-18T02:50:45Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We need to put together DNS Records that can be used to validate correct/incorrect behavior. ",
          "createdAt": "2020-06-18T02:54:22Z",
          "updatedAt": "2020-06-18T02:54:22Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah okay, I think I misunderstood you. Yeah, if the expectation is that alias form precludes disabling the upgrade, #156 is consistent with all this.\r\n\r\nThough I still maintain that, as it's 2020, this is silly. :-)",
          "createdAt": "2020-06-18T02:56:29Z",
          "updatedAt": "2020-06-18T02:56:29Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Now that we have \"mandatory\" (#166), I think we should postpone this design to a separate document.",
          "createdAt": "2020-07-06T15:09:48Z",
          "updatedAt": "2020-07-06T15:09:48Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Deferring to a potential future draft based on need.",
          "createdAt": "2020-07-10T17:25:01Z",
          "updatedAt": "2020-07-10T17:25:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NTg1MzE4",
          "commit": {
            "abbreviatedOid": "aa287bd"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "How strongly is there a need for such a key? It seems a bit odd to define the key and then strongly discourage it. If anything, it should be marked as SHOULD NOT use or support, which seems tenuous.\n\nIf deployments need something like this in the future, I\u2019d prefer to see it as an extension. ",
          "createdAt": "2020-06-11T04:32:10Z",
          "updatedAt": "2020-06-11T04:34:37Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Typo: tennt",
              "createdAt": "2020-06-11T04:32:11Z",
              "updatedAt": "2020-06-18T02:55:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 165,
      "id": "MDExOlB1bGxSZXF1ZXN0NDMzMjU5MzQ2",
      "title": "Update changelog",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/165",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-06-11T18:27:20Z",
      "updatedAt": "2020-06-12T02:18:38Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "4bc31b26ae28241145aa9a9512fda90b762ced97",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-changelog",
      "headRefOid": "93c22271b434af2ef8d1232d0638e98524aef145",
      "closedAt": "2020-06-12T02:18:38Z",
      "mergedAt": "2020-06-12T02:18:38Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "3cded7241830630f92ffa1039b5a9efcb6bea75d"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Ok, I'll add that.\n\nOn Thu, Jun 11, 2020, 5:44 PM Erik Nygren <notifications@github.com> wrote:\n\n> *@enygren* commented on this pull request.\n>\n> Do we want to add the alignment with the ESNI draft and the switch from\n> esniconfig to echconfig ? Otherwise looks fine (but I haven't fully\n> scrubbed the diffs)\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/MikeBishop/dns-alt-svc/pull/165#pullrequestreview-429311661>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AABO3SL6JST6Q5YW7ORRGQTRWFF2JANCNFSM4N3U4HQA>\n> .\n>\n",
          "createdAt": "2020-06-11T22:55:33Z",
          "updatedAt": "2020-06-11T22:55:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MzExNjYx",
          "commit": {
            "abbreviatedOid": "c9b67d4"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Do we want to add the alignment with the ESNI draft and the switch from esniconfig to echconfig ?  Otherwise looks fine (but I haven't fully scrubbed the diffs)",
          "createdAt": "2020-06-11T21:43:50Z",
          "updatedAt": "2020-06-11T21:43:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 169,
      "id": "MDExOlB1bGxSZXF1ZXN0NDMzODQ4MDUz",
      "title": "Rename HTTPSSVC to HTTPS RR",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/169",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #80 \r\n* Rename HTTPSSVC RR to HTTPS RR     \r\n* Rename \"an SVCB\" to \"a SVCB\"     \r\n* Removed \"design considerations and open issues\" section and some other \"to be removed\" text\r\n* Rename draft to draft-ietf-dnsop-svcb-https\r\n",
      "createdAt": "2020-06-12T19:24:38Z",
      "updatedAt": "2020-06-12T20:12:26Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "3cded7241830630f92ffa1039b5a9efcb6bea75d",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-rename-httpssvc",
      "headRefOid": "b21ac595478036aecfd00e80d3dbc0d0fa1d86ba",
      "closedAt": "2020-06-12T20:12:26Z",
      "mergedAt": "2020-06-12T20:12:25Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "ff5cc8de4c1aacf13e5dedd29b5de0e5522d2145"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMDEwOTA5",
          "commit": {
            "abbreviatedOid": "b21ac59"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-12T20:12:17Z",
          "updatedAt": "2020-06-12T20:12:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 170,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM0MjEyNTE5",
      "title": "Attrleaf is actually RFC8552",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/170",
      "state": "CLOSED",
      "author": "moonshiner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Updated to reflect that Attrleaf draft is actually RFC8552\r\n\r\nI \"think\" I did this correctly - i'm more mmark than kramdown.\r\n",
      "createdAt": "2020-06-14T22:38:10Z",
      "updatedAt": "2020-06-22T17:29:22Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "ff5cc8de4c1aacf13e5dedd29b5de0e5522d2145",
      "headRepository": "moonshiner/dns-alt-svc",
      "headRefName": "master",
      "headRefOid": "babb166386358ea54d051cdeb3a3131b05eeda64",
      "closedAt": "2020-06-18T00:32:08Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I will close this as I need to deal with all the CI stuff ",
          "createdAt": "2020-06-18T00:32:08Z",
          "updatedAt": "2020-06-18T00:32:08Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "I'm happy to help with any toolchain issues, if you're still stuck.",
          "createdAt": "2020-06-22T17:29:21Z",
          "updatedAt": "2020-06-22T17:29:21Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 173,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1NDgzMzM5",
      "title": "s/master/primary/",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/173",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #172",
      "createdAt": "2020-06-16T21:46:12Z",
      "updatedAt": "2020-06-16T22:00:04Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "ff5cc8de4c1aacf13e5dedd29b5de0e5522d2145",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-master-to-primary",
      "headRefOid": "58da5d1c52b46354503c4f305337191f9466a627",
      "closedAt": "2020-06-16T21:59:58Z",
      "mergedAt": "2020-06-16T21:59:58Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "f3e4433b39d4d66147acb149639c25dc8b5a0a1e"
      },
      "comments": [
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you! I was on my to doing a pull request but you are too good to me\r\n",
          "createdAt": "2020-06-16T21:50:16Z",
          "updatedAt": "2020-06-16T21:50:16Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 174,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2MTY1NTQy",
      "title": "minor fix of ABNF",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/174",
      "state": "MERGED",
      "author": "moonshiner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-06-18T00:46:11Z",
      "updatedAt": "2020-06-23T12:24:53Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "f3e4433b39d4d66147acb149639c25dc8b5a0a1e",
      "headRepository": "moonshiner/dns-alt-svc",
      "headRefName": "tjw-fix-abnf",
      "headRefOid": "85042d8aaa8f61251f6461e878338023236781a3",
      "closedAt": "2020-06-18T01:28:34Z",
      "mergedAt": "2020-06-18T01:28:34Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "c73b8e7c89ca2c9e5f7111e71bf1a06245af86d3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODc5ODA2",
          "commit": {
            "abbreviatedOid": "85042d8"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-18T01:28:25Z",
          "updatedAt": "2020-06-18T01:28:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 175,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2MTg4MjMz",
      "title": "Switch NOT REQUIRED to non-2119 language",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/175",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #171",
      "createdAt": "2020-06-18T02:22:13Z",
      "updatedAt": "2020-06-22T18:41:32Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "c73b8e7c89ca2c9e5f7111e71bf1a06245af86d3",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-not-required",
      "headRefOid": "6726e47cd3dc8bb659bd294d2557917cc6b0bf1c",
      "closedAt": "2020-06-22T18:41:31Z",
      "mergedAt": "2020-06-22T18:41:31Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "5d00e17e45df8d39fa6b733d037c9281aaa9a06c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1MTgyMTQy",
          "commit": {
            "abbreviatedOid": "6726e47"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-22T18:41:27Z",
          "updatedAt": "2020-06-22T18:41:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 176,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2MTkwNzg1",
      "title": "Clarify HTTPS RR definition",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/176",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Editorial attempt to address feedback from @moonshiner by clarifying the HTTPS record definition.",
      "createdAt": "2020-06-18T02:31:55Z",
      "updatedAt": "2020-07-09T20:18:42Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "c73b8e7c89ca2c9e5f7111e71bf1a06245af86d3",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-clarify-https-rr",
      "headRefOid": "5d0beaac705a03c7117dc9afb797fea935f9d569",
      "closedAt": "2020-07-09T20:18:42Z",
      "mergedAt": "2020-07-09T20:18:42Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "08a5c8ac0e37848318fa9dc4929b4ee5d85d4e75"
      },
      "comments": [
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This works. ",
          "createdAt": "2020-06-18T02:53:06Z",
          "updatedAt": "2020-06-18T02:53:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1MTgxODUy",
          "commit": {
            "abbreviatedOid": "5a83215"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-22T18:40:58Z",
          "updatedAt": "2020-06-22T18:41:04Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "We defined the term \"SVCB-compatible\" for this purpose in the terminology section.  I'd prefer to maintain consistency across the document if possible, e.g.\r\n```suggestion\r\nOther SVCB-compatible resource record types\r\n```",
              "createdAt": "2020-06-22T18:40:58Z",
              "updatedAt": "2020-07-09T20:17:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1OTM4NTY3",
          "commit": {
            "abbreviatedOid": "5d0beaa"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-09T20:18:13Z",
          "updatedAt": "2020-07-09T20:18:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 178,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2MjA3MjU1",
      "title": "updated doc references",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/178",
      "state": "CLOSED",
      "author": "moonshiner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Issue 177",
      "createdAt": "2020-06-18T03:36:10Z",
      "updatedAt": "2020-06-24T17:27:16Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "c73b8e7c89ca2c9e5f7111e71bf1a06245af86d3",
      "headRepository": "moonshiner/dns-alt-svc",
      "headRefName": "tjw-ref-updates",
      "headRefOid": "25deb76f5369aec344000c8294e3f7ebba3db5c6",
      "closedAt": "2020-06-24T16:29:06Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the testing did not approve of draft-tls-esni-07, so removed the -07 for now",
          "createdAt": "2020-06-18T03:39:34Z",
          "updatedAt": "2020-06-18T03:39:34Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks like this is blocked due to collision with #179 ",
          "createdAt": "2020-06-22T18:36:00Z",
          "updatedAt": "2020-06-22T18:36:00Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "Actually, I think it's addressed by a combination of #179 and some others I found and have a PR for.",
          "createdAt": "2020-06-24T16:29:06Z",
          "updatedAt": "2020-06-24T16:29:06Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 179,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM4MTA0Nzc5",
      "title": "Fix up references",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/179",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #177, plus a few things I found along the way.",
      "createdAt": "2020-06-22T18:19:50Z",
      "updatedAt": "2020-06-22T18:35:11Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "0c53419523164c6822ed3b9c078e5e7db2bbe3ab",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "references",
      "headRefOid": "29793f8d73ca5153afc2a864dcf0ede9e54a6818",
      "closedAt": "2020-06-22T18:35:11Z",
      "mergedAt": "2020-06-22T18:35:10Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "1cf5f200375fd73b25582f13accd84bbb75b7595"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1MTc4MTU2",
          "commit": {
            "abbreviatedOid": "29793f8"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-22T18:35:05Z",
          "updatedAt": "2020-06-22T18:35:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 197,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM4NTM4NTgw",
      "title": "added RRType requests in IANA Considerations",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/197",
      "state": "MERGED",
      "author": "moonshiner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Make specific IANA requests in the IANA Considerations section",
      "createdAt": "2020-06-23T12:30:10Z",
      "updatedAt": "2020-08-11T21:34:29Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "9a3311b91969b2aabb83f444a6fa74e9d640fcd0",
      "headRepository": "moonshiner/dns-alt-svc",
      "headRefName": "tjw-iana-section",
      "headRefOid": "e1ab2a4e17eff50bca13aa483fb675d5b7f1f17a",
      "closedAt": "2020-07-10T17:06:27Z",
      "mergedAt": "2020-07-10T17:06:27Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "137242b8365fc2084a930ab6008240af8bddfe36"
      },
      "comments": [
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I updated this with the IANA Values that have been assigned.  \r\n\r\n",
          "createdAt": "2020-06-30T19:44:30Z",
          "updatedAt": "2020-06-30T19:44:30Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "This looks good but maybe we should hold off on it until after WGLC, just in case there are any last-minute changes?",
          "createdAt": "2020-07-10T01:13:15Z",
          "updatedAt": "2020-07-10T01:13:15Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bemasc the allocations are already made, so we may as well mention the values, right?",
          "createdAt": "2020-07-10T01:51:47Z",
          "updatedAt": "2020-07-10T01:51:47Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should mention the values as they are set by IANA. ",
          "createdAt": "2020-07-10T03:47:23Z",
          "updatedAt": "2020-07-10T03:47:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2ODQ3MTg5",
          "commit": {
            "abbreviatedOid": "87f4414"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-24T17:12:46Z",
          "updatedAt": "2020-06-24T17:12:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 198,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM4NTUxMDAx",
      "title": "added colons to clean up the text",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/198",
      "state": "MERGED",
      "author": "moonshiner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This should cover all the missing colons mentioned \r\n\r\nhttps://github.com/MikeBishop/dns-alt-svc/issues/186\r\n",
      "createdAt": "2020-06-23T12:53:21Z",
      "updatedAt": "2020-09-08T16:32:36Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "5d00e17e45df8d39fa6b733d037c9281aaa9a06c",
      "headRepository": "moonshiner/dns-alt-svc",
      "headRefName": "tjw-add-colons",
      "headRefOid": "631091e4707c7bc60f4a033360655068fcd8f540",
      "closedAt": "2020-06-28T17:10:23Z",
      "mergedAt": "2020-06-28T17:10:23Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "9a3311b91969b2aabb83f444a6fa74e9d640fcd0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4Nzk3NDg1",
          "commit": {
            "abbreviatedOid": "631091e"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-28T17:10:17Z",
          "updatedAt": "2020-06-28T17:10:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 199,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM4OTQ1NzI0",
      "title": "Incorporate comments from implementer review",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/199",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We got some tweaks from a server implementer review\r\n* Everything additional should go in Additional\r\n* Authoritatives should include DNSSEC for the in-bailiwick followup records\r\n* Harmonize #recursive-behavior with #incomplete-responses",
      "createdAt": "2020-06-24T03:58:53Z",
      "updatedAt": "2020-07-11T16:27:38Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "5d00e17e45df8d39fa6b733d037c9281aaa9a06c",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-implementer-review",
      "headRefOid": "3629dac5cf768b6d7285e35c7958edb0207e5841",
      "closedAt": "2020-07-11T16:27:38Z",
      "mergedAt": "2020-07-11T16:27:38Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "23fd6011d3f47c061055d3f805a908797b9661c2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2NzU5MzY4",
          "commit": {
            "abbreviatedOid": "a177de9"
          },
          "author": "wtoorop",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-24T15:26:00Z",
          "updatedAt": "2020-06-24T15:26:01Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Including useful records in the additional section, is called additional section processing in RFC1035.\r\nWhen comparing SVCB with MX and SRV, note that MX and SRV may not refer to an alias. This is documented in https://tools.ietf.org/html/rfc2181#section-10.3 and in https://tools.ietf.org/html/rfc2782 on page 4, quoting: \"The name MUST NOT be an alias\".",
              "createdAt": "2020-06-24T15:26:01Z",
              "updatedAt": "2020-07-09T21:28:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2NzYwMzEx",
          "commit": {
            "abbreviatedOid": "a177de9"
          },
          "author": "wtoorop",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-24T15:27:01Z",
          "updatedAt": "2020-06-24T15:27:01Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I suggest to remove the text in parenthesis.",
              "createdAt": "2020-06-24T15:27:01Z",
              "updatedAt": "2020-07-09T21:28:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2Nzc0MjI5",
          "commit": {
            "abbreviatedOid": "a177de9"
          },
          "author": "wtoorop",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-24T15:42:21Z",
          "updatedAt": "2020-06-24T15:42:22Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "So, comparing this to SRV serving by Unbound: Unbound will include useful RR's in the additional section (i.e. address records for the SRV targets) when they can be found in cache.\r\nThe current text states that ``\"resolve\" means the resolver's ordinary recursive resolution procedure'' rather firmly (verbatim on line 637 actually), but this ignores the modus operandi of providing helpful records from cache (for which you can be certain that it will help improve performance; opposed to doing additional recursive resolution).\r\nGetting the RRs for the additional from cache also plays along nicely with the authoritative providing the A, AAAA and SVCB records which it has in-bailiwick in the additional section.",
              "createdAt": "2020-06-24T15:42:22Z",
              "updatedAt": "2020-07-09T21:28:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1OTgxODg3",
          "commit": {
            "abbreviatedOid": "3629dac"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-09T21:28:43Z",
          "updatedAt": "2020-07-09T21:28:43Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "OK, removed.  CNAMEs within the bailiwick would be a strange configuration anyway.",
              "createdAt": "2020-07-09T21:28:43Z",
              "updatedAt": "2020-07-09T21:28:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1OTgyODcx",
          "commit": {
            "abbreviatedOid": "3629dac"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-09T21:30:30Z",
          "updatedAt": "2020-07-09T21:30:31Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "That behavior is compatible with the text as-is, as discussed in \"Generating and using incomplete responses\".  However, I have adjusted the text here in an attempt to reduce confusion about the motivation and requirements.",
              "createdAt": "2020-07-09T21:30:31Z",
              "updatedAt": "2020-07-09T21:30:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODEzMzc5",
          "commit": {
            "abbreviatedOid": "3629dac"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-11T16:27:32Z",
          "updatedAt": "2020-07-11T16:27:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 200,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM5MzE3ODYw",
      "title": "Fix more references",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/200",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-06-24T16:29:41Z",
      "updatedAt": "2020-06-24T17:10:24Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "5d00e17e45df8d39fa6b733d037c9281aaa9a06c",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "references",
      "headRefOid": "94690bf429d8cd4df7ba2e9fc9e24c658c788bfd",
      "closedAt": "2020-06-24T17:10:24Z",
      "mergedAt": "2020-06-24T17:10:24Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "3d1b580ed11645e889e55bc5e276dbab383414c8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2ODQ1MTg4",
          "commit": {
            "abbreviatedOid": "94690bf"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-24T17:10:03Z",
          "updatedAt": "2020-06-24T17:10:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 201,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQwMzM2MTI1",
      "title": "Adjust advice on populating the client's ALPN set",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/201",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #194",
      "createdAt": "2020-06-26T01:37:36Z",
      "updatedAt": "2020-07-11T17:46:59Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "9a3311b91969b2aabb83f444a6fa74e9d640fcd0",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-better",
      "headRefOid": "6cfd415a0e9a31b89206b62050b9fbdd77a935da",
      "closedAt": "2020-07-11T17:46:59Z",
      "mergedAt": "2020-07-11T17:46:59Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "0ea348a7fcc88ccd183c601a50a22eecf160d9ec"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we should say *something*. Otherwise the analogy to Alt-Svc, which prescribed the wrong thing, may cause implementers to do the wrong thing. (The wrong thing being considered compliant by confused clients results in deployment implications for a server trying to use SVCB.) But, given the point is to disavow that and get these Alt-Svc-like mechanisms out of the business of messing with ALPN as much as possible, I'm good with something shorter and lighter on details.\r\n\r\nThough that suggestion might be a little *too* light? It's arguably not *quite* a hint because an `h3` SVCB record will (at least for now) result in different ALPN advertisement than an `h2` record due to different sets of ALPNs being \"compatible\". If we don't want to go down the rabbithole of defining that just yet, maybe something like:\r\n\r\n> Note a client may not be willing to negotiate all protocols over all connections, and would advertise ALPN protocols accordingly. For example, an HTTP client using an `h3` record for a QUIC connection would not advertise `http/1.1` or `h2`. However, when using an `h2` record for a TCP connection, it may advertise both `http/1.1` and `h2`, and accept either protocol from the server.\r\n\r\nWDYT?",
          "createdAt": "2020-07-10T04:30:28Z",
          "updatedAt": "2020-07-10T04:31:32Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Are we comfortable with what is here and ready to merge it, or are changes still desired?\r\n(It is looking fairly reasonable to me.)",
          "createdAt": "2020-07-11T16:34:55Z",
          "updatedAt": "2020-07-11T16:34:55Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to merge this as-is.  It may be overly verbose, but we seem to have rough consensus that it is correct, and perhaps we can shorten it later.\r\n\r\nI want to be cautious about removing text here because I think there is a real risk of implementors getting it wrong in various ways, and previous drafts have resulted in differing interpretations.",
          "createdAt": "2020-07-11T17:46:50Z",
          "updatedAt": "2020-07-11T17:46:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMDg3NjMz",
          "commit": {
            "abbreviatedOid": "73cd4ee"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks! One quick question below.",
          "createdAt": "2020-07-01T18:02:03Z",
          "updatedAt": "2020-07-01T18:02:42Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I'm not quite following this sentence (old and new version). Is it saying the same thing as the SHOULD above or something else?",
              "createdAt": "2020-07-01T18:02:03Z",
              "updatedAt": "2020-07-10T01:37:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMTQ5NTA4",
          "commit": {
            "abbreviatedOid": "73cd4ee"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-01T19:43:44Z",
          "updatedAt": "2020-07-01T19:43:45Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "It's kind of the inverse.  There are really two requirements:\r\n* If you use an ALPN from the list, you SHOULD accompany it with any other ALPN you would like to do on that transport, whether or not it's in the list.\r\n* You MUST only form one ClientHello per transport in total, so if you like two ALPNs from the list, they have to go in the same ClientHello (if that is possible).\r\n\r\nThe first requirement defends against attackers on the DNS path, and the second defends against attackers on the network path.\r\n\r\nThat said, these requirements are effectively kind of redundant, so we could possibly simplify this text.  Suggestions welcome.",
              "createdAt": "2020-07-01T19:43:44Z",
              "updatedAt": "2020-07-10T01:37:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMTU3ODE4",
          "commit": {
            "abbreviatedOid": "73cd4ee"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-01T19:58:02Z",
          "updatedAt": "2020-07-01T19:58:02Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Ah. I guess my interpretation was that, if `ClientHelloFromSVCB(proto=h2)` and `ClientHelloFromSVCB(proto=http/1.1)` both result in the same ClientHello (based on the rule that you include all of them), that's fine whether I connect to them serially or in parallel or whatever.\r\n\r\nWhat does consolidating mean if, say, I see SVCB records for h2 and http/1.1 but other properties, like ECH keys or addresses, are different? I figured the model would be that you pick which one(s) you want, and send out ClientHellos for them. If you decided you wanted to race the http/1.1 and h2 records, they'll end up sending the same ALPN. If you decided you wanted to race an h3 one in there, it will be different. When picking them, you probably do need to be aware of the correspondence, but I think the impact is less security and more making your connection strategy coherent.",
              "createdAt": "2020-07-01T19:58:02Z",
              "updatedAt": "2020-07-10T01:37:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMjg4NzMy",
          "commit": {
            "abbreviatedOid": "ffe88cd"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-02T01:18:08Z",
          "updatedAt": "2020-07-02T01:18:09Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "OK, evidently the previous text was not clear enough.  I've reorganized it; hopefully its less ambiguous now.",
              "createdAt": "2020-07-02T01:18:08Z",
              "updatedAt": "2020-07-10T01:37:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMjkxNTEz",
          "commit": {
            "abbreviatedOid": "ffe88cd"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-02T01:27:49Z",
          "updatedAt": "2020-07-02T01:27:49Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "FWIW, I find \"downgrade attacks within a transport\" somewhat confusing. Could we add an example?",
              "createdAt": "2020-07-02T01:27:49Z",
              "updatedAt": "2020-07-10T01:37:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMjk1MjM5",
          "commit": {
            "abbreviatedOid": "6adefff"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-02T01:40:31Z",
          "updatedAt": "2020-07-02T01:40:32Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "OK, I replaced that language with a more explicit definition.",
              "createdAt": "2020-07-02T01:40:31Z",
              "updatedAt": "2020-07-10T01:37:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMjk1NzE2",
          "commit": {
            "abbreviatedOid": "6adefff"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-02T01:42:11Z",
          "updatedAt": "2020-07-02T01:42:11Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Much clearer -- thanks!",
              "createdAt": "2020-07-02T01:42:11Z",
              "updatedAt": "2020-07-10T01:37:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODE4NDk4",
          "commit": {
            "abbreviatedOid": "6adefff"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-02T15:48:34Z",
          "updatedAt": "2020-07-02T15:55:41Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Nitpick: Not sure I've seen these called \"IDs\" before. RFC7301 says \"protocol\" or \"protocol name\". RFC8446 says \"ALPN protocol\". RFC7838 says \"ALPN protocol name\" with a few instances of \"ALPN protocol\".",
              "createdAt": "2020-07-02T15:48:34Z",
              "updatedAt": "2020-07-10T01:37:45Z"
            },
            {
              "originalPosition": 12,
              "body": "Might want to mention in this example that this client supports [\"http/1.1\", \"h2\", \"h3\"]. If the client supports \"h4\" which also goes over QUIC, the example would be different.",
              "createdAt": "2020-07-02T15:50:03Z",
              "updatedAt": "2020-07-10T01:37:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1OTQ1MjAy",
          "commit": {
            "abbreviatedOid": "6adefff"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-09T20:28:37Z",
          "updatedAt": "2020-07-09T20:28:37Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "\"Supported IDs\" seems to be ambiguous here.  Needs clarification that this is \"supported by the client\".",
              "createdAt": "2020-07-09T20:28:37Z",
              "updatedAt": "2020-07-10T01:37:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MDcwMTY4",
          "commit": {
            "abbreviatedOid": "6cfd415"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-10T01:38:44Z",
          "updatedAt": "2020-07-10T01:38:44Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I've reworked the terminology to be more precise, and use \"Identification Sequence\", \"protocol name\", and \"protocol\" as appropriate.",
              "createdAt": "2020-07-10T01:38:44Z",
              "updatedAt": "2020-07-10T01:38:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MDcwMTk1",
          "commit": {
            "abbreviatedOid": "6cfd415"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-10T01:38:50Z",
          "updatedAt": "2020-07-10T01:38:51Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Done",
              "createdAt": "2020-07-10T01:38:50Z",
              "updatedAt": "2020-07-10T01:38:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MDcwMjI5",
          "commit": {
            "abbreviatedOid": "6cfd415"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-10T01:38:58Z",
          "updatedAt": "2020-07-10T01:38:58Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Done",
              "createdAt": "2020-07-10T01:38:58Z",
              "updatedAt": "2020-07-10T01:38:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MDczNTI1",
          "commit": {
            "abbreviatedOid": "6cfd415"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-10T01:51:14Z",
          "updatedAt": "2020-07-10T01:51:14Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "FWIW, these steps are exactly what I'm implementing in our client already, so this seems to be the most practical approach.",
              "createdAt": "2020-07-10T01:51:14Z",
              "updatedAt": "2020-07-10T01:51:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MTAyMjM3",
          "commit": {
            "abbreviatedOid": "6cfd415"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Why so many words when this could be entirely silent on the subject instead?\r\n\r\nOr, if you feel the need to say something, say:\r\n\r\n> In order to prevent downgrade attacks, clients need to ensure that all ALPN values that it might be willing to use are advertised.  Information in SVCB only provides hints about supported protocols.  An authenticated connection to a server is the only reliable way in which clients can determine what protocols are supported by that server.\r\n\r\nNote the absence of normative language.  RFC 7301 has everything necessary in that area.",
          "createdAt": "2020-07-10T03:39:32Z",
          "updatedAt": "2020-07-10T03:39:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 202,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQwMzY4OTA4",
      "title": "Rework ABNF for clarity and simpler implementation",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/202",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #185, #192",
      "createdAt": "2020-06-26T04:05:32Z",
      "updatedAt": "2020-07-13T20:11:12Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "73b89134ed6ac7dbbd427b3e36fb3d56f2c41b14",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-escape",
      "headRefOid": "b323165bc84ff1e4e6e7d3c38623b21ece17c4df",
      "closedAt": "2020-07-13T20:11:12Z",
      "mergedAt": "2020-07-13T20:11:12Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "b9693794693edcdd6eeb75b5fb4a4322730e8e58"
      },
      "comments": [
        {
          "author": "lcampbel",
          "authorAssociation": "NONE",
          "body": "I think these changes do make the text clearer. But there are two different ways to implement a parser for this. The suggested approach is essentially to have an alternate character-string parser that (1) splits on unescaped commas, and (2) returns an array of strings rather than a string. I think an equally appealing approach is to first use a character-string parser that always returns a string and ignores backslash escapes other than \\\". All other uses (such as TXT records) would unescape the returned string; the alpn parser would first split the returned string on unescaped commas, then unescape each component string. I believe these two approaches are functionally identical but I find the latter a bit cleaner.",
          "createdAt": "2020-07-01T17:50:14Z",
          "updatedAt": "2020-07-01T17:50:14Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@lcampbel Thanks for the review.  I think that would indeed be a fine way to implement, but describing that procedure in ABNF seems pretty complicated, especially due to the many ambiguities of RFC 1035.  (I think it would be great if someone would write a followup to 1035 that pins down the precise zone file format rules, but this draft is already further down that road than I would like.)",
          "createdAt": "2020-07-02T02:15:09Z",
          "updatedAt": "2020-07-02T02:15:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MDEyOTIz",
          "commit": {
            "abbreviatedOid": "aab400b"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-26T04:56:13Z",
          "updatedAt": "2020-06-26T04:56:14Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "The double quotes are part of the second alpn-id. so this should read.\r\n\r\nThis would be decoded as three `alpn-id`s: 'example1', '\"weird, why?\"', and\r\n'example2'.\r\n ",
              "createdAt": "2020-06-26T04:56:13Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MDE3NTk0",
          "commit": {
            "abbreviatedOid": "aab400b"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-26T05:13:26Z",
          "updatedAt": "2020-06-26T05:13:27Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Why doesn't this just say \"unescaped comma\"?  \\044 really does not buy anything over \"\\\\,\" when parsing.   So is '\\\\,' now also a separator or is it a syntax error?",
              "createdAt": "2020-06-26T05:13:26Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MjY4NzAy",
          "commit": {
            "abbreviatedOid": "aab400b"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-26T12:52:41Z",
          "updatedAt": "2020-06-26T12:52:42Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "In this PR, this example is first parsed to a sequence of three `char-string`s: `example1`, `\"weird\\044 why?\"`, and `example2`.  Then the character-string decoding algorithm is applied to each `char-string`, yielding `example1`, `weird, why?`, and `example2`.  This is because double-quotes are optional in `char-string`.\r\n\r\nMy goal here is to make the parsing algorithm easy to implement, so please suggest changes.  I proposed this formulation to minimize the amount of new parsing code required (reuse the same decoding algorithm), while making sure that all `alpn-id`s are representable, including those that contain commas and spaces. ",
              "createdAt": "2020-06-26T12:52:41Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NDIxMDg3",
          "commit": {
            "abbreviatedOid": "aab400b"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-26T16:10:13Z",
          "updatedAt": "2020-06-26T16:10:13Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "The proposed algorithm here is \"character-string decode, split on commas, character-string decode again\".  Therefore:\r\n* `alpn=ex1,ex2\\,ex3` is `ex1`, `ex2`, and  `ex3`, because the first-pass decoding unescapes the entire value\r\n* `alpn=ex1,ex2\\\\,ex3` is presumably a syntax error, because `ex2\\` is not a valid character-string, because `\\` is supposed to escape something but there is nothing to escape.\r\n* `alpn=ex1,ex2\\\\\\\\,ex3` is `ex1`, `ex2\\`, and `ex3`",
              "createdAt": "2020-06-26T16:10:13Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NjA4OTA4",
          "commit": {
            "abbreviatedOid": "aab400b"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-26T21:35:08Z",
          "updatedAt": "2020-06-26T21:35:08Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "If you do this then \"foo\\044bar\" becomes \"foo,bar\"  which becomes \"foo\" and \"bar\".   Following your method you would have to have \"foo\\\\\\\\044bar\" which becomes \"foo\\044bar\" which becomes \"foo,bar\".   And to get a alpn-id that is \"foo\\044bar\" I would need to enter \"foo\\\\\\\\\\\\\\\\044bar\"  (4 backslashes) instead of \"foo\\\\\\\\044bar\" (2 backslashes).\r\n\r\nAll this for not extending the existing character string parser to know if comma is a special or not.  'if (comma_processing && c == ',' && !escaped) end-of-alpn-id;\". ",
              "createdAt": "2020-06-26T21:35:08Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NjEwOTE2",
          "commit": {
            "abbreviatedOid": "aab400b"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-26T21:39:58Z",
          "updatedAt": "2020-06-26T21:39:59Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "Detecting escaped commas is dead easy.  GO LOOK AT HOW BIND DOES IT.  All this just makes it harder for the person entering the data.  ",
              "createdAt": "2020-06-26T21:39:58Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NjIzNzU4",
          "commit": {
            "abbreviatedOid": "aab400b"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-26T22:13:09Z",
          "updatedAt": "2020-06-26T22:13:10Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "Also the point of using quoted strings is to turn off special processing to get the full token at places that would otherwise terminate the token.   Once you have the full token you don't need to drop them a second time.",
              "createdAt": "2020-06-26T22:13:10Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NjUxMDkz",
          "commit": {
            "abbreviatedOid": "aab400b"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-27T00:05:34Z",
          "updatedAt": "2020-06-27T00:05:34Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "And so you don't have to search around in the repository to find it. \r\n\r\nAt this point the double quotes have been processed.  The token still contains all the escapes.\r\n\r\n```\r\n+static isc_result_t\r\n+alpn_fromtxt(isc_textregion_t *source, isc_buffer_t *target) {\r\n+       isc_textregion_t source0 = *source;\r\n+       do {\r\n+               RETERR(commatxt_fromtext(&source0, true, target));\r\n+       } while (source0.length != 0);\r\n+       return (ISC_R_SUCCESS);\r\n+}\r\n```\r\n\r\n```\r\n@@ -1390,7 +1432,8 @@ name_length(const dns_name_t *name) {\r\n }\r\n \r\n static isc_result_t\r\n-txt_totext(isc_region_t *source, bool quote, isc_buffer_t *target) {\r\n+commatxt_totext(isc_region_t *source, bool quote, bool comma,\r\n+               isc_buffer_t *target) {\r\n        unsigned int tl;\r\n        unsigned int n;\r\n        unsigned char *sp;\r\n@@ -1435,10 +1478,12 @@ txt_totext(isc_region_t *source, bool quote, isc_buffer_t *target) {\r\n                /*\r\n                 * Escape double quote and backslash.  If we are not\r\n                 * enclosing the string in double quotes also escape\r\n-                * at sign and semicolon.\r\n+                * at sign and semicolon unless comma is set.  If\r\n+                * comma is set then escape commas.\r\n                 */\r\n-               if (*sp == 0x22 || *sp == 0x5c ||\r\n-                   (!quote && (*sp == 0x40 || *sp == 0x3b))) {\r\n+               if (*sp == 0x22 || *sp == 0x5c || (comma && *sp == 0x2c) ||\r\n+                   (!comma && !quote && (*sp == 0x40 || *sp == 0x3b)))\r\n+               {\r\n                        if (tl < 2) {\r\n                                return (ISC_R_NOSPACE);\r\n                        }\r\n@@ -1465,9 +1510,14 @@ txt_totext(isc_region_t *source, bool quote, isc_buffer_t *target) {\r\n }\r\n \r\n static isc_result_t\r\n-txt_fromtext(isc_textregion_t *source, isc_buffer_t *target) {\r\n+txt_totext(isc_region_t *source, bool quote, isc_buffer_t *target) {\r\n+       return (commatxt_totext(source, quote, false, target));\r\n+}\r\n+\r\n+static isc_result_t\r\n+commatxt_fromtext(isc_textregion_t *source, bool comma, isc_buffer_t *target) {\r\n        isc_region_t tregion;\r\n-       bool escape;\r\n+       bool escape, seen_comma = false;\r\n        unsigned int n, nrem;\r\n        char *s;\r\n        unsigned char *t;\r\n@@ -1496,6 +1546,10 @@ txt_fromtext(isc_textregion_t *source, isc_buffer_t *target) {\r\n        }\r\n        while (n-- != 0) {\r\n                c = (*s++) & 0xff;\r\n+               if (comma && !escape && c == ',') {\r\n+                       seen_comma = true;\r\n+                       break;\r\n+               }\r\n                if (escape && (d = decvalue((char)c)) != -1) {\r\n                        c = d;\r\n                        if (n == 0) {\r\n@@ -1534,11 +1588,32 @@ txt_fromtext(isc_textregion_t *source, isc_buffer_t *target) {\r\n        if (escape) {\r\n                return (DNS_R_SYNTAX);\r\n        }\r\n+       if (comma) {\r\n+               /*\r\n+                * Disallow empty ALPN at start or in the middle.\r\n+                */\r\n+               if (s == source->base || (seen_comma && s == source->base + 1))\r\n+               {\r\n+                       return (DNS_R_SYNTAX);\r\n+               }\r\n+               isc_textregion_consume(source, s - source->base);\r\n+               /*\r\n+                * Disallow empty ALPN at end.\r\n+                */\r\n+               if (seen_comma && source->length == 0) {\r\n+                       return (DNS_R_SYNTAX);\r\n+               }\r\n+       }\r\n        *tregion.base = (unsigned char)(t - tregion.base - 1);\r\n        isc_buffer_add(target, *tregion.base + 1);\r\n        return (ISC_R_SUCCESS);\r\n }\r\n\r\n +static isc_result_t\r\n+txt_fromtext(isc_textregion_t *source, isc_buffer_t *target) {\r\n+       return (commatxt_fromtext(source, false, target));\r\n+}\r\n+\r\n static isc_result_t\r\n txt_fromwire(isc_buffer_t *source, isc_buffer_t *target) {\r\n        unsigned int n;\r\n```",
              "createdAt": "2020-06-27T00:05:34Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NzI4NjQ4",
          "commit": {
            "abbreviatedOid": "9307a30"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-27T22:31:06Z",
          "updatedAt": "2020-06-27T22:31:07Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "OK, I've updated the PR to reflect this approach.  Please review.",
              "createdAt": "2020-06-27T22:31:06Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NTQyMzI5",
          "commit": {
            "abbreviatedOid": "9307a30"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-29T22:21:50Z",
          "updatedAt": "2020-06-29T22:21:50Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "I would say that they are key value pairs.  If the definition of a value consists of a list (i.e. ipv4hints, ipv6hints, alpn) the list elements are separated by a unescaped \",\".  To add a literal comma to an element in a list, the comma must be escaped.   At the moment you have everything defined to be a list including the generic form which clearly is not a list.",
              "createdAt": "2020-06-29T22:21:50Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDg3Njc3",
          "commit": {
            "abbreviatedOid": "b05042c"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-01T01:23:51Z",
          "updatedAt": "2020-07-01T01:23:52Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "OK, I've changed the text to reflect this idea.",
              "createdAt": "2020-07-01T01:23:51Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDkyMjM5",
          "commit": {
            "abbreviatedOid": "b05042c"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-01T01:39:35Z",
          "updatedAt": "2020-07-01T01:39:35Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "s/splitting on commas/splitting on unescaped commas/",
              "createdAt": "2020-07-01T01:39:35Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDkzMjE5",
          "commit": {
            "abbreviatedOid": "b05042c"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-01T01:43:07Z",
          "updatedAt": "2020-07-01T01:43:07Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "It would be useful to never have to apply escape processing to port so append.  \"No escape processing should be applied to the port value.\"",
              "createdAt": "2020-07-01T01:43:07Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDkzNTY5",
          "commit": {
            "abbreviatedOid": "b05042c"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-01T01:44:23Z",
          "updatedAt": "2020-07-01T01:44:23Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "Similarly disallow escape processing for ipv4hints and ipv6hints.",
              "createdAt": "2020-07-01T01:44:23Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwOTIyMjM4",
          "commit": {
            "abbreviatedOid": "f1b7e42"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-01T14:28:18Z",
          "updatedAt": "2020-07-01T14:28:18Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "Done",
              "createdAt": "2020-07-01T14:28:18Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwOTIyMjcy",
          "commit": {
            "abbreviatedOid": "f1b7e42"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-01T14:28:19Z",
          "updatedAt": "2020-07-01T14:28:20Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "Done",
              "createdAt": "2020-07-01T14:28:20Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwOTIyNTE0",
          "commit": {
            "abbreviatedOid": "f1b7e42"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-01T14:28:35Z",
          "updatedAt": "2020-07-01T14:28:36Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Done",
              "createdAt": "2020-07-01T14:28:35Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NDkwNzQ4",
          "commit": {
            "abbreviatedOid": "9fa40a2"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "See comments above.",
          "createdAt": "2020-07-13T18:19:23Z",
          "updatedAt": "2020-07-13T19:02:21Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Do we want to describe char-string a little more here?  \r\n(ie, say how it relates to  {{!RFC1035}} character-string, even if the full definition is in the appendix?)  ",
              "createdAt": "2020-07-13T18:19:23Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            },
            {
              "originalPosition": 18,
              "body": "Move this background context up to the introduction to {{svcb}} ?\r\n\r\n\"SVCB RRs are extensible by SvcParams which is a list of tuples consisting of a SvcParamKey with an optional SvcParamValue. Each SvcParamKey has a presentation string which maps to a registered number. Values are in a format specific to the SvcParamKey.  Their definition should specify both their presentation format and wire encoding (e.g., domain names, binary data, or numeric values).  The initial SvcParamKeys and formats are defined in {{keys}}.\"\r\n",
              "createdAt": "2020-07-13T18:24:08Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            },
            {
              "originalPosition": 36,
              "body": "Should we split out and define SvcParamValue ?\r\n\r\n```suggestion\r\n    SvcParam    = SvcParamKey [\"=\" SvcParamValue]\r\n    SvcParamValue = char-string\r\n```\r\n",
              "createdAt": "2020-07-13T18:31:49Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            },
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nThe definition of each key indicates that SvcParamValue is either \r\nempty, single-valued, or multi-valued.  To parse a single-valued SvcParam, the parser applies the\r\n```",
              "createdAt": "2020-07-13T18:34:14Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            },
            {
              "originalPosition": 43,
              "body": "```suggestion\r\nthe wire-format encoding.  To parse a multi-valued SvcParam, the parser applies\r\n```",
              "createdAt": "2020-07-13T18:34:32Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            },
            {
              "originalPosition": 64,
              "body": "Do we want to be more consistent on when we mean a SvcParamKey\r\nvs SvcParam?  We use \"key\" here in a few places in a way that is potentially\r\nambiguous and it might be better to tighten that up minimize the use\r\nof bare \"key\".  At least with value vs SvcParamValue they do mean different things.",
              "createdAt": "2020-07-13T18:35:24Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            },
            {
              "originalPosition": 82,
              "body": "```suggestion\r\n\"alpn\" is a multi-valued SvcParamKey.  Each decoded value in the \"alpn\" value list\r\n```",
              "createdAt": "2020-07-13T18:39:58Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            },
            {
              "originalPosition": 138,
              "body": "Is there a weird mismatch here with other value encodings?  Is there a reason presentation format for this isn't char-string escaped.  Do we want to at least call this out?  (ie, that base64 is used here for more condensed encoding and that no escaping is needed since it falls into non-special?)",
              "createdAt": "2020-07-13T18:46:49Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            },
            {
              "originalPosition": 184,
              "body": "Should this be \"\\\\\\\\,\" ?",
              "createdAt": "2020-07-13T18:48:29Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            },
            {
              "originalPosition": 184,
              "body": "(presumably the \\\\\\\\ is for markdown, not the doc?)",
              "createdAt": "2020-07-13T18:49:24Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            },
            {
              "originalPosition": 171,
              "body": "It took me a few times reading this to really understand it.  Not sure ways to clarify?\r\nCorner cases:\r\n* What about \\\\44 ?  (encoded comma)\r\n* DQUOTE\r\nPerhaps have an example which shows how these interact?\r\nFor example, that:\r\n\"part1,part2\",\"part3\" \r\nstill gets decoded as all three values?\r\nAnd that \"part1\\\\44part2,part3\" gets decoded as two values?",
              "createdAt": "2020-07-13T19:01:49Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NTU0MjUy",
          "commit": {
            "abbreviatedOid": "7719f04"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-13T19:53:41Z",
          "updatedAt": "2020-07-13T19:57:27Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done (with slight modifications)",
              "createdAt": "2020-07-13T19:53:41Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            },
            {
              "originalPosition": 138,
              "body": "I added an explanation.  (I think the real reason is that we don't expect TLS stacks to gain support for producing DNS zone file escape codes.)  I also added the escape restriction.",
              "createdAt": "2020-07-13T19:54:26Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            },
            {
              "originalPosition": 171,
              "body": "OK, clarified relationship with \\044 and quoting.\r\n\r\n> \"part1,part2\",\"part3\"\r\n\r\nThis is not a valid `char-string` so it's excluded.\r\n\r\nI admit that this description isn't perfect, but there is no clear syntax definition for zone files so I don't think we should aim for extreme precision.",
              "createdAt": "2020-07-13T19:56:37Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            },
            {
              "originalPosition": 184,
              "body": "I think this is a difference between github-markdown and the flavor we're using.  In our flavor, \"\\\" doesn't need to be escaped inside a verbatim block (four space indent).",
              "createdAt": "2020-07-13T19:57:16Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NTU3OTc1",
          "commit": {
            "abbreviatedOid": "7719f04"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-13T19:59:19Z",
          "updatedAt": "2020-07-13T19:59:19Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "OK, I've tried to do this more consistently.",
              "createdAt": "2020-07-13T19:59:19Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NTYzMzQ0",
          "commit": {
            "abbreviatedOid": "7719f04"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-07-13T20:07:35Z",
          "updatedAt": "2020-07-13T20:08:48Z",
          "comments": [
            {
              "originalPosition": 201,
              "body": "Make plural:\r\n```suggestion\r\nFor example, consider these `char-string` SvcParamValues:\r\n```",
              "createdAt": "2020-07-13T20:07:35Z",
              "updatedAt": "2020-07-13T20:10:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 204,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQxMDk4Mzg2",
      "title": "Remove use of \"origin\" for non-HTTP schemes",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/204",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The use of \"origin\" for non-HTTP schemes, and the use of \"origin server\"\r\nto mean only the normal server, were generating confusion.  This PR\r\naligns terminology with the URI specification and limits the use of\r\n\"origin\" to HTTP.\r\n\r\nFixes #183",
      "createdAt": "2020-06-28T18:51:58Z",
      "updatedAt": "2020-07-13T19:52:33Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "73b89134ed6ac7dbbd427b3e36fb3d56f2c41b14",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-origin",
      "headRefOid": "8fca57b07ed16b65bc06f7376988ca32de80eefd",
      "closedAt": "2020-07-13T19:52:33Z",
      "mergedAt": "2020-07-13T19:52:33Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "47dc70b77d0db048de81bb7ded8a3dfadd19d23c"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson Does this address your concern related to \"origin server\"?",
          "createdAt": "2020-06-28T22:11:23Z",
          "updatedAt": "2020-06-28T22:11:23Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "This is looking good to me, but I'll try and re-read it again later today.\r\nI think it would be good for @MikeBishop to review this one as well.",
          "createdAt": "2020-07-11T16:20:50Z",
          "updatedAt": "2020-07-11T16:20:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NTM4MjQw",
          "commit": {
            "abbreviatedOid": "a3f8b14"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-07-10T16:30:49Z",
          "updatedAt": "2020-07-10T17:22:42Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nto network services, such as for HTTPS URLs.  SVCB records\r\nallow a service to be provided from multiple alternative endpoints, \r\neach with associated parameters (such as transport protocol\r\n```\r\n\r\nDo we want to define \"service\" and \"endpoint\" explicitly here? Being consistent seems good, but it may even be worth adding a terminology section?  We should also scrub through to see if there are other places we should use \"endpoint\". ",
              "createdAt": "2020-07-10T16:30:49Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 29,
              "body": "Is this really an \"endpoint\"?  Do we want to distinguish \"endpoints\"  (eg, ServiceMode RRs) from AliasMode which aren't really endpoints?  (For that matter, should \"ServiceMode\" be renamed as \"EndpointMode\"?  That might be its own issue.)",
              "createdAt": "2020-07-10T16:33:12Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 100,
              "body": "We should mention for HTTPS records that this is the same as the {{!RFC6454}} origin?",
              "createdAt": "2020-07-10T16:49:04Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 101,
              "body": "Is \"authority address\" defined in an RFC?  It's confusing as \"address\" is too close to A/AAAA record addresses.  Perhaps \"fully qualified authority\"?",
              "createdAt": "2020-07-10T16:53:13Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 94,
              "body": "Should we continue to have a term for the endpoint that would be used for an authority in the absence of a SVCB record (or HTTPS Alt-Svc)?   Perhaps specify that the \"fully qualified authority\" (or whetever we call it) gets used as an implicit endpoint or \"default endpoint\"?",
              "createdAt": "2020-07-10T16:56:02Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\n* Provides alternative endpoints that are authoritative for the service,\r\n```",
              "createdAt": "2020-07-10T16:57:36Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 75,
              "body": "```suggestion\r\nparameters associated with each of these alternative endpoints.\r\n```",
              "createdAt": "2020-07-10T16:58:58Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 104,
              "body": "```suggestion\r\n* An \"alternative endpoint\" is a hostname, port number, and other associated\r\n  instructions to the client on how to reach an instance of service.\r\n```",
              "createdAt": "2020-07-10T17:00:01Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 97,
              "body": "Do we want to keep this illustrative example but reword it?  I think having an example here would help.",
              "createdAt": "2020-07-10T17:01:05Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 81,
              "body": "Add \"service name\"?  (The hostname within the authority.)",
              "createdAt": "2020-07-10T17:02:41Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 154,
              "body": "```suggestion\r\nA SVCB-aware client resolves a service with hostname $HOST by attempting\r\n```",
              "createdAt": "2020-07-10T17:03:27Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 157,
              "body": "```suggestion\r\nto determine endpoint (the preferred SvcFieldValue and IP addresses for its service),\r\nusing the following procedure:\r\n```",
              "createdAt": "2020-07-10T17:05:43Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 186,
              "body": "Should it connect to the authority address or $HOST_QNAME?  The latter implies that the AliasForm SVCB record should be ignored if ServiceForm SVCB records were present and didn't work.",
              "createdAt": "2020-07-10T17:13:38Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 186,
              "body": "(This is an interesting question which may want to be its own issue for discussion.)",
              "createdAt": "2020-07-10T17:14:06Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 190,
              "body": "```suggestion\r\n5. If a SVCB record for $SVCB_QNAME does not exist, the received AAAA and/or A\r\n   records from $HOST_QNAME are the preferred IP addresses \r\n   and there is no SvcFieldValue.\r\n```",
              "createdAt": "2020-07-10T17:15:03Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 161,
              "body": "```suggestion\r\n1. Let $SVCB_QNAME be $HOST, plus appropriate prefixes for the scheme\r\n   (see {{svcb-names}}).  Let $HOST_QNAME be $HOST.\r\n```\r\n\r\n\r\n\r\nSeparate out $SVCB_HOST so we don't mutate $HOST in step 3?\r\n",
              "createdAt": "2020-07-10T17:16:04Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 163,
              "body": "```suggestion\r\n2. Issue parallel AAAA/A queries for $HOST_QNAME and a SVCB query for $SVCB_QNAME.\r\n```",
              "createdAt": "2020-07-10T17:16:45Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 170,
              "body": "```suggestion\r\n   clients MUST set $HOST_QNAME and $SVCB_QNAME to SvcDomainName (without\r\n```",
              "createdAt": "2020-07-10T17:17:06Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 186,
              "body": "```suggestion\r\n   If none of the options succeed, the client SHOULD connect to $HOST_QNAME directly.\r\n   If that fails, the client SHOULD fall back to $HOST.\r\n```\r\n(SHOULD or MAY for the final fall back to $HOST?)",
              "createdAt": "2020-07-10T17:19:28Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 101,
              "body": "Given how we use this, either \"default endpoint\" or \"implicit endpoint\" might be better.",
              "createdAt": "2020-07-10T17:22:32Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NjcyNjkz",
          "commit": {
            "abbreviatedOid": "13d2ad1"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-10T20:08:09Z",
          "updatedAt": "2020-07-10T20:08:09Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "How about \"authority endpoint\"?",
              "createdAt": "2020-07-10T20:08:09Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzA0Njkw",
          "commit": {
            "abbreviatedOid": "db52d3a"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-10T21:14:48Z",
          "updatedAt": "2020-07-10T21:14:49Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "That's better.",
              "createdAt": "2020-07-10T21:14:48Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzA0OTg4",
          "commit": {
            "abbreviatedOid": "db52d3a"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-10T21:15:26Z",
          "updatedAt": "2020-07-10T21:15:27Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "It sounds like \"authority endpoint\"?",
              "createdAt": "2020-07-10T21:15:27Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NjgwNjEz",
          "commit": {
            "abbreviatedOid": "ed6ce1b"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "> (SHOULD or MAY for the final fall back to $HOST?)\r\n\r\nI changed this to MAY, and incorporated it for both AliasForm and ServiceForm.  This seems to simplify the logic.\r\n\r\nI also made a number of changes throughout the document for consistency with these changes.",
          "createdAt": "2020-07-10T20:24:38Z",
          "updatedAt": "2020-07-10T21:54:45Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "I think this is covered by the sentence above equation \"service\" and \"origin\".",
              "createdAt": "2020-07-10T20:24:38Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 94,
              "body": "I think this is covered by \"authority endpoint\".  EDIT: You got there first.",
              "createdAt": "2020-07-10T20:24:51Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 29,
              "body": "This is just an example, so it seems at least possible that there is an endpoint somewhere at svc.example.net to which the owner wants to delegate.\r\n\r\nI think \"EndpointMode\" or \"BindingMode\" would be an improvement, but let's not change that here.",
              "createdAt": "2020-07-10T20:25:57Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 100,
              "body": "OK, done.",
              "createdAt": "2020-07-10T20:27:03Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 81,
              "body": "Done",
              "createdAt": "2020-07-10T20:29:11Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NTQzNTEx",
          "commit": {
            "abbreviatedOid": "d53f1e7"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-13T19:36:51Z",
          "updatedAt": "2020-07-13T19:46:36Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nto network services, such as for HTTPS origins.  SVCB records\r\n```\r\nNot text changed by this PR, but I'd probably talk about the HTTPS origin as one of the services being described, rather than the URL.  In fact, this is explicitly stated further down.",
              "createdAt": "2020-07-13T19:36:51Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            },
            {
              "originalPosition": 39,
              "body": "While this doesn't need to be addressed before merging, I'm not certain that the concept of \"authoritative\" is the same in all possible protocols, particularly ones where the scope of a \"service\" might vary.  We might want to consider whether that's a term we want to keep as well.",
              "createdAt": "2020-07-13T19:45:00Z",
              "updatedAt": "2020-07-13T19:50:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NTUzNDY1",
          "commit": {
            "abbreviatedOid": "8fca57b"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-13T19:52:25Z",
          "updatedAt": "2020-07-13T19:52:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 205,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQyNDA2MzE5",
      "title": "Define a \"mandatory\" SvcParamKey",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/205",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #166",
      "createdAt": "2020-07-01T02:46:45Z",
      "updatedAt": "2020-07-03T02:54:46Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "9a3311b91969b2aabb83f444a6fa74e9d640fcd0",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-mandatory",
      "headRefOid": "8a237bc05213d139c538af4eb02952ad0d1fabf1",
      "closedAt": "2020-07-03T02:54:46Z",
      "mergedAt": "2020-07-03T02:54:46Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "7ae1ce79b8501f6d35e3dafbcc70c10b7fccbe40"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNTEzMTU2",
          "commit": {
            "abbreviatedOid": "83f89c4"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-01T02:53:56Z",
          "updatedAt": "2020-07-01T02:53:56Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Overriding or adding to the default set?  The later seems more usable?",
              "createdAt": "2020-07-01T02:53:56Z",
              "updatedAt": "2020-07-03T02:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNTEzNzE4",
          "commit": {
            "abbreviatedOid": "83f89c4"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-01T02:56:02Z",
          "updatedAt": "2020-07-01T02:56:02Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Is there a reason to switch between the words \"essential\" and \"mandatory\"?  Using both is somewhat distracting.",
              "createdAt": "2020-07-01T02:56:02Z",
              "updatedAt": "2020-07-03T02:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNTE1MTUy",
          "commit": {
            "abbreviatedOid": "83f89c4"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-01T03:01:29Z",
          "updatedAt": "2020-07-01T03:01:29Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Should explicitly state that if the set of compatible ServiceForm HTTPS RRs is empty (such as due to all requiring a mandatory key not supported) that clients MUST NOT apply the HSTS-like behavior?  (It's implicit here, but may be worth calling out outright.)",
              "createdAt": "2020-07-01T03:01:29Z",
              "updatedAt": "2020-07-03T02:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNTE1NTEz",
          "commit": {
            "abbreviatedOid": "83f89c4"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-01T03:02:46Z",
          "updatedAt": "2020-07-01T03:02:46Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Did we want to give it ID 0 ?  (I liked the idea of having it first.)  I guess we can't make it 1 because we don't want to move alpn? ",
              "createdAt": "2020-07-01T03:02:46Z",
              "updatedAt": "2020-07-03T02:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNTE1ODcy",
          "commit": {
            "abbreviatedOid": "83f89c4"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-01T03:04:06Z",
          "updatedAt": "2020-07-01T03:04:06Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I'd add a note here that if no ServiceForm RRs in the RRset are compatible then the client must treat the RRset as empty.",
              "createdAt": "2020-07-01T03:04:06Z",
              "updatedAt": "2020-07-03T02:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNTIxNjY0",
          "commit": {
            "abbreviatedOid": "83f89c4"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-01T03:26:05Z",
          "updatedAt": "2020-07-01T03:26:06Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I\u2019d prefer to stick with \u201cmandatory\u201d and \u201cdefault mandatory set\u201d.  Agreed that the mix is a bit confusing. ",
              "createdAt": "2020-07-01T03:26:05Z",
              "updatedAt": "2020-07-03T02:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNTIyMDE5",
          "commit": {
            "abbreviatedOid": "83f89c4"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-01T03:27:24Z",
          "updatedAt": "2020-07-01T03:27:25Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "I\u2019d rather us not move alpn if that\u2019s okay :)\r\n\r\nAny reason not to give this 0? It is a meta-key, so making it 0 seems elegant. ",
              "createdAt": "2020-07-01T03:27:24Z",
              "updatedAt": "2020-07-03T02:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNTMzMDA3",
          "commit": {
            "abbreviatedOid": "83f89c4"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-01T04:11:03Z",
          "updatedAt": "2020-07-01T04:11:03Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "We'd previously discussed leaving 0 unassigned so that APIs could use it to mean something like \"null\".  If we don't think that's actually useful then I'm OK with making this 0.\r\n\r\nEDIT: I think the use case would be for a function that parses a key name and returns the uint16 code.  In some programming languages, it might be convenient to be able to return 0 if the name couldn't be parsed.  Naturally, there are also many other possible solutions.",
              "createdAt": "2020-07-01T04:11:03Z",
              "updatedAt": "2020-07-03T02:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNTMzNzg2",
          "commit": {
            "abbreviatedOid": "83f89c4"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-01T04:14:03Z",
          "updatedAt": "2020-07-01T04:14:03Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I chose this wording because \"mandatory\", in my view, is extremely confusing: \"mandatory\" sounds like domain owners are required to publish or use the \"mandatory\" keys, and clients are expected to enforce that they are present (neither of which is true).  These keys aren't \"mandatory\"; they're \"mandatory-to-understand-if-present\".  \"Non-ignorable\".\r\n\r\nIf you can think of a clearer way to express this I would appreciate a suggestion!",
              "createdAt": "2020-07-01T04:14:03Z",
              "updatedAt": "2020-07-03T02:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNTM0MTc2",
          "commit": {
            "abbreviatedOid": "83f89c4"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-01T04:15:35Z",
          "updatedAt": "2020-07-01T04:15:35Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Overriding seems more powerful, since it allows making default-essential keys optional.  Given that this feature should be very rare, I figured usability was not too important.\r\n\r\nThen again, maybe clients have to have an understanding of all the default-essential keys for a scheme anyway, so I guess we can just make it additive.",
              "createdAt": "2020-07-01T04:15:35Z",
              "updatedAt": "2020-07-03T02:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMzExOTk0",
          "commit": {
            "abbreviatedOid": "44fc195"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-02T02:39:32Z",
          "updatedAt": "2020-07-02T02:39:33Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Changed: I made it additional instead.",
              "createdAt": "2020-07-02T02:39:33Z",
              "updatedAt": "2020-07-03T02:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMzEyMTIy",
          "commit": {
            "abbreviatedOid": "44fc195"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-02T02:39:58Z",
          "updatedAt": "2020-07-02T02:39:59Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I changed this to \"mandatory\"/\"automatically mandatory\".",
              "createdAt": "2020-07-02T02:39:58Z",
              "updatedAt": "2020-07-03T02:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMzEyMTcy",
          "commit": {
            "abbreviatedOid": "44fc195"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-02T02:40:08Z",
          "updatedAt": "2020-07-02T02:40:08Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Done",
              "createdAt": "2020-07-02T02:40:08Z",
              "updatedAt": "2020-07-03T02:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMzEyNDQ4",
          "commit": {
            "abbreviatedOid": "44fc195"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-02T02:41:04Z",
          "updatedAt": "2020-07-02T02:41:04Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "I changed \"mandatory\" to ID 0 and made key65535 (a.k.a. -1) explicitly reserved as \"invalid key\".",
              "createdAt": "2020-07-02T02:41:04Z",
              "updatedAt": "2020-07-03T02:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMzEyNjM3",
          "commit": {
            "abbreviatedOid": "44fc195"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-02T02:41:45Z",
          "updatedAt": "2020-07-02T02:41:45Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I think that is already mandated by each section on client behavior, but I added a non-normative note to this effect.",
              "createdAt": "2020-07-02T02:41:45Z",
              "updatedAt": "2020-07-03T02:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMzE1MTk4",
          "commit": {
            "abbreviatedOid": "44fc195"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-02T02:50:21Z",
          "updatedAt": "2020-07-02T02:50:21Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Are \"automatically mandatory\" ones allowed to appear?  Is this \"MUST NOT appear more than once\" needed as a contraint for Presentation Format?\r\n(May \"automatically mandatory\" entries appear in the wire format list?)",
              "createdAt": "2020-07-02T02:50:21Z",
              "updatedAt": "2020-07-03T02:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMzE1NTcw",
          "commit": {
            "abbreviatedOid": "44fc195"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-02T02:51:35Z",
          "updatedAt": "2020-07-02T02:51:36Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Perhaps reframe as:\r\n\r\n\"This SvcParamKey is always automatically mandatory.  Automatically mandatory entries MUST NOT appear in the value list.\"\r\n\r\n(Unless we want to allow them to appear as doing so is idempotent?)",
              "createdAt": "2020-07-02T02:51:36Z",
              "updatedAt": "2020-07-03T02:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMTA2MzYw",
          "commit": {
            "abbreviatedOid": "8a237bc"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-03T02:05:24Z",
          "updatedAt": "2020-07-03T02:05:24Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "> Are \"automatically mandatory\" ones allowed to appear?\r\n\r\nI updated the text to make this a \"SHOULD NOT\".\r\n\r\n> Is this \"MUST NOT appear more than once\" needed as a contraint for Presentation Format?\r\n\r\nNo, but there's no use in having duplicates, and it's easy for the zone file parser to detect.",
              "createdAt": "2020-07-03T02:05:24Z",
              "updatedAt": "2020-07-03T02:05:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMTA2Njg4",
          "commit": {
            "abbreviatedOid": "8a237bc"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-03T02:06:51Z",
          "updatedAt": "2020-07-03T02:06:51Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I don't want to make this \"MUST NOT\", because zone file parsers can't detect it (they are not scheme-aware), and I would like to avoid introducing syntax errors that are caught by clients but not by the zone file parser.",
              "createdAt": "2020-07-03T02:06:51Z",
              "updatedAt": "2020-07-03T02:06:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMTE3OTEw",
          "commit": {
            "abbreviatedOid": "8a237bc"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-03T02:54:39Z",
          "updatedAt": "2020-07-03T02:54:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 207,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ1NzE4MTQy",
      "title": "Recommend against DNAME-after-SVCB",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/207",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #206",
      "createdAt": "2020-07-07T22:12:36Z",
      "updatedAt": "2020-07-13T03:45:35Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "7ae1ce79b8501f6d35e3dafbcc70c10b7fccbe40",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-dname",
      "headRefOid": "2f9dd7d2084e60313e36dd3b068964832074af68",
      "closedAt": "2020-07-13T03:45:35Z",
      "mergedAt": "2020-07-13T03:45:35Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "6d310b378ba4273694a71bfcb42f4c4bd8218e35"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@marka63, does this work?",
          "createdAt": "2020-07-07T22:12:58Z",
          "updatedAt": "2020-07-07T22:12:58Z"
        },
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "yes, that should be fine",
          "createdAt": "2020-07-07T22:52:42Z",
          "updatedAt": "2020-07-07T22:52:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTYzOTkx",
          "commit": {
            "abbreviatedOid": "2f9dd7d"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-13T03:45:30Z",
          "updatedAt": "2020-07-13T03:45:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 208,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3MDgxMDg1",
      "title": "Note on why priority is 16 bits",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/208",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves issue #184",
      "createdAt": "2020-07-09T20:37:02Z",
      "updatedAt": "2020-07-10T17:23:28Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "08a5c8ac0e37848318fa9dc4929b4ee5d85d4e75",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-why-16-bits",
      "headRefOid": "68480d8be5803ac69dfc3ba439be05f144ae9edf",
      "closedAt": "2020-07-10T17:23:28Z",
      "mergedAt": "2020-07-10T17:23:28Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "191b811735df6aef995593444bf7d07df8d73496"
      },
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "(Note this uses an alternate CamelCase name as proposed elsewhere.)",
          "createdAt": "2020-07-09T20:38:20Z",
          "updatedAt": "2020-07-09T20:38:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1OTg2NjE3",
          "commit": {
            "abbreviatedOid": "68480d8"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-09T21:37:40Z",
          "updatedAt": "2020-07-09T21:37:40Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MDczODIz",
          "commit": {
            "abbreviatedOid": "68480d8"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-10T01:52:15Z",
          "updatedAt": "2020-07-10T01:52:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 209,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3MTQyNDA3",
      "title": "Improve description of AliasForm",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/209",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #187, #188",
      "createdAt": "2020-07-09T23:26:04Z",
      "updatedAt": "2020-07-14T03:40:34Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "08a5c8ac0e37848318fa9dc4929b4ee5d85d4e75",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-alias",
      "headRefOid": "b8b95c57412360fd443354048252f68df09d5588",
      "closedAt": "2020-07-13T03:45:01Z",
      "mergedAt": "2020-07-13T03:45:00Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "3474aa7f38ac13e953ba02486f7793e29bf0049d"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, this guidance could become obsolete if recursive resolvers are\nuniversally upgraded to follow SVCB aliases.  That day seems likely to be a\nlong way off, but we can certainly adjust the wording here.\n\nOn Mon, Jul 13, 2020, 11:01 PM Martin Thomson <notifications@github.com>\nwrote:\n\n> *@martinthomson* commented on this pull request.\n> ------------------------------\n>\n> In draft-ietf-dnsop-svcb-https.md\n> <https://github.com/MikeBishop/dns-alt-svc/pull/209#discussion_r454057512>\n> :\n>\n> > +requiring a corresponding change to example.com.  Note that if\n> +foosvc.example.net promises to always publish a SVCB record, this AliasForm\n> +record can be replaced by a CNAME, which would likely improve performance.\n>\n> Isn't this only true until resolvers start automatically following\n> AliasForm references?\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/MikeBishop/dns-alt-svc/pull/209#pullrequestreview-447737760>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AABO3SPM7S7ERVKB7LUYHJLR3PC7LANCNFSM4OWCCCJA>\n> .\n>\n",
          "createdAt": "2020-07-14T03:12:21Z",
          "updatedAt": "2020-07-14T03:12:21Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You might be willing to make a move sooner than when every resolver collapses the indirection.",
          "createdAt": "2020-07-14T03:40:34Z",
          "updatedAt": "2020-07-14T03:40:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NTI4NTM4",
          "commit": {
            "abbreviatedOid": "e0fab0f"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This one still has some pending comments...",
          "createdAt": "2020-07-10T16:15:52Z",
          "updatedAt": "2020-07-12T03:40:02Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "did we want to use a word other than \"origin\" here?",
              "createdAt": "2020-07-10T16:15:52Z",
              "updatedAt": "2020-07-12T12:35:20Z"
            },
            {
              "originalPosition": 25,
              "body": "The \"wanted to point requests to\" took me a few times to read. \r\n\r\n```suggestion\r\nFor example, the operator of foo://example.com:8080 could\r\npoint requests to a service operating at foosvc.example.net\r\nby publishing:\r\n```",
              "createdAt": "2020-07-10T16:20:20Z",
              "updatedAt": "2020-07-12T12:35:20Z"
            },
            {
              "originalPosition": 32,
              "body": "Inconsistent on use of \".\" in names and it makes this harder to read.\r\n```suggestion\r\nfoosvc.example.net promises to always publish a SVCB record, this AliasForm\r\n```",
              "createdAt": "2020-07-10T16:21:41Z",
              "updatedAt": "2020-07-12T12:35:20Z"
            },
            {
              "originalPosition": 6,
              "body": "Per #204 perhaps use \"service\" instead?\r\n\r\n```suggestion\r\nWhen SvcRecordType is AliasForm, the SVCB record aliases a service to a\r\n```",
              "createdAt": "2020-07-10T16:24:27Z",
              "updatedAt": "2020-07-12T12:35:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODc0NjY2",
          "commit": {
            "abbreviatedOid": "b72d581"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-12T12:34:46Z",
          "updatedAt": "2020-07-12T12:34:46Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Done",
              "createdAt": "2020-07-12T12:34:46Z",
              "updatedAt": "2020-07-12T12:35:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTYzODY1",
          "commit": {
            "abbreviatedOid": "b8b95c5"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-13T03:44:55Z",
          "updatedAt": "2020-07-13T03:44:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NzM3NzYw",
          "commit": {
            "abbreviatedOid": "b8b95c5"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-14T02:18:18Z",
          "updatedAt": "2020-07-14T03:00:56Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Isn't this only true until resolvers start automatically following AliasForm references?",
              "createdAt": "2020-07-14T02:18:18Z",
              "updatedAt": "2020-07-14T03:00:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 210,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3MTY4MTg1",
      "title": "Relax normative language around downgrade attacks",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/210",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #191",
      "createdAt": "2020-07-10T01:10:50Z",
      "updatedAt": "2020-07-10T16:14:59Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "08a5c8ac0e37848318fa9dc4929b4ee5d85d4e75",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-security",
      "headRefOid": "77bd598a7a2f44b8d5d488fdcea32c852f87dfc6",
      "closedAt": "2020-07-10T16:14:59Z",
      "mergedAt": "2020-07-10T16:14:59Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "e95db73e3087891fdb1e30246aa1ceadfadcd8de"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NTI3Nzcz",
          "commit": {
            "abbreviatedOid": "77bd598"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Seems fine.  Only potential area for future improvement might be to clarify in the Security Considerations that attacks may be indistinguishable from network or software issues (to rationalize the SHOULD vs MUST), but that is also covered to some degree above and could get wordy.",
          "createdAt": "2020-07-10T16:14:43Z",
          "updatedAt": "2020-07-10T16:14:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 212,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3Njc2MTc1",
      "title": "Alias to \".\" means repudiation",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/212",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change also adjusts the advice about the use of \".\".\r\n\r\nFixes #203",
      "createdAt": "2020-07-10T23:01:27Z",
      "updatedAt": "2020-07-12T03:38:28Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "191b811735df6aef995593444bf7d07df8d73496",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-dot",
      "headRefOid": "da7826c737673b1bf882242e12be054dcdb71060",
      "closedAt": "2020-07-12T03:38:28Z",
      "mergedAt": "2020-07-12T03:38:27Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "63bf92d957cb28de9918d077253f822f84393acd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODExNjA4",
          "commit": {
            "abbreviatedOid": "ffef662"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "See comments above.  If we're going to recommend using origin hostname\r\n(which was added here and should probably be called out explicitly) we need\r\nthe safety warning.\r\n\r\nWe should also add a security consideration that untrusted recursive resolvers\r\nmight return AliasForm \".\" records as a way to block clients from accessing \r\nparticular protocols, but in a way that is more fine-grained than is possible\r\nwith NXDOMAINs injection today.",
          "createdAt": "2020-07-11T15:59:07Z",
          "updatedAt": "2020-07-11T16:14:11Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "```suggestion\r\n## Special handling of \".\" {#dot} in SvcDomainName\r\n```",
              "createdAt": "2020-07-11T15:59:07Z",
              "updatedAt": "2020-07-11T17:26:56Z"
            },
            {
              "originalPosition": 70,
              "body": "```suggestion\r\ndomain owners SHOULD minimize the use of AliasForm records, and choose\r\nSvcDomainName to be a domain for which the client will have already issued\r\naddress queries (see {{client-behavior}}), such as by using \".\" as the SvcDomainName for ServiceForm records.  The simplest SVCB configuration\r\nwould be a single ServiceForm SVCB record whose SvcDomainName is the origin hostname.  (Note that using the origin hostname as the SvcDomainName can be problematic when using {{!ECH}} \r\n({{svcparamkeys-echconfig}}) and switching between different\r\nendpoints as clients may get IP addresses for one endpoint\r\nand {{svcparamkeys-echconfig}} for a different endpoint.)\r\n```\r\n\r\nI'm not sure if the note should be moved elsewhere, but it's an important warning for explaining why using the simplest form may not be preferable.",
              "createdAt": "2020-07-11T16:10:35Z",
              "updatedAt": "2020-07-11T17:26:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODE1OTI3",
          "commit": {
            "abbreviatedOid": "fd967ee"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "> We should also add a security consideration that untrusted recursive resolvers\r\n> might return AliasForm \".\" records as a way to block clients from accessing\r\n> particular protocols, but in a way that is more fine-grained than is possible\r\n> with NXDOMAINs injection today.\r\n\r\nDone",
          "createdAt": "2020-07-11T17:09:11Z",
          "updatedAt": "2020-07-11T17:28:54Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Rather than describe a simple configuration and then advise against it, I changed this section to have an explicit example that we would actually recommend, using a layer of indirection as intended.",
              "createdAt": "2020-07-11T17:09:11Z",
              "updatedAt": "2020-07-11T17:28:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODQzMzAz",
          "commit": {
            "abbreviatedOid": "da7826c"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-12T03:37:25Z",
          "updatedAt": "2020-07-12T03:37:25Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODQzMzQ1",
          "commit": {
            "abbreviatedOid": "da7826c"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-12T03:38:21Z",
          "updatedAt": "2020-07-12T03:38:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 214,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3ODA2NzMw",
      "title": "Expand description of proxy configuration",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/214",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #190",
      "createdAt": "2020-07-11T19:21:31Z",
      "updatedAt": "2020-07-12T03:19:47Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "0ea348a7fcc88ccd183c601a50a22eecf160d9ec",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-intent",
      "headRefOid": "09128a0e120c5fa58a9c605d0a948d87135b4eaa",
      "closedAt": "2020-07-12T03:19:47Z",
      "mergedAt": "2020-07-12T03:19:47Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "15331da92a3d94d16a414091e9c883d801ea3b04"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODQyNzEw",
          "commit": {
            "abbreviatedOid": "09128a0"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-12T03:19:30Z",
          "updatedAt": "2020-07-12T03:19:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 215,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3ODA3MTc1",
      "title": "Add reference to HSTS on first use",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/215",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #181",
      "createdAt": "2020-07-11T19:25:49Z",
      "updatedAt": "2020-07-13T17:26:31Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "ba6fef7b3ad0de83b12d6b2135cb5c16293a8b55",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-hstsref",
      "headRefOid": "d953395fd7f3a187498a66537f48fb34945946a2",
      "closedAt": "2020-07-13T17:26:31Z",
      "mergedAt": "2020-07-13T17:26:31Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "73b89134ed6ac7dbbd427b3e36fb3d56f2c41b14"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODQyNjc3",
          "commit": {
            "abbreviatedOid": "58f1d81"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-12T03:18:18Z",
          "updatedAt": "2020-07-13T17:26:23Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Why wouldn't we mention the DNS RR TTL aspect?  This seems to be very confusing to people given the semi-permanency of HSTS.",
              "createdAt": "2020-07-12T03:18:18Z",
              "updatedAt": "2020-07-13T17:26:23Z"
            },
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n* Provide a HSTS-like (but DNS TTL limited) indication {{!HSTS=RFC6797}} signaling\r\n  that the HTTPS scheme should\r\n```\r\nAnother wording might be to call it \"temporary\"?  Or is the real difference that HSTS lifetimes may be much longer than typical DNS TTLs?",
              "createdAt": "2020-07-13T17:17:13Z",
              "updatedAt": "2020-07-13T17:26:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 216,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3ODA4MTcx",
      "title": "Simplify description of SRV/HTTP status",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/216",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This also removes duplicate statements about CNAME at apex.\r\n\r\nFixes #180",
      "createdAt": "2020-07-11T19:36:08Z",
      "updatedAt": "2020-07-13T03:18:37Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "0ea348a7fcc88ccd183c601a50a22eecf160d9ec",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-srv",
      "headRefOid": "8efc3d4514a8c381bb138d9c5567f1958c0e9ccd",
      "closedAt": "2020-07-13T03:18:37Z",
      "mergedAt": "2020-07-13T03:18:37Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "603fd7339e39e7b8911db17b8a1f8cb9b117d715"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODQyNjI5",
          "commit": {
            "abbreviatedOid": "e920d6f"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-07-12T03:16:34Z",
          "updatedAt": "2020-07-12T03:16:40Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I actually think this context (can't have a CNAME and NS RR at the zone apex) is helpful as this is one of the driving factors.  SRV is just one of the mechanisms that could do this.   Perhaps still include \"..., such as allowing service delegation for a zone apex name where CNAMEs aren't allowed, ...\" ?",
              "createdAt": "2020-07-12T03:16:34Z",
              "updatedAt": "2020-07-12T12:30:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODc0NDA4",
          "commit": {
            "abbreviatedOid": "8efc3d4"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-12T12:31:17Z",
          "updatedAt": "2020-07-12T12:31:17Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "OK.  Rather than duplicate the statement about CNAME-at-apex, I added a pointer back to the CNAME-at-apex bullet point.",
              "createdAt": "2020-07-12T12:31:17Z",
              "updatedAt": "2020-07-12T12:31:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTU3OTAz",
          "commit": {
            "abbreviatedOid": "8efc3d4"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-13T03:18:29Z",
          "updatedAt": "2020-07-13T03:18:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 217,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3ODE5NTkw",
      "title": "Don't use references as names",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/217",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "With this change, references are either parentheticals or nouns that\r\nname the referenced document.\r\n\r\nFixes #195",
      "createdAt": "2020-07-11T21:33:01Z",
      "updatedAt": "2020-07-13T04:06:19Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "0ea348a7fcc88ccd183c601a50a22eecf160d9ec",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-ref",
      "headRefOid": "ba4502fe320022f6b53a32cc0cd689a1d63e088a",
      "closedAt": "2020-07-13T04:05:59Z",
      "mergedAt": "2020-07-13T04:05:59Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "ba6fef7b3ad0de83b12d6b2135cb5c16293a8b55"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, merged. I promise I didn't do anything interesting.",
          "createdAt": "2020-07-13T04:06:19Z",
          "updatedAt": "2020-07-13T04:06:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTU3NjY5",
          "commit": {
            "abbreviatedOid": "ba4502f"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This looks fine but I won't have a chance to do a code-review level review of this (ie, to validate all the output as sane).  But probably fine to just merge and review later?",
          "createdAt": "2020-07-13T03:17:24Z",
          "updatedAt": "2020-07-13T03:17:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 218,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ4NDQ5MTg3",
      "title": "Update RR type numbers in text",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/218",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Update assigned rrtypes in a place we missed before",
      "createdAt": "2020-07-13T19:36:52Z",
      "updatedAt": "2020-07-13T19:56:49Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "47dc70b77d0db048de81bb7ded8a3dfadd19d23c",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-rrtype-one-more-place",
      "headRefOid": "ff9a1ef23b512094e6418ddae8cec3345ed2bcad",
      "closedAt": "2020-07-13T19:56:19Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed elsewhere...",
          "createdAt": "2020-07-13T19:56:46Z",
          "updatedAt": "2020-07-13T19:56:46Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 219,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ4NDY0OTg0",
      "title": "Update changelog",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/219",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-13T20:13:25Z",
      "updatedAt": "2020-07-13T20:23:18Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "b9693794693edcdd6eeb75b5fb4a4322730e8e58",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-changelog",
      "headRefOid": "ceb8d05d7ea3a51c332c55bf7c3266d18f9b8c7d",
      "closedAt": "2020-07-13T20:23:18Z",
      "mergedAt": "2020-07-13T20:23:18Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "0eeb68300611d512f97527724dbc5a79a393da5c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NTczNDcw",
          "commit": {
            "abbreviatedOid": "ceb8d05"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-13T20:23:09Z",
          "updatedAt": "2020-07-13T20:23:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 220,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ4NDY4NTMx",
      "title": "Use non-normative language in intro",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/220",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #182",
      "createdAt": "2020-07-13T20:20:46Z",
      "updatedAt": "2020-07-13T20:22:43Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "b9693794693edcdd6eeb75b5fb4a4322730e8e58",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-non-normative-in-intro",
      "headRefOid": "981cbe47ddf21267110c6bd805371ef9c255d64e",
      "closedAt": "2020-07-13T20:22:42Z",
      "mergedAt": "2020-07-13T20:22:42Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "1f63188a940714db51f6adf1bc0bac7e6fe5af59"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": ":+1: ",
          "createdAt": "2020-07-13T20:22:38Z",
          "updatedAt": "2020-07-13T20:22:38Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 223,
      "id": "MDExOlB1bGxSZXF1ZXN0NDUwNzA5NDg2",
      "title": " mandatory also needs MUST NOT for escape processing.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/223",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes issue #222",
      "createdAt": "2020-07-17T02:59:29Z",
      "updatedAt": "2020-07-17T03:11:15Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "0eeb68300611d512f97527724dbc5a79a393da5c",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-mandatory-no-escape",
      "headRefOid": "f52e2a70b101d3da0a9dad1655249b7752bb5cbf",
      "closedAt": "2020-07-17T03:11:15Z",
      "mergedAt": "2020-07-17T03:11:14Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "ff8c572d75f7fb70ba7d0428e1459f3994b74c86"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMzQ1NjY4",
          "commit": {
            "abbreviatedOid": "f52e2a7"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-17T03:11:08Z",
          "updatedAt": "2020-07-17T03:11:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 224,
      "id": "MDExOlB1bGxSZXF1ZXN0NDUwNzEzNDM3",
      "title": "Recursives, handling loops, and clarifying AliasMode targets",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/224",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "enygren"
      ],
      "labels": [],
      "body": "Fixes #221 \r\n\r\nChange the \"TargetName of AliasMode SHOULD NOT equal owner name\" (vs MUST NOT).\r\n\r\nClarify that recursives MUST have reasonable loop prevention.",
      "createdAt": "2020-07-17T03:06:37Z",
      "updatedAt": "2020-10-02T14:26:27Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "0eeb68300611d512f97527724dbc5a79a393da5c",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-loop-safety",
      "headRefOid": "02205e1e5aee1bb4adb25e4e2f5e135f92466273",
      "closedAt": "2020-10-02T14:26:26Z",
      "mergedAt": "2020-10-02T14:26:26Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "cbad95cad8776df499e14a9e8bd86df07dbc11f0"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Ping.  I'm happy to incorporate this if we can avoid duplicate normative language.",
          "createdAt": "2020-09-22T14:42:14Z",
          "updatedAt": "2020-09-22T14:42:14Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on discussion: \r\n* Only normative text in one place\r\n* Make this not specific to loops\r\n* Address PR #259 at the same time.  (Switch to non-normative language to describe target of an AliasMode record.)",
          "createdAt": "2020-10-01T20:21:28Z",
          "updatedAt": "2020-10-01T20:44:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMzQ2NzIw",
          "commit": {
            "abbreviatedOid": "3f507ed"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-17T03:15:30Z",
          "updatedAt": "2020-07-17T03:15:30Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "The AliasForm section already says \"To avoid unbounded alias chains, clients and recursive resolvers MUST impose a limit on the total number of SVCB aliases they will follow\".  I don't understand whether this requirement is equivalent or not.",
              "createdAt": "2020-07-17T03:15:30Z",
              "updatedAt": "2020-10-02T14:25:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTY1NDEw",
          "commit": {
            "abbreviatedOid": "3f507ed"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T02:07:30Z",
          "updatedAt": "2020-10-01T02:07:31Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "To clarify, I think we need to answer whether \"a limit on the total number of SVCB aliases\" counts as \"reasonable loop prevention\".  If it does, then this line is redundant.  If it doesn't, then the intent here is to require a specific loop-detection behavior (before hitting the alias limit), which I think would need to be stated more explicitly.",
              "createdAt": "2020-10-01T02:07:31Z",
              "updatedAt": "2020-10-02T14:25:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzAxNjE5",
          "commit": {
            "abbreviatedOid": "3f507ed"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T20:40:11Z",
          "updatedAt": "2020-10-01T20:40:12Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Chrome intends an alias limit small enough that extra loop detection beyond that would just be silly.  Please don't make me implement silly loop detection.",
              "createdAt": "2020-10-01T20:40:12Z",
              "updatedAt": "2020-10-02T14:25:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMTczNDMz",
          "commit": {
            "abbreviatedOid": "d9f6b69"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T14:14:52Z",
          "updatedAt": "2020-10-02T14:14:53Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nAAAA, and/or A records.  The TargetName SHOULD NOT be equal\r\n```",
              "createdAt": "2020-10-02T14:14:52Z",
              "updatedAt": "2020-10-02T14:25:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMTgxNDky",
          "commit": {
            "abbreviatedOid": "010e27d"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T14:24:44Z",
          "updatedAt": "2020-10-02T14:24:45Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nbe the name of a domain that resolves to SVCB\r\n(or other SVCB compatible record such as HTTPS),\r\n```",
              "createdAt": "2020-10-02T14:24:45Z",
              "updatedAt": "2020-10-02T14:25:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMTgyMDUx",
          "commit": {
            "abbreviatedOid": "1b5aa79"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T14:25:24Z",
          "updatedAt": "2020-10-02T14:25:25Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n(or other SVCB-compatible record such as HTTPS),\r\n```",
              "createdAt": "2020-10-02T14:25:24Z",
              "updatedAt": "2020-10-02T14:25:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMTgyNzk2",
          "commit": {
            "abbreviatedOid": "02205e1"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-02T14:26:15Z",
          "updatedAt": "2020-10-02T14:26:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 226,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU1MzIwMTAy",
      "title": "Update svcb-implementations.md",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/226",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Describe iOS/macOS client support.",
      "createdAt": "2020-07-22T19:48:15Z",
      "updatedAt": "2020-07-22T20:08:12Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "45773e33342d45aa862ae4a9832eb44ceb0508a9",
      "headRepository": "tfpauly/dns-alt-svc",
      "headRefName": "patch-1",
      "headRefOid": "a1d909375f1c461c7a83ec33658bafb468ff7cf4",
      "closedAt": "2020-07-22T20:08:12Z",
      "mergedAt": "2020-07-22T20:08:12Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "78ae89c07071efca05046f2d3ab0b76f77fc3db3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNjQ2MzAy",
          "commit": {
            "abbreviatedOid": "a1d9093"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-22T20:08:06Z",
          "updatedAt": "2020-07-22T20:08:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 227,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU1NjUzMTA4",
      "title": "Add more implementations",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/227",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-23T11:45:53Z",
      "updatedAt": "2020-07-23T14:15:18Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "78ae89c07071efca05046f2d3ab0b76f77fc3db3",
      "headRepository": "ghedo/dns-alt-svc",
      "headRefName": "cloudflare",
      "headRefOid": "cbda85fda20bd83178bdc8ed851fdb133e4fc024",
      "closedAt": "2020-07-23T14:15:18Z",
      "mergedAt": "2020-07-23T14:15:18Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "859c68f04d78c1da0763d631f8630a200aacdca1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 228,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU1NzU0MTky",
      "title": "Missed one SvcDomainName -> TargetName",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/228",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-23T14:35:09Z",
      "updatedAt": "2020-07-23T20:26:59Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "859c68f04d78c1da0763d631f8630a200aacdca1",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-targetname",
      "headRefOid": "de2ab8f1314ea5932f28f33ea674b3514126137c",
      "closedAt": "2020-07-23T20:26:59Z",
      "mergedAt": "2020-07-23T20:26:59Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "06bb472563d642cbe8a5c8f5d7e77d8a63b9092a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NDcwMzM2",
          "commit": {
            "abbreviatedOid": "de2ab8f"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-23T20:26:54Z",
          "updatedAt": "2020-07-23T20:26:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 230,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU4MDM1OTA2",
      "title": "Proposal: Skip the default port prefix",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/230",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wg"
      ],
      "body": "This changes the definition of \"Port Prefix Naming\" to only include the\r\n_port prefix if a non-default port is specified.  None of the examples\r\nexercise this case, and the HTTPS RR overrides it, so this only matters\r\nfor future protocol mappings that choose to follow this advice.",
      "createdAt": "2020-07-28T20:25:44Z",
      "updatedAt": "2021-02-18T19:12:35Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "bd3bd0b9e3aad9e51dbe6911f4d451cb24af5bbe",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-noport",
      "headRefOid": "334db890a8ef0ed1007c741898e0c758e831b783",
      "closedAt": "2021-02-18T19:12:33Z",
      "mergedAt": "2021-02-18T19:12:33Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "3325f69984a64b525b4f770a8dd82c69b4b0197f"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me.",
          "createdAt": "2021-02-18T17:06:07Z",
          "updatedAt": "2021-02-18T17:06:07Z"
        },
        {
          "author": "vcunat",
          "authorAssociation": "NONE",
          "body": "I see no issue with it, and reducing the depth is good for performance in case QNAME minimization is used.",
          "createdAt": "2021-02-18T18:20:16Z",
          "updatedAt": "2021-02-18T18:20:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNDQ3MTg0",
          "commit": {
            "abbreviatedOid": "334db89"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-18T17:06:13Z",
          "updatedAt": "2021-02-18T17:06:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNTU3NTI4",
          "commit": {
            "abbreviatedOid": "334db89"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "(Unless we want to give an example or be explicit about when this can be omitted?)",
          "createdAt": "2021-02-18T19:09:42Z",
          "updatedAt": "2021-02-18T19:09:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 231,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU4MDM3NDEx",
      "title": "Explain \"SVCB\" at the top",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/231",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #229",
      "createdAt": "2020-07-28T20:28:56Z",
      "updatedAt": "2020-09-22T02:24:42Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "bd3bd0b9e3aad9e51dbe6911f4d451cb24af5bbe",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-svcb",
      "headRefOid": "c27b3b4297f723d8671869bbbd99eade01242817",
      "closedAt": "2020-09-22T02:24:41Z",
      "mergedAt": "2020-09-22T02:24:41Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "2de27e5d7d836e29f373fc83fa86a63f7651f9ee"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@cbartle891 Is this better?",
          "createdAt": "2020-07-28T20:29:25Z",
          "updatedAt": "2020-07-28T20:29:25Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "NONE",
          "body": "Yes, thank you!",
          "createdAt": "2020-07-28T20:31:02Z",
          "updatedAt": "2020-07-28T20:31:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMDkyMjMw",
          "commit": {
            "abbreviatedOid": "c27b3b4"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-22T02:24:36Z",
          "updatedAt": "2020-09-22T02:24:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 233,
      "id": "MDExOlB1bGxSZXF1ZXN0NDYyOTQzNjUz",
      "title": "Remove TODOs",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/233",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-04T18:58:02Z",
      "updatedAt": "2020-09-22T02:26:45Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "b418893c912b89873ba8bde0b9751d6c31717b47",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-todo",
      "headRefOid": "9d1096316933cb32bb24510a8952ad10012cf9ac",
      "closedAt": "2020-09-22T02:26:45Z",
      "mergedAt": "2020-09-22T02:26:45Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "cbe827fdd389b298da6172cc0606a634610875c4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMDkyNzE1",
          "commit": {
            "abbreviatedOid": "9d10963"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-22T02:26:38Z",
          "updatedAt": "2020-09-22T02:26:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 234,
      "id": "MDExOlB1bGxSZXF1ZXN0NDYzMzQ5MjIy",
      "title": "Update svcb-implementations.md linking to the PowerDNS implementation",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/234",
      "state": "MERGED",
      "author": "pieterlexis",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-05T12:23:06Z",
      "updatedAt": "2020-08-05T13:20:53Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "b418893c912b89873ba8bde0b9751d6c31717b47",
      "headRepository": "pieterlexis/dns-alt-svc",
      "headRefName": "patch-1",
      "headRefOid": "85e825a7a63ca8c46c17952aee838ba5fd86021a",
      "closedAt": "2020-08-05T13:14:00Z",
      "mergedAt": "2020-08-05T13:14:00Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "77c16235459b1b84da809cf7e0bf2704aefb1bc3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 236,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY0OTM3MTcx",
      "title": "Update dnspython status.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/236",
      "state": "MERGED",
      "author": "rthalley",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "dnspython now has support for draft-ietf-dnsop-svcb-https-01 on its master branch",
      "createdAt": "2020-08-08T02:40:41Z",
      "updatedAt": "2020-08-08T15:27:14Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "77c16235459b1b84da809cf7e0bf2704aefb1bc3",
      "headRepository": "rthalley/dns-alt-svc",
      "headRefName": "master",
      "headRefOid": "8cb356e066727d45c6e784c3d9a61cf4e39daf08",
      "closedAt": "2020-08-08T15:27:14Z",
      "mergedAt": "2020-08-08T15:27:14Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "0efc21bf42c8de2e93154df100468eff5ec7839c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzODA5NTQ5",
          "commit": {
            "abbreviatedOid": "8cb356e"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-08T15:27:06Z",
          "updatedAt": "2020-08-08T15:27:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 237,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY1MDgzNDAy",
      "title": "Update svcb-implementations.md",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/237",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Update details for iOS/macOS.",
      "createdAt": "2020-08-08T23:00:57Z",
      "updatedAt": "2020-08-09T18:11:18Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "0efc21bf42c8de2e93154df100468eff5ec7839c",
      "headRepository": "tfpauly/dns-alt-svc",
      "headRefName": "patch-2",
      "headRefOid": "0cad6d1ed27c74c05cd587136cba5b21d7760e09",
      "closedAt": "2020-08-09T18:11:18Z",
      "mergedAt": "2020-08-09T18:11:18Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "105ea12b642ca7dee97111f6ae7836a3642d30ae"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 238,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY2Mjg4MDE3",
      "title": "Adjust additional section processing",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/238",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change makes the SHOULD-level requirement less specific, and adds a\r\nvery specific optional procedure that would optimize performance.",
      "createdAt": "2020-08-11T18:45:53Z",
      "updatedAt": "2020-09-16T18:44:40Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "105ea12b642ca7dee97111f6ae7836a3642d30ae",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-cname",
      "headRefOid": "af3ac8067bb303186bc409cce9a56fe8495cd189",
      "closedAt": "2020-09-16T18:44:39Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@wtoorop @marka63 This is my attempt to incorporate recent feedback regarding in-bailiwick CNAME chains.  Please review.",
          "createdAt": "2020-08-11T18:53:40Z",
          "updatedAt": "2020-08-11T18:53:40Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems like there was insufficient interest in tightening additional section processing on the mailing list, so I will close this PR.  This behavior is \"opt-in\", so it can always be defined in a later RFC if the working group decides it is desirable.",
          "createdAt": "2020-09-16T18:44:39Z",
          "updatedAt": "2020-09-16T18:44:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 241,
      "id": "MDExOlB1bGxSZXF1ZXN0NDgwNjgxODQx",
      "title": "Tjw editorial edits",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/241",
      "state": "MERGED",
      "author": "moonshiner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "One minor editorial edit, and one spelling nit. \r\n\r\n\r\n",
      "createdAt": "2020-09-06T07:59:49Z",
      "updatedAt": "2020-09-08T16:20:49Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "105ea12b642ca7dee97111f6ae7836a3642d30ae",
      "headRepository": "moonshiner/dns-alt-svc",
      "headRefName": "master",
      "headRefOid": "b7b5845f7bc55ecef69ee2a98f3ed5cd922f4a52",
      "closedAt": "2020-09-08T16:20:49Z",
      "mergedAt": "2020-09-08T16:20:49Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "b7b5845f7bc55ecef69ee2a98f3ed5cd922f4a52"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MjE2NDIz",
          "commit": {
            "abbreviatedOid": "b7b5845"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-08T14:46:48Z",
          "updatedAt": "2020-09-08T14:46:55Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Nope, singular :).  \"The algorithm ... is specified\".  We can rephrase if that sounds weird.",
              "createdAt": "2020-09-08T14:46:48Z",
              "updatedAt": "2020-09-08T14:46:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MjE4NDU2",
          "commit": {
            "abbreviatedOid": "b7b5845"
          },
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-08T14:48:49Z",
          "updatedAt": "2020-09-08T14:48:49Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Arrfg - you are right.  I did miss this ",
              "createdAt": "2020-09-08T14:48:49Z",
              "updatedAt": "2020-09-08T14:48:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 242,
      "id": "MDExOlB1bGxSZXF1ZXN0NDgxNTM4MzQz",
      "title": "cleaned up zone file examples to be more consistent",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/242",
      "state": "MERGED",
      "author": "moonshiner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "small editorial edits to make the zone fragment examples more consistent across the document. ",
      "createdAt": "2020-09-07T16:41:19Z",
      "updatedAt": "2020-09-08T16:30:57Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "105ea12b642ca7dee97111f6ae7836a3642d30ae",
      "headRepository": "moonshiner/dns-alt-svc",
      "headRefName": "tjw-editorial",
      "headRefOid": "58ece3152d2f87a7abb26360f377fb44da9a6472",
      "closedAt": "2020-09-08T16:20:47Z",
      "mergedAt": "2020-09-08T16:20:47Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "1699b948d5b9a7eb6c08568dd9dad070ac429ef8"
      },
      "comments": [
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Relative form is fine.  I am more pedantic about using complete names, as I tend to analyze zone data for other reasons. \r\nI also don't trust anything. ",
          "createdAt": "2020-09-08T16:15:38Z",
          "updatedAt": "2020-09-08T16:15:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MjIwODUx",
          "commit": {
            "abbreviatedOid": "566c9ed"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks.  I proposed changing the names to relative-form, for compactness and consistency with the other examples.  You might also want to change line 1177.",
          "createdAt": "2020-09-08T14:51:15Z",
          "updatedAt": "2020-09-08T14:59:33Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n    $ORIGIN example.com. ; Origin\r\n    foo                  3600 IN CNAME foosvc.example.net.\r\n    _8080._foo.foo       3600 IN CNAME foosvc.example.net.\r\n```",
              "createdAt": "2020-09-08T14:51:15Z",
              "updatedAt": "2020-09-08T16:15:25Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n    $ORIGIN example.net. ; Service provider zone\r\n    foosvc               3600 IN SVCB 1 . key65333=...\r\n    foosvc                300 IN AAAA 2001:db8::1\r\n```",
              "createdAt": "2020-09-08T14:52:34Z",
              "updatedAt": "2020-09-08T16:15:25Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\r\n    @ 300 IN A    192.0.2.1\r\n             AAAA 2001:db8::1\r\n```",
              "createdAt": "2020-09-08T14:53:35Z",
              "updatedAt": "2020-09-08T16:15:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MzAxNzM1",
          "commit": {
            "abbreviatedOid": "58ece31"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-08T16:20:38Z",
          "updatedAt": "2020-09-08T16:20:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 243,
      "id": "MDExOlB1bGxSZXF1ZXN0NDgyMTUyMjM0",
      "title": "Add an example of a full multi-CDN configuration",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/243",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bemasc"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2020-09-08T16:11:30Z",
      "updatedAt": "2020-10-02T15:27:27Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "105ea12b642ca7dee97111f6ae7836a3642d30ae",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-multicdn",
      "headRefOid": "4ef5bccf16b2acda078ea943b3d7cefb51b40e71",
      "closedAt": "2020-10-02T15:27:26Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "We've decided to describe a different architecture here.  @enygren will write up a proposal.",
          "createdAt": "2020-10-02T15:27:26Z",
          "updatedAt": "2020-10-02T15:27:26Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 244,
      "id": "MDExOlB1bGxSZXF1ZXN0NDgyMTY4Njgx",
      "title": "Add a forward reference to the underscore registry",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/244",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-09-08T16:39:55Z",
      "updatedAt": "2020-09-22T02:27:14Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "748869748aee219b98047820fde9ef84179d605d",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-underscore",
      "headRefOid": "df76284ce7c6f6090d749d0e9283def5af1e4e5a",
      "closedAt": "2020-09-22T02:27:14Z",
      "mergedAt": "2020-09-22T02:27:14Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "441172ba67c13093aab98e2f51ea9ccd4591bff5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMDkyODM3",
          "commit": {
            "abbreviatedOid": "df76284"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-22T02:27:09Z",
          "updatedAt": "2020-09-22T02:27:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 245,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkwNjUyNjUw",
      "title": "Update iOS description for production version",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/245",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "iOS 14 has shipped the official version, with support for SVCB/HTTPS records.",
      "createdAt": "2020-09-22T02:21:34Z",
      "updatedAt": "2020-09-22T02:24:06Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "748869748aee219b98047820fde9ef84179d605d",
      "headRepository": "tfpauly/dns-alt-svc",
      "headRefName": "patch-3",
      "headRefOid": "230a4922a00ab268c9a9ba8c8935bd1994f6a0f4",
      "closedAt": "2020-09-22T02:24:06Z",
      "mergedAt": "2020-09-22T02:24:06Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "a185991c1832f128eb5c32bb7df0924f90dea4e2"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 257,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1OTA1MDg0",
      "title": "More concise description of HTTP-based protocols",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/257",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #255",
      "createdAt": "2020-10-01T02:27:00Z",
      "updatedAt": "2020-10-01T20:38:20Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "441172ba67c13093aab98e2f51ea9ccd4591bff5",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-httpbased",
      "headRefOid": "87eff5d8212f56b113d0acd02cd29a954ca22948",
      "closedAt": "2020-10-01T20:38:20Z",
      "mergedAt": "2020-10-01T20:38:20Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "2566bf17427a097e11812c8596478b8fac1e9b26"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzAwNDE4",
          "commit": {
            "abbreviatedOid": "87eff5d"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-01T20:38:14Z",
          "updatedAt": "2020-10-01T20:38:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 258,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1OTA1Mjk0",
      "title": "Separate TTL and granularity sections",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/258",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This also includes a change to the TTL advice, which was too specific\r\nand not generally true.\r\n\r\nFixes #254",
      "createdAt": "2020-10-01T02:27:45Z",
      "updatedAt": "2020-10-01T20:39:48Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "441172ba67c13093aab98e2f51ea9ccd4591bff5",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-granularity",
      "headRefOid": "cbba3f6e50ca4611aa9b9321b00a5dc120e2c7e3",
      "closedAt": "2020-10-01T20:39:48Z",
      "mergedAt": "2020-10-01T20:39:47Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "92a0a799cb6ace2b595a47b60d26adfd3aa22d14"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzAxMzA4",
          "commit": {
            "abbreviatedOid": "cbba3f6"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-01T20:39:41Z",
          "updatedAt": "2020-10-01T20:39:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 259,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1OTA1Mzcw",
      "title": "Remove redundant requirement on Alias target RRs",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/259",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This requirement is obvious anyway, is hard to state precisely, and has\r\ngenerated confusion from multiple readers.\r\n\r\nFixes #251",
      "createdAt": "2020-10-01T02:28:03Z",
      "updatedAt": "2020-10-01T20:43:42Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "441172ba67c13093aab98e2f51ea9ccd4591bff5",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-alias-rrtype",
      "headRefOid": "93ad46a3887424ace1da7d681fa904d134f9ce6b",
      "closedAt": "2020-10-01T20:43:42Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@enygren will take a look at improving the phrasing here.",
          "createdAt": "2020-10-01T20:43:42Z",
          "updatedAt": "2020-10-01T20:43:42Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 260,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1OTA1Njkz",
      "title": "Rephrase wire format parsing error description",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/260",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #248",
      "createdAt": "2020-10-01T02:29:10Z",
      "updatedAt": "2020-10-01T20:54:34Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "441172ba67c13093aab98e2f51ea9ccd4591bff5",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-parsing",
      "headRefOid": "f6fb865805ade7401ad1bffe0fb8f19f955740c6",
      "closedAt": "2020-10-01T20:54:34Z",
      "mergedAt": "2020-10-01T20:54:34Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "516c06fbd141e2fc1566be2f43207b32eb74b73a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzA4NDIx",
          "commit": {
            "abbreviatedOid": "4447c0e"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T20:50:59Z",
          "updatedAt": "2020-10-01T20:50:59Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n* the end of the RDATA occurs within a SvcParam.\r\n```",
              "createdAt": "2020-10-01T20:50:59Z",
              "updatedAt": "2020-10-01T20:51:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzEwNjg1",
          "commit": {
            "abbreviatedOid": "f6fb865"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-01T20:54:28Z",
          "updatedAt": "2020-10-01T20:54:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 261,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1OTA1ODY5",
      "title": "Replace \"owner name\" with \"query name\"",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/261",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There are two section headers where we imply that we are talking about\r\nthe \"owner name\" of a SVCB record, but this is not actually true due to\r\nCNAMEs, aliases, etc.  This change uses \"query name\" and \"owner name\" in\r\na more consistent way, and clarifies the relationship with Attrleaf.\r\n\r\nFixes #250",
      "createdAt": "2020-10-01T02:29:51Z",
      "updatedAt": "2020-10-01T20:54:09Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "441172ba67c13093aab98e2f51ea9ccd4591bff5",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-qname",
      "headRefOid": "89ad49e3ac82a2d6c9a18ba60a578a0476213722",
      "closedAt": "2020-10-01T20:54:09Z",
      "mergedAt": "2020-10-01T20:54:09Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "48b689f13945d6a6f7458462b7da9bfeb6e95e01"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzEwNDA1",
          "commit": {
            "abbreviatedOid": "89ad49e"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-01T20:54:03Z",
          "updatedAt": "2020-10-01T20:54:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 262,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk2NjUwMDI3",
      "title": "Proposal: Simplify SvcParamKey registration policy",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/262",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wg"
      ],
      "body": "This change removes the First Come First Served registration policy\r\nand the Expert Review policy, and combines them into a single\r\nSpecification Required range, with guidelines for what constitutes a\r\nminimal specification.  The goal of this change is to avoid zone file\r\nincompatibilities that could arise from the registration of keys whose\r\npresentation format is poorly documented.",
      "createdAt": "2020-10-02T02:53:17Z",
      "updatedAt": "2021-03-15T19:16:55Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "1515e3d3124a10c85d71664eb6ad470a7a97d995",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-iana",
      "headRefOid": "99910fcc0b746463d4186e2719f7c9ce6e5b3506",
      "closedAt": "2021-03-15T19:16:51Z",
      "mergedAt": "2021-03-15T19:16:51Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "25f908144dc49d1cb3b91f90bd1f4ca453a84a12"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@tfpauly FYI, this is relevant to a discussion we had.  Assuming this policy is considered permissible by IANA, I think it should provide a better balance of flexibility and interoperability.\r\n",
          "createdAt": "2020-10-02T03:17:25Z",
          "updatedAt": "2020-10-02T03:17:25Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "TODO: replace \"empty string\" with \"invalid\".",
          "createdAt": "2020-10-23T20:36:03Z",
          "updatedAt": "2020-10-23T20:36:03Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@moonshiner (as chair) Do you think these new proposed IANA instructions will work?  For example, is the \"temporary\" instruction something that IANA can process?",
          "createdAt": "2020-10-23T20:37:14Z",
          "updatedAt": "2020-10-23T20:37:14Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bemasc can you provide more explanation for the problem for keys that don't have well-defined presentation formats?\r\n\r\nI guess my concern is that we're creating a larger barrier towards experimentation, while not really solving the issue, since we can't expect all implementations to update presentations formats in line immediately when new specifications come up.\r\n\r\nShouldn't there be some default handling for presentation formats for unknown kinds?",
          "createdAt": "2020-12-16T21:53:19Z",
          "updatedAt": "2020-12-16T21:53:19Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it'd be more acceptable to move the expert-review section to spec required if you want to ensure that there's a definition of format, or even just have instructions to the expert review to include that.\r\n\r\nAlternatively, you can just have a row in the IANA registration for the presentation format. Wouldn't that be the same effect?",
          "createdAt": "2020-12-16T21:56:11Z",
          "updatedAt": "2020-12-16T21:56:11Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> @bemasc can you provide more explanation for the problem for keys that don't have well-defined presentation formats?\r\n\r\nSuppose we're transferring a zone file from auth server implementation A to implementation B, and it contains a SVCB RR with a particular key.\r\n\r\n* If A doesn't know the key, it has to be represented in the unknown-key format.  That's fine.\r\n* If A knows the key and B doesn't, the zone file can't be transferred (parse error).  That's unfortunate but unambiguous, and easily solved: B implements support for the key, or the owner rewrites the zone file to use the unknown-key format.\r\n  * But if the key isn't publicly documented, how can B implement it?\r\n* If A and B both think they know the key, but disagree on the exact presentation format, then arbitrary failures and silent corruption are possible.\r\n  *  But if the key isn't publicly documented, how can we resolve the discrepancy?\r\n\r\nHaving named-but-undocumented SVCB keys floating around seems like a bad outcome for authoritative DNS interoperability, and therefore also for portability of domains between hosting services.\r\n\r\n> Alternatively, you can just have a row in the IANA registration for the presentation format.\r\n\r\nI think that's precisely what \"Specification Required\" means.  The conversion between wire format and presentation format won't literally fit inside an IANA registry entry, so we use a pointer to it.\r\n\r\nNote that this is not \"RFC required\".  Any document that describes the format qualifies as a \"Specification\", so long as IANA believes that it is not going to disappear.  For example, individual I-Ds are considered sufficient.",
          "createdAt": "2020-12-16T22:12:17Z",
          "updatedAt": "2020-12-16T22:12:17Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The conversion between wire format and presentation format won't literally fit inside an IANA registry entry, so we use a pointer to it.\r\n\r\nIs there any limit to what goes in the IANA registry? I've seen some pretty verbose registry tables.",
          "createdAt": "2020-12-17T17:45:41Z",
          "updatedAt": "2020-12-17T17:45:41Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I still think that we can specify what we need in the first-come first-served bucket. From RFC 8126:\r\n\r\n```\r\n   For the First Come First Served policy, assignments are made to\r\n   anyone on a first come, first served basis.  There is no substantive\r\n   review of the request, other than to ensure that it is well-formed\r\n   and doesn't duplicate an existing assignment.  However, requests must\r\n   include a minimal amount of clerical information, such as a point of\r\n   contact (including an email address, and sometimes a postal address)\r\n   and a brief description of how the value will be used.  Additional\r\n   information specific to the type of value requested may also need to\r\n   be provided, as defined by the namespace.\r\n```\r\n\r\nLet's just define that in order to be well-formed in the namespace, you need the zone file format.",
          "createdAt": "2021-02-18T17:04:53Z",
          "updatedAt": "2021-02-18T17:04:53Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I contacted an IANA representative and got some advice on how this works,as well as [this example](https://www.iana.org/assignments/websocket/websocket.xhtml#subprotocol-name) of a relatively recent registry that seems to be working well.  On that basis, I've changed this to FCFS and attempted to clarify the Reference requirement (now \"Format Reference\").",
          "createdAt": "2021-02-23T20:26:53Z",
          "updatedAt": "2021-02-23T20:26:53Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@tfpauly Please review.",
          "createdAt": "2021-03-03T21:37:10Z",
          "updatedAt": "2021-03-03T21:37:10Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bemasc looks good to me, thanks!",
          "createdAt": "2021-03-14T17:31:17Z",
          "updatedAt": "2021-03-14T17:31:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTE3NzAy",
          "commit": {
            "abbreviatedOid": "e076984"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-12-16T21:57:41Z",
          "updatedAt": "2020-12-16T21:57:47Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "This temporary first-come-first-served seems awkward. I think requiring the IANA registration to define the presentation format is much simpler and consistent with IANA policy.",
              "createdAt": "2020-12-16T21:57:42Z",
              "updatedAt": "2021-02-24T16:40:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTMwOTI3",
          "commit": {
            "abbreviatedOid": "e076984"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-16T22:19:32Z",
          "updatedAt": "2020-12-16T22:19:32Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Does that mean you're OK with having to specify the presentation format before IANA allocates you a number?  Remember that FCFS doesn't mean you get to choose your number (except at IANA's discretion).",
              "createdAt": "2020-12-16T22:19:32Z",
              "updatedAt": "2021-02-24T16:40:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0ODM5NDAy",
          "commit": {
            "abbreviatedOid": "e076984"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-17T17:43:25Z",
          "updatedAt": "2020-12-17T17:43:25Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Yeah, I think it's quite reasonable to have to give information like that on the allocation.",
              "createdAt": "2020-12-17T17:43:25Z",
              "updatedAt": "2021-02-24T16:40:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0ODkxMzc5",
          "commit": {
            "abbreviatedOid": "e076984"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-17T18:49:22Z",
          "updatedAt": "2020-12-17T18:49:23Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "The apparent goal of this text is to be able to claim a code-point for experimental purposes before the presentation format is fixed.  RFC 7120 requires any early allocations to be from within the IETF, and for the implementation to be fully stable.  FCFS-to-reserve is an end-run around those requirements.  (And something that IANA specifically says [does not exist](https://www.iana.org/help/protocol-registration):  \"There is an early allocation process available, but there is no reservation system.\")  Is the intended audience here non-IETF and/or unstable usage?  If not, let's just stick with early allocation.\r\n\r\nNote that there is still a Private Use range, which would work as a place to implement until the specification is stable enough for EA.",
              "createdAt": "2020-12-17T18:49:23Z",
              "updatedAt": "2021-02-24T16:40:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2NzQ4MjMx",
          "commit": {
            "abbreviatedOid": "e076984"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-22T00:39:41Z",
          "updatedAt": "2020-12-22T00:39:42Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I don't think the FCFS range should be meant for code points that are intended to be later reserved and standardized. Rather, I'd expect them to be used for non-private use for specs that aren't fully standardized, but have value for deploying and support. Stable specs and RFCs would use the more official space once they have final formats, etc.\r\n\r\nAn example is how Oblivious DoH is using a value in the FCFS range with a specific definition that is used for interoperating implementations on the public Internet; it's well-defined, but it may not be the same as some later RFC that could eventually take precedence.",
              "createdAt": "2020-12-22T00:39:41Z",
              "updatedAt": "2021-02-24T16:40:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMjc5MzEy",
          "commit": {
            "abbreviatedOid": "b1c1eeb"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-06T02:11:27Z",
          "updatedAt": "2021-01-06T02:11:27Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Per @MikeBishop's observation, I've removed the sentence on temporary reservation.\r\n\r\nOblivious DoH would be in violation of the policy either way.  FCFS doesn't mean \"take a number\"; it means \"ask and ye shall receive\".  However, I think \"Specification Required\" should work fine for Oblivious DoH.  You have a specification (an I-D) that defines the presentation format unambiguously, so you meet the criteria.  Done.",
              "createdAt": "2021-01-06T02:11:27Z",
              "updatedAt": "2021-02-24T16:40:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjExNzE5NTA5",
          "commit": {
            "abbreviatedOid": "99910fc"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-14T17:31:25Z",
          "updatedAt": "2021-03-14T17:31:25Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjEyNTUxMjA4",
          "commit": {
            "abbreviatedOid": "99910fc"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-15T19:05:50Z",
          "updatedAt": "2021-03-15T19:05:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 263,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk3MDMzODgx",
      "title": "Adjust fallback behavior",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/263",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "enygren"
      ],
      "labels": [],
      "body": "Editorial changes only, to clarify the fallback sequence.\r\n\r\nFixes #256",
      "createdAt": "2020-10-02T17:13:57Z",
      "updatedAt": "2020-11-02T15:43:34Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "cbad95cad8776df499e14a9e8bd86df07dbc11f0",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-fallback",
      "headRefOid": "6946673a91503ddafbb346b20ce182cbcc0569db",
      "closedAt": "2020-11-02T15:43:34Z",
      "mergedAt": "2020-11-02T15:43:34Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "56f5b907c6c639d0345c12bce68dd5aa48a6b8ce"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@squarooticus FYI, this is the change based on your suggestion in #256.",
          "createdAt": "2020-10-26T20:25:13Z",
          "updatedAt": "2020-10-26T20:25:13Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMzQ5MTU0",
          "commit": {
            "abbreviatedOid": "5afc6a6"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "On re-reading a few times, I think it would help to be crystal clear that if Step 5 is reached due to $SVCB_QNAME not having a SVCB record then the A/AAAA ($ADDR_QNAME) must be used instead.  In the section where we talk about DNSSEC it may make sense to say that authoritative answers (NODATA/NOERROR and NXDOMAIN) for SVCB records are acceptable and should result in $ADDR_QNAME fallback.",
          "createdAt": "2020-10-30T03:07:56Z",
          "updatedAt": "2020-10-30T03:13:18Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n5. At this point there are no usable ServiceMode records, either because $SVCB_QNAME has no SVCB records or because no SVCB records have acceptable parameters. In this case, clients SHALL connect to the\r\n```",
              "createdAt": "2020-10-30T03:07:56Z",
              "updatedAt": "2020-10-30T15:56:15Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n   If there are no usable ServiceMode records, clients MUST go to step 5.  If all attempts fail, clients SHOULD go to step 5 (except as noted in\r\n```",
              "createdAt": "2020-10-30T03:10:09Z",
              "updatedAt": "2020-10-30T15:56:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNzY4MDg0",
          "commit": {
            "abbreviatedOid": "ea0aaf9"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-30T15:16:31Z",
          "updatedAt": "2020-10-30T15:16:31Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "OK, I incorporated a version of this change.",
              "createdAt": "2020-10-30T15:16:31Z",
              "updatedAt": "2020-10-30T15:56:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNzY4NzEw",
          "commit": {
            "abbreviatedOid": "ea0aaf9"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-30T15:17:14Z",
          "updatedAt": "2020-10-30T15:17:14Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\"Usable\" is ambiguous here.  I expanded this section and moved to our notion of \"compatible\" records (which may not have existed yet when we last updated this text).",
              "createdAt": "2020-10-30T15:17:14Z",
              "updatedAt": "2020-10-30T15:56:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNzkzOTI2",
          "commit": {
            "abbreviatedOid": "ea0aaf9"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-30T15:41:07Z",
          "updatedAt": "2020-10-30T15:41:07Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Should we rename this subsection from \"mandatory\" to \"ServiceMode RR compatibility and mandatory keys\" ?  That might be more descriptive?",
              "createdAt": "2020-10-30T15:41:07Z",
              "updatedAt": "2020-10-30T15:56:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNzk1MzE4",
          "commit": {
            "abbreviatedOid": "ea0aaf9"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looking good other than the minor remaining questions.",
          "createdAt": "2020-10-30T15:42:41Z",
          "updatedAt": "2020-10-30T15:43:01Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Should we clear on what it should do?  (eg, fail the connection?  or use the failed-to-validate SVCB response?   I assume the former, but a little ambiguous here.)",
              "createdAt": "2020-10-30T15:42:41Z",
              "updatedAt": "2020-10-30T15:56:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwODA3NjQ1",
          "commit": {
            "abbreviatedOid": "6946673"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-30T15:56:24Z",
          "updatedAt": "2020-10-30T15:56:24Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Done",
              "createdAt": "2020-10-30T15:56:24Z",
              "updatedAt": "2020-10-30T15:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwODA3Nzcw",
          "commit": {
            "abbreviatedOid": "6946673"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-30T15:56:32Z",
          "updatedAt": "2020-10-30T15:56:33Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "OK, done",
              "createdAt": "2020-10-30T15:56:32Z",
              "updatedAt": "2020-10-30T15:56:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 265,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk3MDczNTI3",
      "title": "Add a note about the one-scheme-per-name rule",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/265",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change also combines all advice about zone structures and example\r\nzones into one section.",
      "createdAt": "2020-10-02T18:40:04Z",
      "updatedAt": "2020-10-07T19:58:10Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "cbad95cad8776df499e14a9e8bd86df07dbc11f0",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-flex",
      "headRefOid": "e5b0523a0e7f7af21966a260d055861d164e5850",
      "closedAt": "2020-10-07T19:58:06Z",
      "mergedAt": "2020-10-07T19:58:06Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "a0b4a126baa81c6cc227c796d6826fdd06767d2f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MjA1NzQ0",
          "commit": {
            "abbreviatedOid": "e5b0523"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-07T19:36:35Z",
          "updatedAt": "2020-10-07T19:36:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 267,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk3MTQzNzIz",
      "title": "Unify text regarding SvcPriority",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/267",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This text was divided across two subsections.  This change also adjusts\r\nthe title of the \"Modes\" section, whose subsections were broader than\r\njust the two modes.\r\n\r\nAddresses #266",
      "createdAt": "2020-10-02T21:28:39Z",
      "updatedAt": "2020-10-07T19:56:08Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "cbad95cad8776df499e14a9e8bd86df07dbc11f0",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-pri",
      "headRefOid": "8b12ed23eef95a4734b89487bde437f05457f589",
      "closedAt": "2020-10-07T19:56:08Z",
      "mergedAt": "2020-10-07T19:56:08Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "e814761abd7d7e023c883036aed63926383d2d81"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MjA3ODQx",
          "commit": {
            "abbreviatedOid": "8b12ed2"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-07T19:39:49Z",
          "updatedAt": "2020-10-07T19:39:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 269,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk4NzgxMzk1",
      "title": "Clarify rules for SvcParams in AliasMode",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/269",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #266",
      "createdAt": "2020-10-06T19:19:02Z",
      "updatedAt": "2020-10-07T20:33:26Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "cbad95cad8776df499e14a9e8bd86df07dbc11f0",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-alias-params",
      "headRefOid": "be82cb038488977aa0d224f27758b5c93de7314e",
      "closedAt": "2020-10-07T20:33:26Z",
      "mergedAt": "2020-10-07T20:33:26Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "4c4a85a91bd2264cd6d29c63b4743819bb40eca7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MjQ0Njk3",
          "commit": {
            "abbreviatedOid": "be82cb0"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-07T20:33:20Z",
          "updatedAt": "2020-10-07T20:33:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 270,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk4ODAwNTU1",
      "title": "Move multi-value references into the keys",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/270",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #247",
      "createdAt": "2020-10-06T19:56:04Z",
      "updatedAt": "2020-10-26T20:22:05Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "cbad95cad8776df499e14a9e8bd86df07dbc11f0",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-multivalue",
      "headRefOid": "5148c97edf76733baf6c90194465e85b646008e3",
      "closedAt": "2020-10-26T20:22:05Z",
      "mergedAt": "2020-10-26T20:22:05Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "1515e3d3124a10c85d71664eb6ad470a7a97d995"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I added a definition to try to make \"value-list\" a first-class term.",
          "createdAt": "2020-10-26T20:20:22Z",
          "updatedAt": "2020-10-26T20:20:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1Nzk5MTkw",
          "commit": {
            "abbreviatedOid": "3a33136"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "We should define \"value list\" somewhere before its first use. (currently on line 749)  Otherwise it just gets used there (and subsequently) with no context.  Is \"value list\" a first class thing?",
          "createdAt": "2020-10-23T15:53:40Z",
          "updatedAt": "2020-10-23T15:53:40Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MTQ0OTM5",
          "commit": {
            "abbreviatedOid": "5148c97"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-26T20:21:59Z",
          "updatedAt": "2020-10-26T20:21:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 271,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk4ODg3ODgz",
      "title": "Add an example of a full Multi-CDN configuration.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/271",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-06T23:22:56Z",
      "updatedAt": "2020-10-23T20:09:05Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "a0b4a126baa81c6cc227c796d6826fdd06767d2f",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-multicdn",
      "headRefOid": "49b208c7eb3a68860eb045fe38312f5c539da727",
      "closedAt": "2020-10-23T20:09:05Z",
      "mergedAt": "2020-10-23T20:09:05Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "bb15e308f810af241ab6576d9300ac66afab7a53"
      },
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Any remaining issues?",
          "createdAt": "2020-10-23T15:48:27Z",
          "updatedAt": "2020-10-23T15:48:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNDM2NzAx",
          "commit": {
            "abbreviatedOid": "9bbdab6"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks!  Only minor comments.",
          "createdAt": "2020-10-06T23:54:14Z",
          "updatedAt": "2020-10-07T00:18:58Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "`\\t` leading to indentation weirdness",
              "createdAt": "2020-10-06T23:54:14Z",
              "updatedAt": "2020-10-23T16:06:10Z"
            },
            {
              "originalPosition": 51,
              "body": "```suggestion\r\n     cdn1 300 IN HTTPS 1 h3pool alpn=h3 echconfig=\"123...\"\r\n```",
              "createdAt": "2020-10-07T00:14:17Z",
              "updatedAt": "2020-10-23T16:06:10Z"
            },
            {
              "originalPosition": 51,
              "body": "A TTL of 300 on the HTTPS records seems low.",
              "createdAt": "2020-10-07T00:16:43Z",
              "updatedAt": "2020-10-23T16:06:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNDU3MTk1",
          "commit": {
            "abbreviatedOid": "9bbdab6"
          },
          "author": "brian-peter-dickson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-07T01:01:16Z",
          "updatedAt": "2020-10-07T01:01:17Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "This is illegal. RFC 1034 (and addition RFCs clarifying this) restrict the owner to having a single CNAME RR (and prohibit any other RRTYPE with the same owner as a CNAME).\r\nSpecifically, you cannot have two CNAME records with the same owner name (in this case \"www\".)",
              "createdAt": "2020-10-07T01:01:16Z",
              "updatedAt": "2020-10-23T16:06:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNDc3NTU4",
          "commit": {
            "abbreviatedOid": "9bbdab6"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-07T02:10:39Z",
          "updatedAt": "2020-10-07T02:10:39Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Yes.  The point is that only one of these exists in the RRset at any one time.  I'll try and clarify this.",
              "createdAt": "2020-10-07T02:10:39Z",
              "updatedAt": "2020-10-23T16:06:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNDgwMjU0",
          "commit": {
            "abbreviatedOid": "5c4fa28"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-07T02:18:27Z",
          "updatedAt": "2020-10-07T02:18:27Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Is the updated text better?",
              "createdAt": "2020-10-07T02:18:27Z",
              "updatedAt": "2020-10-23T16:06:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNDgwMjg3",
          "commit": {
            "abbreviatedOid": "5c4fa28"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-07T02:18:34Z",
          "updatedAt": "2020-10-07T02:18:34Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "updated",
              "createdAt": "2020-10-07T02:18:34Z",
              "updatedAt": "2020-10-23T16:06:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0ODY2NDUx",
          "commit": {
            "abbreviatedOid": "4fd9942"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "DISMISSED",
          "body": "There are some line length things here that need to be fixed, but they're minor.  The content looks good.",
          "createdAt": "2020-10-08T14:49:38Z",
          "updatedAt": "2020-10-23T19:24:24Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Probably also worth mentioning that the A/AAAA/HTTPS resolutions can follow different CNAMEs to different CDNs:\r\n- The client will properly handle the HTTPS record, but find the reference to a hostname it hasn't started resolving yet; this could be fixed by including the IP hints.\r\n- If only one CDN publishes HTTPS records, sometimes the client will receive NXDATA for the HTTPS query, but A/AAAA results for an ECH-capable CDN.",
              "createdAt": "2020-10-08T14:49:38Z",
              "updatedAt": "2020-10-23T16:06:10Z"
            },
            {
              "originalPosition": 39,
              "body": "If we need to be clearer, it might be worth moving the explanatory text from comments to regular prose, and having two distinct code blocks.  Also, this line and 1250 are too long to fit on a single line in a code block.",
              "createdAt": "2020-10-08T14:51:37Z",
              "updatedAt": "2020-10-23T16:06:10Z"
            },
            {
              "originalPosition": 62,
              "body": "This line is also too long for a code block; consider wrapping it.",
              "createdAt": "2020-10-08T14:58:01Z",
              "updatedAt": "2020-10-23T16:06:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1Nzk0NjQz",
          "commit": {
            "abbreviatedOid": "aa3889a"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T15:48:01Z",
          "updatedAt": "2020-10-23T15:48:02Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Added notes about this",
              "createdAt": "2020-10-23T15:48:01Z",
              "updatedAt": "2020-10-23T16:06:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1ODAzNjI2",
          "commit": {
            "abbreviatedOid": "aa3889a"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T15:59:05Z",
          "updatedAt": "2020-10-23T16:01:03Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "```suggestion\r\n* If not all CDNs publish HTTPS records, clients will sometimes\r\n```",
              "createdAt": "2020-10-23T15:59:05Z",
              "updatedAt": "2020-10-23T16:06:10Z"
            },
            {
              "originalPosition": 107,
              "body": "```suggestion\r\n* The A, AAAA, HTTPS resolutions are independent lookups so clients may\r\n```",
              "createdAt": "2020-10-23T15:59:46Z",
              "updatedAt": "2020-10-23T16:06:10Z"
            },
            {
              "originalPosition": 51,
              "body": "```suggestion\r\n     $ORIGIN customer.example.\r\n     www 900 IN CNAME customer.svc2.example.\r\n\r\n     ; and yet other times it contains:\r\n     $ORIGIN customer.example.\r\n```",
              "createdAt": "2020-10-23T16:00:45Z",
              "updatedAt": "2020-10-23T16:06:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1ODE1MDY2",
          "commit": {
            "abbreviatedOid": "49b208c"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-23T16:13:51Z",
          "updatedAt": "2020-10-23T16:13:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1OTQ4NzU1",
          "commit": {
            "abbreviatedOid": "49b208c"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-23T19:28:39Z",
          "updatedAt": "2020-10-23T19:28:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 272,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk5OTk1Nzg0",
      "title": "Fix nits",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/272",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Remove some trailing whitespace, update ref from RFC 5226 to RFC 8126.",
      "createdAt": "2020-10-08T15:08:39Z",
      "updatedAt": "2020-10-08T15:22:12Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "4c4a85a91bd2264cd6d29c63b4743819bb40eca7",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "mbishop/ref_nit",
      "headRefOid": "ecacdbf3dbb5c56c5fbf4730f7880a5d6d71f844",
      "closedAt": "2020-10-08T15:22:12Z",
      "mergedAt": "2020-10-08T15:22:12Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "25e540f5374700b68057bf6fc3c2c7daa8fb8599"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0ODk5NDgy",
          "commit": {
            "abbreviatedOid": "ecacdbf"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-08T15:21:49Z",
          "updatedAt": "2020-10-08T15:21:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 274,
      "id": "MDExOlB1bGxSZXF1ZXN0NTExNzk2NjA3",
      "title": "Relax the \"no recourse\" policy for HTTPS-RR-HSTS",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/274",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change removes the requirement to terminate without\r\nrecourse and expands the description of the problem.\r\n\r\nFixes #87",
      "createdAt": "2020-10-28T19:46:42Z",
      "updatedAt": "2020-12-05T15:22:29Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "1515e3d3124a10c85d71664eb6ad470a7a97d995",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-recourse",
      "headRefOid": "d0494612b82270e5c44b7ead95a3f2ffc4e8c5ee",
      "closedAt": "2020-12-05T15:22:29Z",
      "mergedAt": "2020-12-05T15:22:29Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "757ca1bbaa55954a670abda97fcad40493bdbac7"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I've converted this PR to \"draft\" status due to lack of consensus in #87.",
          "createdAt": "2020-11-05T15:39:10Z",
          "updatedAt": "2020-11-05T15:39:10Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I've substantially modified this PR to reflect the apparent consensus in #87.",
          "createdAt": "2020-12-04T22:01:04Z",
          "updatedAt": "2020-12-04T22:01:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0MzQ3Njgw",
          "commit": {
            "abbreviatedOid": "76dc567"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-05T14:59:25Z",
          "updatedAt": "2020-11-05T15:00:54Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nis revoked or expired), the client SHOULD terminate the connection.  The\r\nuser agent SHOULD NOT offer user recourse, as defined in Section 12.1 of\r\n{{!HSTS}}.  This is a subset of the requirements in Section 8.4 of {{!HSTS}}.\r\n```\r\nI don't know that a reader who wasn't already deeply familiar with HSTS would understand the \"terminate without recourse\" language without making it very explicit where to find the definition of \"without recourse.\"",
              "createdAt": "2020-11-05T14:59:25Z",
              "updatedAt": "2020-12-04T23:04:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MzI3Mjg4",
          "commit": {
            "abbreviatedOid": "20e509a"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-04T22:00:38Z",
          "updatedAt": "2020-12-04T22:00:38Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I agree.  I've expanded the explanation here.",
              "createdAt": "2020-12-04T22:00:38Z",
              "updatedAt": "2020-12-04T23:04:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MzUxODUz",
          "commit": {
            "abbreviatedOid": "20e509a"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-12-04T22:57:01Z",
          "updatedAt": "2020-12-04T22:57:09Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Is there some wording that doesn't involve the \"it\" which is a little ambiguous?\r\nPerhaps \"a client MAY choose to not provide user recourse\".",
              "createdAt": "2020-12-04T22:57:02Z",
              "updatedAt": "2020-12-04T23:04:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MzU0NjE0",
          "commit": {
            "abbreviatedOid": "20e509a"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-04T23:04:54Z",
          "updatedAt": "2020-12-04T23:04:55Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Rephrased",
              "createdAt": "2020-12-04T23:04:54Z",
              "updatedAt": "2020-12-04T23:04:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NTk0NTEz",
          "commit": {
            "abbreviatedOid": "d049461"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-05T15:20:17Z",
          "updatedAt": "2020-12-05T15:20:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 276,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEyNDkwOTM4",
      "title": "Document additional information in DNS queries",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/276",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #275",
      "createdAt": "2020-10-29T18:52:25Z",
      "updatedAt": "2020-10-30T03:15:17Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "1515e3d3124a10c85d71664eb6ad470a7a97d995",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-leak",
      "headRefOid": "bb2869fd25e159aae84b51e539a632e1cac22fc6",
      "closedAt": "2020-10-30T03:15:17Z",
      "mergedAt": "2020-10-30T03:15:16Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "d6c150627b93268df59bd87c575fed6ec60d2608"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMzUxMTUy",
          "commit": {
            "abbreviatedOid": "bb2869f"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-30T03:15:11Z",
          "updatedAt": "2020-10-30T03:15:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 277,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEyNzMwMzkx",
      "title": "Update acknowledgements",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/277",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #273\r\n\r\n(It would be good for someone else to take a pass and add others as needed.\r\nShould we sort?  They are in no particular order.)",
      "createdAt": "2020-10-30T03:18:36Z",
      "updatedAt": "2020-10-30T15:34:46Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "d6c150627b93268df59bd87c575fed6ec60d2608",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-ack-1",
      "headRefOid": "b9ff377189fc1988404011b28a4c31eccaad6ec2",
      "closedAt": "2020-10-30T15:34:46Z",
      "mergedAt": "2020-10-30T15:34:46Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "f206e7b98f1a76b4dbde168e30191fe2470e031a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNzI2NzE3",
          "commit": {
            "abbreviatedOid": "35f8e61"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-10-30T14:33:56Z",
          "updatedAt": "2020-10-30T14:34:17Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nCraig Taylor, Dan McArdle, Brian Dickson, and others for their feedback\r\n```",
              "createdAt": "2020-10-30T14:33:57Z",
              "updatedAt": "2020-10-30T14:44:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNzY3MDY0",
          "commit": {
            "abbreviatedOid": "b9ff377"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-30T15:15:18Z",
          "updatedAt": "2020-10-30T15:15:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 278,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMwOTcxMjQy",
      "title": "Firefox support for HTTPS",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/278",
      "state": "MERGED",
      "author": "ddragana",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-12-02T12:07:33Z",
      "updatedAt": "2020-12-03T16:31:25Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "3081e7c43b72814c7a60fd00c6c2fcc86cac99bc",
      "headRepository": "ddragana/dns-alt-svc",
      "headRefName": "ff",
      "headRefOid": "f74779f4576166f1af3966ab40df348d70779321",
      "closedAt": "2020-12-03T16:31:25Z",
      "mergedAt": "2020-12-03T16:31:25Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "434703e72424e99e0d6ee27ff1807dad67c821d0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MTQ1NjYz",
          "commit": {
            "abbreviatedOid": "f74779f"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-03T16:31:20Z",
          "updatedAt": "2020-12-03T16:31:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 280,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMzNzcxNDIy",
      "title": "Add warning about cross-protocol custom port issue",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/280",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #279",
      "createdAt": "2020-12-07T15:51:33Z",
      "updatedAt": "2021-01-05T01:44:17Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "757ca1bbaa55954a670abda97fcad40493bdbac7",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-port-confusion",
      "headRefOid": "e650739d9a26d3b9d2f28e5536db580d6733f631",
      "closedAt": "2021-01-05T01:44:13Z",
      "mergedAt": "2021-01-05T01:44:13Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "e318510b60c6a4f21eb0f541aa3f316e8e502938"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MzY0MTQw",
          "commit": {
            "abbreviatedOid": "e650739"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-07T17:18:49Z",
          "updatedAt": "2020-12-07T17:18:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMzYzNjAz",
          "commit": {
            "abbreviatedOid": "e650739"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-04T21:38:44Z",
          "updatedAt": "2021-01-04T21:38:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 281,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM5NzgzODg0",
      "title": "Add a mapping summary table for the HTTPS mapping",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/281",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-12-14T20:36:50Z",
      "updatedAt": "2021-01-06T17:38:14Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "e318510b60c6a4f21eb0f541aa3f316e8e502938",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-table",
      "headRefOid": "462aeb4811ce9d4ace8972e70dc49cf350020f09",
      "closedAt": "2021-01-06T17:38:08Z",
      "mergedAt": "2021-01-06T17:38:08Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "ea499189c4e492a1b623544d3a974ba366ec2c13"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@brian-peter-dickson Does this match your expectations for a summary table?",
          "createdAt": "2021-01-06T16:28:41Z",
          "updatedAt": "2021-01-06T16:28:41Z"
        },
        {
          "author": "brian-peter-dickson",
          "authorAssociation": "NONE",
          "body": "Yes, that is great, thank you.\n\nOn Wed, Jan 6, 2021 at 8:28 AM Benjamin M. Schwartz <\nnotifications@github.com> wrote:\n\n> @brian-peter-dickson <https://github.com/brian-peter-dickson> Does this\n> match your expectations for a summary table?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/MikeBishop/dns-alt-svc/pull/281#issuecomment-755407719>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ABPFI3MIFBEPBROPUQJD733SYSFURANCNFSM4U3JROIQ>\n> .\n>\n",
          "createdAt": "2021-01-06T17:23:51Z",
          "updatedAt": "2021-01-06T17:23:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxNDkyODk3",
          "commit": {
            "abbreviatedOid": "bdc4128"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-01-05T03:30:14Z",
          "updatedAt": "2021-01-05T03:34:20Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "How should we treat http (and ws/wss?) in this section?",
              "createdAt": "2021-01-05T03:30:14Z",
              "updatedAt": "2021-01-06T16:19:09Z"
            },
            {
              "originalPosition": 13,
              "body": "Include a reference for \"Port-Prefix\"?  (and/or give an example?)",
              "createdAt": "2021-01-05T03:31:15Z",
              "updatedAt": "2021-01-06T16:19:09Z"
            },
            {
              "originalPosition": 12,
              "body": "Include the RR code point in parens?",
              "createdAt": "2021-01-05T03:31:30Z",
              "updatedAt": "2021-01-06T16:19:09Z"
            },
            {
              "originalPosition": 16,
              "body": "Include a section reference?",
              "createdAt": "2021-01-05T03:31:54Z",
              "updatedAt": "2021-01-06T16:19:09Z"
            },
            {
              "originalPosition": 22,
              "body": "* What happens if a client specifies no-default-alpn but doesn't include an alpn key?\r\n* Aren't clients required to implement all of the automatically-mandatory keys?  Or just that if a server sends them but a client doesn't implement then the record is pruned?  Does this mean alpn is effectively required for clients to implement?",
              "createdAt": "2021-01-05T03:34:13Z",
              "updatedAt": "2021-01-06T16:19:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDE4MTA2",
          "commit": {
            "abbreviatedOid": "85b63de"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T18:11:54Z",
          "updatedAt": "2021-01-05T18:11:54Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "OK, I added a row for them.",
              "createdAt": "2021-01-05T18:11:54Z",
              "updatedAt": "2021-01-06T16:19:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDE4MjUz",
          "commit": {
            "abbreviatedOid": "85b63de"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T18:12:07Z",
          "updatedAt": "2021-01-05T18:12:07Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I changed this to an example/template.",
              "createdAt": "2021-01-05T18:12:07Z",
              "updatedAt": "2021-01-06T16:19:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDE4NDc3",
          "commit": {
            "abbreviatedOid": "85b63de"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T18:12:27Z",
          "updatedAt": "2021-01-05T18:12:27Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Done",
              "createdAt": "2021-01-05T18:12:27Z",
              "updatedAt": "2021-01-06T16:19:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDE4ODMx",
          "commit": {
            "abbreviatedOid": "85b63de"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T18:12:59Z",
          "updatedAt": "2021-01-05T18:12:59Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I added a reference to the overall section in the intro sentence.  I don't think we should try to squeeze references into this (non-normative) summary table.",
              "createdAt": "2021-01-05T18:12:59Z",
              "updatedAt": "2021-01-06T16:19:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDMwMjg0",
          "commit": {
            "abbreviatedOid": "3d8cb01"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T18:28:51Z",
          "updatedAt": "2021-01-05T18:28:51Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "> What happens if a client specifies no-default-alpn but doesn't include an alpn key?\r\n\r\nAssuming s/client/origin, that record is null: its set of advertised ALPNs is empty, so no client will ever attempt to use it.\r\n\r\n> Aren't clients required to implement all of the automatically-mandatory keys?\r\n\r\nFormally, no.\r\n\r\n> Or just that if a server sends them but a client doesn't implement then the record is pruned?\r\n\r\nCorrect.\r\n\r\n> Does this mean alpn is effectively required for clients to implement?\r\n\r\nThis is an interesting question.  To improve the answer, I've added a nontrivial change to this PR: I've removed \"alpn\" from the automatically mandatory keys.\r\n\r\nIf \"alpn\" is automatically mandatory, such a client would lose access to any endpoint that proactively advertised support for newer HTTP versions, which is ... paradoxical. With this change, a client that does not implement support for \"alpn\" has correct HTTP/1.1-only behavior.",
              "createdAt": "2021-01-05T18:28:51Z",
              "updatedAt": "2021-01-06T16:19:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDQyNDA3",
          "commit": {
            "abbreviatedOid": "3d8cb01"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T18:47:14Z",
          "updatedAt": "2021-01-05T18:47:15Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "> > What happens if a client specifies no-default-alpn but doesn't include an alpn key?\r\n> \r\n> Assuming s/client/origin, that record is null: its set of advertised ALPNs is empty, so no client will ever attempt to use it.\r\n> \r\n\r\nFor consistency with all the other rules for calling non-sensible stuff invalid, should this be made into a more formal \"don't do that\"? And should clients consider it malformed (at least those clients that can handle \"alpn\" if you remove it from the mandatory keys)?\r\n\r\nMaybe: 'If \"no-default-alpn\" is indictated, \"alpn\" MUST be included.  If a client that recognizes \"alpn\" SvcParamKeys receives an RR with \"no-default-alpn\" but no \"alpn\", the RR MUST be considered malformed.'\r\n",
              "createdAt": "2021-01-05T18:47:14Z",
              "updatedAt": "2021-01-06T16:19:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDUyNTM5",
          "commit": {
            "abbreviatedOid": "3d8cb01"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T19:02:08Z",
          "updatedAt": "2021-01-05T19:02:09Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "This state does violate the \"alpn list is one or more entries\" scenario, but it would be good to call it out explicitly somewhere, but likely elsewhere from this table.  (If no-default-alpn is specified without an alpn, the RR should be discarded seems like a reasonable behavior.)",
              "createdAt": "2021-01-05T19:02:08Z",
              "updatedAt": "2021-01-06T16:19:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDU3MjU4",
          "commit": {
            "abbreviatedOid": "3d8cb01"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T19:09:14Z",
          "updatedAt": "2021-01-05T19:09:27Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Opened issue #283",
              "createdAt": "2021-01-05T19:09:14Z",
              "updatedAt": "2021-01-06T16:19:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDYxMzU2",
          "commit": {
            "abbreviatedOid": "3d8cb01"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T19:15:42Z",
          "updatedAt": "2021-01-05T19:15:42Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "And split out PR #284 ",
              "createdAt": "2021-01-05T19:15:42Z",
              "updatedAt": "2021-01-06T16:19:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDYyMTU3",
          "commit": {
            "abbreviatedOid": "3d8cb01"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T19:16:59Z",
          "updatedAt": "2021-01-05T19:16:59Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Do we want a clarifying note as to what it means for alpn to not be automatically mandatory given that no-default-alpn requires alpn to be present?",
              "createdAt": "2021-01-05T19:16:59Z",
              "updatedAt": "2021-01-06T16:19:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDcwNjcx",
          "commit": {
            "abbreviatedOid": "3d8cb01"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T19:29:45Z",
          "updatedAt": "2021-01-05T19:29:45Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I don't have any clarification to add on that point.  Suggestions welcome.",
              "createdAt": "2021-01-05T19:29:45Z",
              "updatedAt": "2021-01-06T16:19:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMTAwNzk3",
          "commit": {
            "abbreviatedOid": "3d8cb01"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T20:16:09Z",
          "updatedAt": "2021-01-05T20:16:10Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "```suggestion\r\nHTTPS RRs.  The default set of ALPN IDs is the single value \"http/1.1\".\r\nClients not implementing the \"alpn\" key SHOULD behave as if the default\r\nALPN ID is present and also discard records containing no-default-alpn.\r\n```",
              "createdAt": "2021-01-05T20:16:09Z",
              "updatedAt": "2021-01-06T16:19:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMTAwODk4",
          "commit": {
            "abbreviatedOid": "3d8cb01"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T20:16:19Z",
          "updatedAt": "2021-01-05T20:16:19Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Added a suggestion above.",
              "createdAt": "2021-01-05T20:16:19Z",
              "updatedAt": "2021-01-06T16:19:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMTEzODAx",
          "commit": {
            "abbreviatedOid": "25e65e0"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T20:37:15Z",
          "updatedAt": "2021-01-05T20:37:15Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "OK, I added a variation on that sentence.",
              "createdAt": "2021-01-05T20:37:15Z",
              "updatedAt": "2021-01-06T16:19:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyODQxODQ3",
          "commit": {
            "abbreviatedOid": "25e65e0"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-06T16:14:00Z",
          "updatedAt": "2021-01-06T16:14:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 282,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM5ODE3OTgw",
      "title": "Disentangle comma-separated lists from char-string",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/282",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change allows unconditional char-string parsing to occur before\r\ninspecting the SvcParamKey in order to determine whether it is\r\nsingle-valued or multi-valued.  I've now encountered two implementations\r\nof zone file syntax that have this structure, which makes the current\r\ntext unimplementable.\r\n\r\nAddresses #268",
      "createdAt": "2020-12-14T21:41:35Z",
      "updatedAt": "2021-01-06T01:05:15Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "757ca1bbaa55954a670abda97fcad40493bdbac7",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-comma",
      "headRefOid": "636cdde1ed72a477c4c8d3b0ddad4c05129fd8db",
      "closedAt": "2021-01-05T20:12:58Z",
      "mergedAt": "2021-01-05T20:12:58Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "8ee88330f32c783d3290259e660137d445089951"
      },
      "comments": [
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "\n\n> On 6 Jan 2021, at 05:06, Tim Wicinski <notifications@github.com> wrote:\n> \n> \n> @moonshiner commented on this pull request.\n> \n> In draft-ietf-dnsop-svcb-https.md:\n> \n> >  \n> -In order to represent lists of values in zone files, this specification uses\n> -an extended version of character-string decoding that adds the use of \",\"\n> -as a delimiter after double-quote processing.  When \",\" is not escaped\n> -(by a preceding \"\\\\\" or as the escape sequence \"\\\\044\"), it separates\n> -values in the output, which is a list of 1*OCTET.  (For simplicity, empty\n> -values are not allowed.)  We refer to this modified procedure as \"value-list\n> -decoding\".\n> +In order to represent lists of items in zone files, this specification uses\n> +comma-separated lists.  When \",\" is not escaped (by a preceding \"\\\\\"), it\n> +separates items in the list.  (For simplicity, empty items are not allowed.)\n> \n> Not \"halting\" parsing, but just throwing out this record as invalid.\n> (or the behavior to halt or not to halt is up to the implementation)\n\nIf the DNS server loads the zone then it is broken.  STD13 REQUIRES that servers\nnot load a zone if there is any error detected when reading the master file.\nYou can continue processing and report multiple errors but the zone is not to\nbe loaded.\n\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n> \n\n-- \nMark Andrews, ISC\n1 Seymour St., Dundas Valley, NSW 2117, Australia\nPHONE: +61 2 9871 4742              INTERNET: marka@isc.org\n\n",
          "createdAt": "2021-01-06T01:01:55Z",
          "updatedAt": "2021-01-06T01:01:55Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks Mark. I fail to remember that more often than not. ",
          "createdAt": "2021-01-06T01:05:15Z",
          "updatedAt": "2021-01-06T01:05:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxNDk0Mzg1",
          "commit": {
            "abbreviatedOid": "465561e"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-01-05T03:36:11Z",
          "updatedAt": "2021-01-05T03:43:35Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Do we still need the \"value-list MUST NOT be empty\" constraint?",
              "createdAt": "2021-01-05T03:36:11Z",
              "updatedAt": "2021-01-05T19:40:17Z"
            },
            {
              "originalPosition": 80,
              "body": "Should we specify how empty items are handled?  (ie, clients MUST discard records where the value-list is empty or where a 'value' is empty?)",
              "createdAt": "2021-01-05T03:40:17Z",
              "updatedAt": "2021-01-05T19:40:17Z"
            },
            {
              "originalPosition": 80,
              "body": "(Although this may want to go elsewhere since it impacts wire format handling)",
              "createdAt": "2021-01-05T03:40:46Z",
              "updatedAt": "2021-01-05T19:40:17Z"
            },
            {
              "originalPosition": 85,
              "body": "What about double-quote?  (\"\"\")",
              "createdAt": "2021-01-05T03:42:19Z",
              "updatedAt": "2021-01-05T19:40:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxOTk5NzM4",
          "commit": {
            "abbreviatedOid": "465561e"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T17:46:21Z",
          "updatedAt": "2021-01-05T17:46:21Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "It's still there: \"one or more\".",
              "createdAt": "2021-01-05T17:46:21Z",
              "updatedAt": "2021-01-05T19:40:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDAxNjEy",
          "commit": {
            "abbreviatedOid": "465561e"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T17:48:52Z",
          "updatedAt": "2021-01-05T17:48:53Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "Nothing here impacts clients; this is only relevant during zone-file parsing.  I think it's clear from the text here that `alpn=,,` is a syntax error that halts zone file parsing.",
              "createdAt": "2021-01-05T17:48:53Z",
              "updatedAt": "2021-01-05T19:40:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDAzMDgw",
          "commit": {
            "abbreviatedOid": "465561e"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T17:50:55Z",
          "updatedAt": "2021-01-05T17:50:56Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Double-quote is not special-cased here.  It is treated just like any other character, e.g, `alpn=\"\\\"foo\\\",bar\"` -> `\"foo\",bar` -> (`\"foo\"`, `bar`).",
              "createdAt": "2021-01-05T17:50:55Z",
              "updatedAt": "2021-01-05T19:40:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDEzOTkz",
          "commit": {
            "abbreviatedOid": "465561e"
          },
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T18:06:00Z",
          "updatedAt": "2021-01-05T18:06:00Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "Not \"halting\" parsing, but just throwing out this record as invalid.  \r\n(or the behavior to halt or not to halt is up to the implementation)",
              "createdAt": "2021-01-05T18:06:00Z",
              "updatedAt": "2021-01-05T19:40:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDQ3ODc1",
          "commit": {
            "abbreviatedOid": "465561e"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T18:55:31Z",
          "updatedAt": "2021-01-05T18:55:31Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "I should have re-read with more context.  Perhaps being clear below would help?",
              "createdAt": "2021-01-05T18:55:31Z",
              "updatedAt": "2021-01-05T19:40:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDQ4ODQ0",
          "commit": {
            "abbreviatedOid": "465561e"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T18:56:56Z",
          "updatedAt": "2021-01-05T18:56:57Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "```suggestion\r\nDecoding of value-lists happens after character-string decoding.  \r\nFor example, consider these `char-string` SvcParamValues:\r\n```\r\n",
              "createdAt": "2021-01-05T18:56:56Z",
              "updatedAt": "2021-01-05T19:40:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDk2NDI2",
          "commit": {
            "abbreviatedOid": "636cdde"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-05T20:09:07Z",
          "updatedAt": "2021-01-05T20:09:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 284,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ5NDE4MjEw",
      "title": "When no-default-alpn is present, alpn must also be present",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/284",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #283",
      "createdAt": "2021-01-05T19:15:06Z",
      "updatedAt": "2021-01-15T21:48:23Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "e318510b60c6a4f21eb0f541aa3f316e8e502938",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-no-default-alpn-must-have-alpn",
      "headRefOid": "52c1f2840f153d35711afa2443788fc08e4ba388",
      "closedAt": "2021-01-15T21:31:56Z",
      "mergedAt": "2021-01-15T21:31:55Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "e60752ac8167edc8d8eea32f77b0e0167b100027"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@enygren WDYT about harmonizing this language with #285?",
          "createdAt": "2021-01-12T15:47:33Z",
          "updatedAt": "2021-01-12T15:47:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDgwNDM0",
          "commit": {
            "abbreviatedOid": "4ef037f"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T19:44:41Z",
          "updatedAt": "2021-01-05T19:44:42Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I would prefer to distinguish here between what we want the zone file parser to do vs. what we want the client to do.\r\n\r\nI'm fine with telling the zone file parser that this is invalid, but \"discarded\" sounds silent.  \"flagged as invalid\" might be clearer.\r\n\r\nFor the client, I'd prefer to avoid imposing new requirements or repeating normative language.  If it's necessary, we could say something like \"Compliant clients will ignore ...\".",
              "createdAt": "2021-01-05T19:44:41Z",
              "updatedAt": "2021-01-15T21:27:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDk1NTA2",
          "commit": {
            "abbreviatedOid": "4ef037f"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T20:07:43Z",
          "updatedAt": "2021-01-05T20:07:44Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n(else compliant clients should ignore the record as invalid).\r\n```",
              "createdAt": "2021-01-05T20:07:43Z",
              "updatedAt": "2021-01-15T21:27:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMDk1NjY0",
          "commit": {
            "abbreviatedOid": "4ef037f"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T20:07:56Z",
          "updatedAt": "2021-01-05T20:07:56Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Better?",
              "createdAt": "2021-01-05T20:07:56Z",
              "updatedAt": "2021-01-15T21:27:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMTE1NjQ1",
          "commit": {
            "abbreviatedOid": "4ef037f"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T20:40:15Z",
          "updatedAt": "2021-01-05T20:40:15Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "There's already the rule that clients must reject the entire rrset if any RR is malformed. As written in this change, I think it is ambiguous whether or not the missing \"alpn\" counts as a malformed key, so I wouldn't be sure whether to ignore the RR (just for not having a supported alpn value) or the RRSet (as malformed).\r\n\r\nHence, I think we need the client expectation clarified here and avoid saying something like \"invalid\" unless we mean the malformed case. My preference would be to treat is as malformed to stop bad configurations, but I won't fight for that as long as it's unambiguous.",
              "createdAt": "2021-01-05T20:40:15Z",
              "updatedAt": "2021-01-15T21:27:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMTE1OTE0",
          "commit": {
            "abbreviatedOid": "4ef037f"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T20:40:43Z",
          "updatedAt": "2021-01-05T20:40:43Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "After thinking about this some more, I've changed my mind.  We can just say \"this is not allowed\" and leave the details to the implementors.\r\n```suggestion\r\nempty.  When \"no-default-alpn\" is specified, \"alpn\" MUST also be specified.\r\n```",
              "createdAt": "2021-01-05T20:40:43Z",
              "updatedAt": "2021-01-15T21:27:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMTE3NTMy",
          "commit": {
            "abbreviatedOid": "4ef037f"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T20:43:21Z",
          "updatedAt": "2021-01-05T20:43:21Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "\"malformed\" has a precise definition in Section 2.2.  This would not qualify as \"malformed\".",
              "createdAt": "2021-01-05T20:43:21Z",
              "updatedAt": "2021-01-15T21:27:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMTE4ODQ1",
          "commit": {
            "abbreviatedOid": "4ef037f"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T20:45:32Z",
          "updatedAt": "2021-01-05T20:45:33Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Making this more complicated is having no-default-alpn be mandatory but not alpn.  (See discussion in #281.)  This should cover and we should be crystal clear on what happens if no-default-alpn and alpn are present on some records but some other records have no no-default-alpn, and the client doesn't implement alpn support.  The net result should probably be that clients discard the no-default-alpn records but then use the other records.  ",
              "createdAt": "2021-01-05T20:45:32Z",
              "updatedAt": "2021-01-15T21:27:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMTIxMzA5",
          "commit": {
            "abbreviatedOid": "4ef037f"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T20:49:12Z",
          "updatedAt": "2021-01-05T20:49:12Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "The potentially relevant part of that definition:\r\n\"the SvcParamValue for an SvcParamKey does not have the expected format\"\r\n\r\nDoes an expected key/value not being present and declared \"invalid\" count as an unexpected format? Probably not, but I would still argue it's ambiguous enough to require clarification.\r\n\r\n(And even if it's decided this doesn't meet the current definition, I think it would be better to modify the definition to cover this case, but that's getting into the area I said I wouldn't fight for.)",
              "createdAt": "2021-01-05T20:49:12Z",
              "updatedAt": "2021-01-15T21:27:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMTI1Nzg1",
          "commit": {
            "abbreviatedOid": "4ef037f"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T20:56:27Z",
          "updatedAt": "2021-01-05T20:56:28Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "@ericorth I think there's a logical distinction between \"syntactic validity\" (malformed/unparseable) and \"semantic validity\" (inter-key logical agreement).  If a record is malformed, something Really Bad happened (memory corruption?).  If there's a configuration error, that's different.  I don't have strong feelings about what clients ought to do in each case, but I can certainly imagine that we might recommend or allow different behaviors.\r\n\r\nBTW, this isn't the only case of inter-key logical agreement.  We already have the case of \"mandatory\" indicating a key that is not actually present.",
              "createdAt": "2021-01-05T20:56:27Z",
              "updatedAt": "2021-01-15T21:27:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMTMzNzEz",
          "commit": {
            "abbreviatedOid": "4ef037f"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T21:08:47Z",
          "updatedAt": "2021-01-05T21:08:47Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Agreed that they're reasonably distinct cases and it would be very reasonable to treat the cases differently.\r\n\r\nBut I think my specific points still stand:\r\n- My soft preference would be to add semantic validity (at least this case and maybe also the \"mandatory\" case) to the cases where the RRSet is rejected.  If somebody creates a stupidly bad config, it should be obvious so they know to fix it.  But it wouldn't be the end of the world either if we just make it discarded-RR or just let the stupid results of the stupid config happen.\r\n- Logically distinct or not, there's still room for confusion.  Maybe we just need a sentence in 2.2 clarifying that it only covers syntactic validity of the individual values themselves?",
              "createdAt": "2021-01-05T21:08:47Z",
              "updatedAt": "2021-01-15T21:27:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMTQ2MTYz",
          "commit": {
            "abbreviatedOid": "4ef037f"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T21:22:20Z",
          "updatedAt": "2021-01-05T21:22:20Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "And also, absent a clearly specified rule for how the client should behave given a violation of a semantic rule like this one, we should avoid the word \"invalid\".  As a client implementor, I want to know the proper way to enforce validity.  If the answer is that it's not enforced in any way and just continue to handle it logically (eg by treating a record as one without a matching ALPN and thus discarded RR), then that is not \"invalid\".",
              "createdAt": "2021-01-05T21:22:20Z",
              "updatedAt": "2021-01-15T21:27:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4NTc1MjQz",
          "commit": {
            "abbreviatedOid": "4ef037f"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-14T19:52:57Z",
          "updatedAt": "2021-01-14T19:52:57Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "With #285 this does cover things.  Although does that mean that \"alpn\" should be default mandatory but with a clarification that this doesn't mean clients need to understand all possible values?  As if \"no-default-alpn\" is mandatory and requires \"alpn\" for consistency then it would seem like \"alpn\" needs to be mandatory transitively?",
              "createdAt": "2021-01-14T19:52:57Z",
              "updatedAt": "2021-01-15T21:27:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4NTgwMDg4",
          "commit": {
            "abbreviatedOid": "4ef037f"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-14T19:58:56Z",
          "updatedAt": "2021-01-14T19:58:57Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "No, I don't think this means \"alpn\" needs to be \"automatically mandatory\".  Fundamentally, \"automatically mandatory\" mean \"subtractive\", i.e. \"this key can subtract functionality from the endpoint\".  \"alpn\" is purely additive, so it is always safe to ignore.",
              "createdAt": "2021-01-14T19:58:57Z",
              "updatedAt": "2021-01-15T21:27:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5NjI0ODU3",
          "commit": {
            "abbreviatedOid": "3834df9"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-15T21:19:06Z",
          "updatedAt": "2021-01-15T21:19:07Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nempty.  When \"no-default-alpn\" is specified in an RR, \r\n\"alpn\" MUST also be specified in-order for the RR \r\nto be \"self-consistent\" ({{service-mode}}).\r\n```",
              "createdAt": "2021-01-15T21:19:06Z",
              "updatedAt": "2021-01-15T21:27:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5NjI1MTM0",
          "commit": {
            "abbreviatedOid": "3834df9"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-15T21:19:39Z",
          "updatedAt": "2021-01-15T21:19:39Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "(to align with #285)",
              "createdAt": "2021-01-15T21:19:39Z",
              "updatedAt": "2021-01-15T21:27:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5NjI1Mzkw",
          "commit": {
            "abbreviatedOid": "3834df9"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-15T21:20:05Z",
          "updatedAt": "2021-01-15T21:20:06Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": ":+1: ",
              "createdAt": "2021-01-15T21:20:06Z",
              "updatedAt": "2021-01-15T21:27:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5NjMyOTAy",
          "commit": {
            "abbreviatedOid": "52c1f28"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-15T21:31:43Z",
          "updatedAt": "2021-01-15T21:31:43Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5NjMzNjI0",
          "commit": {
            "abbreviatedOid": "52c1f28"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-15T21:33:03Z",
          "updatedAt": "2021-01-15T21:33:03Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Nit: If I'm remembering the language correctly, being self-consistent is only a SHOULD, so any \"in order for the RR to be 'self-consistent'\" rules should probably also be a SHOULD, rather than a MUST.  You can create records that violate it, but if you do, you have to expect clients will ignore the RR or RRSet.",
              "createdAt": "2021-01-15T21:33:03Z",
              "updatedAt": "2021-01-15T21:33:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5NjM0NjI0",
          "commit": {
            "abbreviatedOid": "52c1f28"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-15T21:34:59Z",
          "updatedAt": "2021-01-15T21:34:59Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "When not \"self-consistent\", dropping the RR is a MUST for clients, rejecting the entire RRset is a MAY.",
              "createdAt": "2021-01-15T21:34:59Z",
              "updatedAt": "2021-01-15T21:34:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5NjM1MDQz",
          "commit": {
            "abbreviatedOid": "52c1f28"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-15T21:35:44Z",
          "updatedAt": "2021-01-15T21:35:45Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I read this as \"The record is not self-consistent if it has no-default-alpn but not alpn.\".  I think it's fine.  It is perhaps slightly unusual use of normative language ... we could make it a lower-case \"must\" :).",
              "createdAt": "2021-01-15T21:35:44Z",
              "updatedAt": "2021-01-15T21:35:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5NjM3MDU2",
          "commit": {
            "abbreviatedOid": "52c1f28"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-15T21:39:48Z",
          "updatedAt": "2021-01-15T21:39:49Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "But zone implementors enforcing that records are self-consistent was only a SHOULD, right? Making this a MUST would add an additional strong requirement specific to this rule.",
              "createdAt": "2021-01-15T21:39:48Z",
              "updatedAt": "2021-01-15T21:39:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5NjM5OTk4",
          "commit": {
            "abbreviatedOid": "52c1f28"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-15T21:45:30Z",
          "updatedAt": "2021-01-15T21:45:31Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "To further clarify my point, \"\"alpn\" MUST also be specified in-order for the RR to be \"self-consistent\" is a rule for the zone implementors to follow.  They're the ones able to make that happen or not.  That rule is then inconsistent with \"Zone-file implementations SHOULD enforce self-consistency.\"\r\n\r\nI think either \"\"alpn\" SHOULD also be specified in-order for the RR to be \"self-consistent\" or \"\"alpn\" must also be specified in-order for the RR to be \"self-consistent\" would be sufficient to break the inconsistency, but I think the former is slightly clearer.",
              "createdAt": "2021-01-15T21:45:31Z",
              "updatedAt": "2021-01-15T21:45:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5NjQxMzY3",
          "commit": {
            "abbreviatedOid": "52c1f28"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-15T21:48:22Z",
          "updatedAt": "2021-01-15T21:48:23Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Let's argue in #290.",
              "createdAt": "2021-01-15T21:48:22Z",
              "updatedAt": "2021-01-15T21:48:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 285,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUyODgyNzUy",
      "title": "Clarify self-consistency rules",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/285",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Requested in https://github.com/MikeBishop/dns-alt-svc/pull/284/files#r552202056",
      "createdAt": "2021-01-11T16:58:52Z",
      "updatedAt": "2021-01-14T21:17:49Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "ea499189c4e492a1b623544d3a974ba366ec2c13",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-invalid",
      "headRefOid": "c145488ee078228a0ca90fc8ccb0f2af55bae29a",
      "closedAt": "2021-01-14T21:17:44Z",
      "mergedAt": "2021-01-14T21:17:44Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "c55491fc96cdcf131378d0dabf983fa2c16866e7"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@ericorth Does this address your concern?",
          "createdAt": "2021-01-11T17:56:40Z",
          "updatedAt": "2021-01-11T17:56:40Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "> @ericorth Does this address your concern?\r\n\r\nYes.  It does so nicely.  Thanks.\r\n\r\nFurther suggestion: We should call out \"would make the record not self-consistent\" or something like that for the alpn/no-default-alpn case we were calling out as \"invalid\" before (and any other cases we know of).  Good to keep the language in the draft consistent and precise (\"malformed\" vs \"invalid\" vs \"not self-consistent\").",
          "createdAt": "2021-01-11T21:00:19Z",
          "updatedAt": "2021-01-11T21:00:19Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> Further suggestion: We should call out \"would make the record not self-consistent\" or something like that for the alpn/no-default-alpn case we were calling out as \"invalid\" before (and any other cases we know of). Good to keep the language in the draft consistent and precise (\"malformed\" vs \"invalid\" vs \"not self-consistent\").\r\n\r\nAgreed; I was just trying to avoid a collision with #284.",
          "createdAt": "2021-01-11T21:05:22Z",
          "updatedAt": "2021-01-11T21:05:22Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "One thing that does get messy here is how to handle new types of keys.  A zone file parser clearly can't handle keyNNNN form SvcParams, but for clients it seems like there could be cases where a new non-mandatory SvcParm shows up that is declared in its spec to conflicts with some other SvcParam.  There is no way for clients which are aware of these to reject the RR.  We also want to avoid cases where clients confused by some new SvcParams throw out the entire RRset and cause compatibility issues.  I'm not sure what we might want to add to help here?",
          "createdAt": "2021-01-14T19:44:04Z",
          "updatedAt": "2021-01-14T19:44:04Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> There is no way for clients which are aware of these to reject the RR.\r\n\r\nDo you mean \"not aware\"?\r\n\r\n> I'm not sure what we might want to add to help here?\r\n\r\nI adjusted the text.  Is it clearer now?",
          "createdAt": "2021-01-14T19:55:24Z",
          "updatedAt": "2021-01-14T19:55:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4NTk0NzEx",
          "commit": {
            "abbreviatedOid": "c145488"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-14T20:19:25Z",
          "updatedAt": "2021-01-14T20:19:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 286,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUzNTY2NTkz",
      "title": "Remove extra backslash in example",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/286",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-12T15:54:41Z",
      "updatedAt": "2021-01-14T19:45:12Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "ea499189c4e492a1b623544d3a974ba366ec2c13",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-comma",
      "headRefOid": "72c3617e2dcf5406098dd9b22f46f4b5e5a5ad5b",
      "closedAt": "2021-01-14T19:45:12Z",
      "mergedAt": "2021-01-14T19:45:12Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "59339dd5d8d2355366e6781ffd05bbf5887c5ed9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4NTY4NDU5",
          "commit": {
            "abbreviatedOid": "72c3617"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-14T19:45:01Z",
          "updatedAt": "2021-01-14T19:45:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 288,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU1MDAwMzk4",
      "title": "Discuss hypothetical SVCB-reliant protocols",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/288",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #287",
      "createdAt": "2021-01-14T15:17:17Z",
      "updatedAt": "2021-02-17T14:45:09Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "ea499189c4e492a1b623544d3a974ba366ec2c13",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-svcb-reliant",
      "headRefOid": "87303bd0b9e206e60a860589842a53b1724b847a",
      "closedAt": "2021-02-17T14:45:00Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Waiting on clarification of https://github.com/MikeBishop/dns-alt-svc/issues/287#issuecomment-760346439  if (1) is what is meant, this seems fine.  If (2) is meant, more is needed.",
          "createdAt": "2021-01-14T19:48:46Z",
          "updatedAt": "2021-01-14T19:48:46Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson I don't understand.  This change* has precisely that effect.  Connections will only ever go to the ServiceMode TargetName.  As stated in the new text, if no ServiceMode records are present, the connection attempt terminates (i.e. fails) rather than fall back to bare-AAAA connection.\r\n\r\n*I don't think this is actually a \"change\"; it's more of a hint to future standards authors.",
          "createdAt": "2021-01-15T00:57:38Z",
          "updatedAt": "2021-01-15T00:57:38Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Given how definitively the process in Section 3 is about making A/AAAA queries, I don't agree that this is sufficient.",
          "createdAt": "2021-01-15T01:40:26Z",
          "updatedAt": "2021-01-15T01:40:26Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, I am not proposing to remove those queries.  Those queries are a useful latency optimization even when the connection is required to use ServiceMode records, so long as the TargetName is reasonably likely to coincide with the origin name.  Removing step 5 means that those queries will never be used for a \"legacy\" connection; they will only be used if they happen to coincide with (and pre-empt) a followup query for a ServiceMode TargetName.\r\n\r\nI recognize that you are considering a particular deployment in which the TargetName does not coincide with the origin name, in which case those queries will be wasted, but will otherwise have no effect.",
          "createdAt": "2021-01-15T02:14:06Z",
          "updatedAt": "2021-01-15T02:14:06Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm contemplating a model where those queries could produce answers that should not be used.  That's different from waste.  That's a problem.  Maybe I just don't understand why making them conditional on them being useful is a problem.",
          "createdAt": "2021-01-15T03:14:28Z",
          "updatedAt": "2021-01-15T03:14:28Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm contemplating a model where those queries could produce answers that should not be used.\r\n\r\nYes.  If they should not be used, they will not be used.\r\n\r\n> Maybe I just don't understand why making them conditional on them being useful is a problem.\r\n\r\nI'm focusing on a model where the client doesn't know whether they are useful until it learns the server configuration.  Suppose the client is connecting to `foo://origin.example`, a future SVCB-reliant URI scheme.  Under your proposed behavior, the client would issue only a SVCB query for `_foo.origin.example.`.  Suppose they receive a response of the form \r\n\r\n```dns-zone\r\n_foo.origin.example. IN SVCB 900 1 origin.example. alpn=bar\r\n```\r\n\r\nIf the recursive resolver is not performing Additional Section processing, the client now must issue followup A/AAAA queries for `origin.example.`, and wait for a response before proceeding.  If they had preissued those queries, they would not have to wait.\r\n\r\nPreissuing the A/AAAA queries is inexpensive, so if there's a reasonable likelihood of them being useful, I think they're worth sending.  That likelihood decreases if `foo://` server deployments don't typically set TargetName to the origin ... but `foo://` deployments don't exist yet.  Encouraging such a convention enables this latency-hiding to work (at least sometimes), improving average performance.\r\n\r\nWe could add text describing _both_ a future-protocol that is likely to use origin-located address records, and a future-protocol that is not.  I think this kind of speculation, enumerating behaviors of multiple nonexistent protocols, is more likely to obscure than elucidate.\r\n\r\nWhen it comes to future protocols, this whole section is just a hint to our future selves.  If you think this PR doesn't provide a suitable hint, perhaps you'd prefer the solution in #289.",
          "createdAt": "2021-01-15T18:53:41Z",
          "updatedAt": "2021-01-15T18:59:08Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "I like the approach in #289 as it defers this to the future without trying to pre-suppose what future protocols will want.  Since this is client behavior (not resolver or authority behavior) there is no reason hypothetical futures need to be defined here.",
          "createdAt": "2021-01-15T21:15:57Z",
          "updatedAt": "2021-01-15T21:15:57Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Any objections to abandoning this in-favor of #289?  (It is unclear what value we get from adding this in-addition to #289)",
          "createdAt": "2021-01-15T21:29:29Z",
          "updatedAt": "2021-01-15T21:29:29Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> Any objections to abandoning this in-favor of #289? (It is unclear what value we get from adding this in-addition to #289)\r\n\r\nThat's fine with me, but I'd like to get some input from @martinthomson before proceeding with either change.\r\n",
          "createdAt": "2021-01-15T21:31:09Z",
          "updatedAt": "2021-01-15T21:31:09Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Superseded by #291",
          "createdAt": "2021-02-17T14:45:00Z",
          "updatedAt": "2021-02-17T14:45:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4NDU0MDY1",
          "commit": {
            "abbreviatedOid": "0159c95"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-14T17:19:06Z",
          "updatedAt": "2021-01-14T17:19:07Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nprotocol, new protocols could be defined that require a ServiceMode record with no fallback to AAAA/A address records.\r\n```",
              "createdAt": "2021-01-14T17:19:06Z",
              "updatedAt": "2021-01-14T17:21:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4NzE0MDM5",
          "commit": {
            "abbreviatedOid": "87303bd"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "This is not responsive to the changes.\r\n\r\nTo Erik's question, this is because I want to be able to deploy a protocol that uses SVCB for discovery on a name that has A/AAAA.  I don't want the servers that the A/AAAA records point at getting requests for that protocol.  (Honestly, I don't know which of the options Erik presents that is, so I'm restating it instead.)",
          "createdAt": "2021-01-14T23:39:23Z",
          "updatedAt": "2021-01-14T23:39:23Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NzM1MDgz",
          "commit": {
            "abbreviatedOid": "87303bd"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Would this change or one similar address @martinthomson 's concern?  ",
          "createdAt": "2021-01-28T20:58:58Z",
          "updatedAt": "2021-01-28T20:59:35Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nSuch \"SVCB-reliant\" protocols SHALL:\r\n* ... start off step 1 with ADDR_QNAME being undefined\r\n* ... not issue A/AAAA queries when ADDR_QNAME is undefined\r\n* ... terminate upon reaching step 5\r\n```",
              "createdAt": "2021-01-28T20:58:58Z",
              "updatedAt": "2021-01-28T20:59:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4ODY2Mzg0",
          "commit": {
            "abbreviatedOid": "87303bd"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T01:05:01Z",
          "updatedAt": "2021-01-29T01:05:02Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Yes, I think that would do.  Though, as I noted in mail, it would be better if the current optimization were framed as such and the conditions under which the optimization apply more clearly articulated.",
              "createdAt": "2021-01-29T01:05:01Z",
              "updatedAt": "2021-01-29T01:05:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwNzAzMzA5",
          "commit": {
            "abbreviatedOid": "87303bd"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-01T19:43:49Z",
          "updatedAt": "2021-02-01T19:43:49Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I've drawn up #291 as a _third_ alternative solution here, which implements that reframing.  I'm not sure it's more comprehensible than this text, but it is probably more precise.  Please review.",
              "createdAt": "2021-02-01T19:43:49Z",
              "updatedAt": "2021-02-01T19:43:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 289,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU1ODc4NDIy",
      "title": "Clarify that the client behavior can be modified",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/289",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is an alternative to #288\r\n\r\nAddresses #287",
      "createdAt": "2021-01-15T18:36:34Z",
      "updatedAt": "2021-02-17T14:44:17Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "c55491fc96cdcf131378d0dabf983fa2c16866e7",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-client-behavior",
      "headRefOid": "3b0c3bec4bb4ee01b173608405fa697014c984c1",
      "closedAt": "2021-02-17T14:44:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Superseded by #291",
          "createdAt": "2021-02-17T14:44:16Z",
          "updatedAt": "2021-02-17T14:44:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5NjIzMjMw",
          "commit": {
            "abbreviatedOid": "3b0c3be"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-15T21:16:06Z",
          "updatedAt": "2021-01-15T21:16:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NzMxODQ4",
          "commit": {
            "abbreviatedOid": "3b0c3be"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-28T20:54:28Z",
          "updatedAt": "2021-01-28T20:54:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 290,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU1OTcyMjk0",
      "title": "Use lower-case MUST for self-consistency rule",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/290",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "enygren"
      ],
      "labels": [],
      "body": "This is probably more correct use of normative language.",
      "createdAt": "2021-01-15T21:47:56Z",
      "updatedAt": "2021-02-01T18:13:10Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "e60752ac8167edc8d8eea32f77b0e0167b100027",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-no-alpn-must",
      "headRefOid": "9eea84e8d934139d6e84592b1fe61c7b31157ddf",
      "closedAt": "2021-02-01T18:13:07Z",
      "mergedAt": "2021-02-01T18:13:07Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "701240a1d2bd1195afc7381d7f936de5fa784120"
      },
      "comments": [
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "LGTM.  Makes it clear enough that the statement is just \"you need to do this or it won't be self-consistent\".  Whereas \"you MUST do this...\" made it sound like a stand-alone rule which was not correct.",
          "createdAt": "2021-01-15T21:51:42Z",
          "updatedAt": "2021-01-15T21:51:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NzMxMTgw",
          "commit": {
            "abbreviatedOid": "9eea84e"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-28T20:53:30Z",
          "updatedAt": "2021-01-28T20:53:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 291,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY1NDMxNDIy",
      "title": "Restructure client requirements",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/291",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change significantly refactors the client requirements, separating\r\nrecommended performance optimizations from minimal compliance\r\nrequirements.\r\n\r\nAddresses #287",
      "createdAt": "2021-02-01T19:42:06Z",
      "updatedAt": "2021-02-17T14:43:48Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "701240a1d2bd1195afc7381d7f936de5fa784120",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-svcb-reliant2",
      "headRefOid": "a382a5783be10fd0507c5618adbff79a7a962871",
      "closedAt": "2021-02-17T14:43:40Z",
      "mergedAt": "2021-02-17T14:43:40Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "4d7097007a4fcb47c4b23a1f0d90ebc14c3d79cf"
      },
      "comments": [
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "All this seems reasonable to me.  From the perspective of an HTTPS client, this is a little harder to follow than the previous text (as I would expect since the previous text was targeted really to just telling HTTPS clients what to do), but it's still reasonable enough and hopefully resolves concerns regarding clients other than HTTPS clients.",
          "createdAt": "2021-02-02T18:35:48Z",
          "updatedAt": "2021-02-02T18:35:48Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "impartial third party:  I like these phrasing adjustments. ",
          "createdAt": "2021-02-05T21:42:53Z",
          "updatedAt": "2021-02-05T21:42:53Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> Looks good. Do we want to define HTTPS as an explicit SVCB-optional protocol?\r\n\r\nI added a tiny clarification: https://github.com/MikeBishop/dns-alt-svc/pull/291/commits/a382a5783be10fd0507c5618adbff79a7a962871.  If you'd like to expand that, let's do it in a separate PR.\r\n\r\n",
          "createdAt": "2021-02-17T14:43:20Z",
          "updatedAt": "2021-02-17T14:43:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwODIzNTUz",
          "commit": {
            "abbreviatedOid": "3095752"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This is a lot more changes than the other options, but the general shape is better.  I think that you have added a bunch of things that improve the spec in other ways here, so it is definitely more disruptive, but worthwhile.",
          "createdAt": "2021-02-01T22:27:54Z",
          "updatedAt": "2021-02-01T22:47:23Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "```suggestion\r\nfallback to lower-priority alternatives.  Clients issue AAAA and/or A\r\n```",
              "createdAt": "2021-02-01T22:27:54Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            },
            {
              "originalPosition": 64,
              "body": "This definition of SVCB-reliant doesn't match with my understanding.  I think that what you want to do is note that there are two reasons to make an A/AAAA query in parallel.  The primary one being that the client might be willing to fall back to A/AAAA queries if there are no SVCB records, but you might also want to allow for the possibility that a TargetName form SVCB record references the same name and so there might be an advantage in making the A/AAAA queries in parallel to allow for that outcome.\r\n\r\n(Unfortunately, if you *need* SVCB, you need the TargetName form, and you don't get to predict when that will appear, so you basically have to make the parallel query always once you decide that it is worth the parallel.)\r\n\r\nYou mention the latter below, which is good, but I think that it applies here.",
              "createdAt": "2021-02-01T22:32:41Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            },
            {
              "originalPosition": 83,
              "body": "terminate the connection or terminate the connection attempt?",
              "createdAt": "2021-02-01T22:39:20Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            },
            {
              "originalPosition": 69,
              "body": "I don't understand this.  Are you trying to back-fill a default value for SVCB in the case you don't need one?  Why not just say \"if the endpoint does not require SVCB, then it can use A/AAAA records when SVCB is not available\"?",
              "createdAt": "2021-02-01T22:42:19Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            },
            {
              "originalPosition": 95,
              "body": "This isn't something you recommend.  You just need to say that the reason you issue A/AAAA in parallel is that you are predicting that TargetName is present and that TargetName is \".\", which is what {{zone-performance}} (two curlies!) recommends for those that provision records.",
              "createdAt": "2021-02-01T22:44:19Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            },
            {
              "originalPosition": 117,
              "body": "```suggestion\r\nclients proceed with connection establishment as described in\r\n```",
              "createdAt": "2021-02-01T22:44:40Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            },
            {
              "originalPosition": 133,
              "body": "Citation?",
              "createdAt": "2021-02-01T22:45:18Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwOTIyMjU5",
          "commit": {
            "abbreviatedOid": "3095752"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-02T01:54:00Z",
          "updatedAt": "2021-02-02T01:59:26Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "I'm not sure I understand your concern here, but I hope these changes have clarified it somewhat.",
              "createdAt": "2021-02-02T01:54:00Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            },
            {
              "originalPosition": 69,
              "body": "There are actually _two_ \"default\" fallbacks listed here, in a specific order and with different normativity.  The main motivation is to support using AliasMode to point to a hosting provider that doesn't use SVCB.\r\n\r\nI've adjusted this text to improve clarity (and avoid assuming that non-SVCB connection means A/AAAA, since it could also be SRV or something else).",
              "createdAt": "2021-02-02T01:56:11Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            },
            {
              "originalPosition": 83,
              "body": "Connection attempt.  Reworded.",
              "createdAt": "2021-02-02T01:56:25Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            },
            {
              "originalPosition": 95,
              "body": "{{zone-performance}} actually didn't recommend that.  I've moved this recommendation from here to there.",
              "createdAt": "2021-02-02T01:57:11Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            },
            {
              "originalPosition": 133,
              "body": "Clarified",
              "createdAt": "2021-02-02T01:58:11Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwOTUxNTc1",
          "commit": {
            "abbreviatedOid": "667ea8c"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-02T03:11:58Z",
          "updatedAt": "2021-02-02T03:11:58Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "I think that the key difference between reliant and optional is whether the information in the ServiceMode is critical to operation of the client.\r\n\r\nRelated question: does an SVCB-optional client switch to SVCB-reliant if it encounters an AliasMode record?  Or, can it follow to the target name and just consume A/AAAA (or whatever) instead, without ever having seen a ServiceMode record?",
              "createdAt": "2021-02-02T03:11:58Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwOTUzNDM3",
          "commit": {
            "abbreviatedOid": "667ea8c"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-02T03:17:26Z",
          "updatedAt": "2021-02-02T03:17:26Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "As the text still says that you issue A/AAAA when you hit a ServiceMode record, I'm now more confused by this.\r\n\r\nI'm still totally short on clarity here.  What is being appended to?  And I still don't know what \"the authority endpoint\" is or what it is appended to.  Are you saying that if you exhaust SVCB lookups and you are don't need the ServiceForm information, you could just pretend to have received a SVCB ServiceForm record that consists of $QNAME, the port, and no SvcParams?  Why say that at all?  What advantage does this have over letting the client fall back to non-SVCB resolution?\r\n\r\n\r\n\r\n",
              "createdAt": "2021-02-02T03:17:26Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwOTUzNjM1",
          "commit": {
            "abbreviatedOid": "667ea8c"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-02T03:18:00Z",
          "updatedAt": "2021-02-02T03:18:01Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "> I think that the key difference between reliant and optional is whether the information in the ServiceMode is critical to operation of the client.\r\n\r\nAgreed.  How does that differ from the definition given here?\r\n\r\n> Related question: does an SVCB-optional client switch to SVCB-reliant if it encounters an AliasMode record?\r\n\r\nNo.\r\n\r\n> Or, can it follow to the target name and just consume A/AAAA (or whatever) instead, without ever having seen a ServiceMode record?\r\n\r\nYes.  That's important, to support use of AliasMode pointing to a hosting provider that doesn't have a SVCB record.\r\n\r\nAdditionally, as currently specified, SVCB-optional clients are generally encouraged (and in some cases required) to fall back to non-SVCB connection if all the SVCB alternative endpoints are tried and they all fail. (See #256 for some debate about that.)",
              "createdAt": "2021-02-02T03:18:01Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwOTUzNzU2",
          "commit": {
            "abbreviatedOid": "667ea8c"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-02T03:18:21Z",
          "updatedAt": "2021-02-02T03:18:21Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "I was noting that this might need citation, though the clarification is fine.",
              "createdAt": "2021-02-02T03:18:21Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwOTU0ODc4",
          "commit": {
            "abbreviatedOid": "667ea8c"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-02T03:21:43Z",
          "updatedAt": "2021-02-02T03:21:44Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": ">  How does that differ from the definition given here?\r\n\r\nThe definition here concentrates on what the client does (connect to the ServiceForm endpoint), rather than the reasons for the same.\r\n\r\nDoes the draft explain the AliasForm-CNAME isomorphism?  There's a lot of text, but I can't see anything there.  Seems important.",
              "createdAt": "2021-02-02T03:21:44Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwOTU3NDMy",
          "commit": {
            "abbreviatedOid": "667ea8c"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-02T03:29:14Z",
          "updatedAt": "2021-02-02T03:29:14Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "> As the text still says that you issue A/AAAA when you hit a ServiceMode record, I'm now more confused by this.\r\n\r\nConnection using a ServiceMode record always requires an address lookup for TargetName.  Connection _not_ using SVCB doesn't strictly require an address lookup ... who knows what the non-SVCB connection procedure is for an arbitrary protocol?\r\n\r\n> What is being appended to?\r\n\r\nThe priority-ordered list of alternative endpoints.\r\n\r\n> And I still don't know what \"the authority endpoint\" is or what it is appended to.\r\n\r\nThat's defined in [the definitions section](https://tools.ietf.org/html/draft-ietf-dnsop-svcb-https-02#section-1.4).\r\n\r\n> Are you saying that if you exhaust SVCB lookups and you are don't need the ServiceForm information, you could just pretend to have received a SVCB ServiceForm record that consists of $QNAME, the port, and no SvcParams?\r\n\r\nYes.\r\n\r\n> Why say that at all?\r\n\r\nMostly to handle the case where there is an AliasMode record but no ServiceMode record.  Adding this endpoint unconditionally for fallback is not necessary but seems like it could improve reliability (one more endpoint to try) without expanding the DNS response.",
              "createdAt": "2021-02-02T03:29:14Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwOTYwMDE5",
          "commit": {
            "abbreviatedOid": "27b1a0c"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-02T03:37:13Z",
          "updatedAt": "2021-02-02T03:37:14Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "> The definition here concentrates on what the client does (connect to the ServiceForm endpoint), rather than the reasons for the same.\r\n\r\nOK, I've reversed the polarity of the definitions.  Does that help?\r\n\r\n> Does the draft explain the AliasForm-CNAME isomorphism?\r\n\r\nIt's not really an isomorphism.  [The AliasMode section](https://tools.ietf.org/html/draft-ietf-dnsop-svcb-https-02#section-2.4.2) discusses the relationship in some detail.  I'm happy to improve the description but I think it's out of scope for this PR.",
              "createdAt": "2021-02-02T03:37:13Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgxNzkxNDM1",
          "commit": {
            "abbreviatedOid": "27b1a0c"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-02T21:31:10Z",
          "updatedAt": "2021-02-02T21:31:48Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "```suggestion\r\nendpoint's port number, and no SvcParams, to the list of alternative endpoints, which is \r\nattempted before falling back to non-SVCB connection modes.\r\n```\r\n\r\nDoes this need to be explicitly ServiceMode?",
              "createdAt": "2021-02-02T21:31:10Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg5ODk2NjM1",
          "commit": {
            "abbreviatedOid": "7371fd9"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This does seem to be cleaner and more readable and the previous text, so does seem to be a general improvement.",
          "createdAt": "2021-02-12T23:10:41Z",
          "updatedAt": "2021-02-12T23:18:49Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Do we want to keep a reference to potential of CNAMEs in-place, or this is adequately covered elsewhere and in examples?",
              "createdAt": "2021-02-12T23:10:41Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            },
            {
              "originalPosition": 71,
              "body": "The case somewhat ambiguous here is the scenario where an AliasMode record points to a name with only A/AAAA records.  It may help to call this out explicitly.  Which may be clarifying that each time $QNAME changes, SVCB-optional clients SHOULD issue AAAA/A queries.  We may also want some text such as:  \"Note that SVCB-optional clients should be prepared to handle the case where the TargetName of an AliasMode SVCB RR has only AAAA/A records and no ServiceMode record.\"",
              "createdAt": "2021-02-12T23:17:30Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            },
            {
              "originalPosition": 170,
              "body": "Does this mean that ECH-capable SVCB-optional clients can't use Alt-Svc until we define an Alt-Svc-bis that addresses relevant issues?",
              "createdAt": "2021-02-12T23:18:16Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg5OTAwNjI5",
          "commit": {
            "abbreviatedOid": "7371fd9"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-12T23:23:00Z",
          "updatedAt": "2021-02-12T23:23:00Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Whereas with a precise read of the text does cover the \"the case where there is an AliasMode record but no ServiceMode record\" it is not obvious to a reader as shown by both Martin and I not quite getting this until reading a few times.  At a minimum we should have a parenthetical which concretely calls out this case.",
              "createdAt": "2021-02-12T23:23:00Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxMzg4OTMy",
          "commit": {
            "abbreviatedOid": "22169eb"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-16T16:16:21Z",
          "updatedAt": "2021-02-16T16:16:21Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "OK, I've added a clarification for that case.",
              "createdAt": "2021-02-16T16:16:21Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxMzg5Mjg1",
          "commit": {
            "abbreviatedOid": "22169eb"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-16T16:16:41Z",
          "updatedAt": "2021-02-16T16:16:41Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "OK, added to Step 3.",
              "createdAt": "2021-02-16T16:16:41Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxMzkwNTUy",
          "commit": {
            "abbreviatedOid": "22169eb"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-16T16:17:54Z",
          "updatedAt": "2021-02-16T16:17:54Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "No.  ECH-capable SVCB-optional clients can use Alt-Svc unless all returned ServiceForm records include `echconfig`.",
              "createdAt": "2021-02-16T16:17:54Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxNDQzMjUz",
          "commit": {
            "abbreviatedOid": "22169eb"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-16T17:10:30Z",
          "updatedAt": "2021-02-16T17:11:02Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "Is there a reason we're missing what had been the previous steps 2+3?  (ie, to handle the case where the conditional in step 2 doesn't hold?)",
              "createdAt": "2021-02-16T17:10:30Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxNTczNjE3",
          "commit": {
            "abbreviatedOid": "7371fd9"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-16T19:55:11Z",
          "updatedAt": "2021-02-16T19:55:11Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "It's effectively moved to line 1054 (in the Alt-Svc section, instead of talking about Alt-Svc in the ECH section).",
              "createdAt": "2021-02-16T19:55:11Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxNjE2MTg3",
          "commit": {
            "abbreviatedOid": "22169eb"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-16T20:55:15Z",
          "updatedAt": "2021-02-16T20:55:15Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "In-general this numbered list is still confusing since it doesn't have an \"else\" clause to 2.  Perhaps switching it to be a bulletted list or just some flat text would be better?\r\n\r\n",
              "createdAt": "2021-02-16T20:55:15Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxNjIwNTAx",
          "commit": {
            "abbreviatedOid": "22169eb"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-16T21:00:20Z",
          "updatedAt": "2021-02-16T21:00:20Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "Perhaps:\r\n\r\nAccordingly, ECH-capable SVCB-optional clients MUST use SVCB-reliant connection establishment if SVCB resolution succeeded (following {{client-behavior}}), and if all alternative endpoints have an \"echconfig\" key.\r\n",
              "createdAt": "2021-02-16T21:00:20Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxNjQzOTg0",
          "commit": {
            "abbreviatedOid": "156e968"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-16T21:35:34Z",
          "updatedAt": "2021-02-16T21:35:35Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "OK, done.",
              "createdAt": "2021-02-16T21:35:34Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxODA3NjAx",
          "commit": {
            "abbreviatedOid": "156e968"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good.  Do we want to define HTTPS as an explicit SVCB-optional protocol?  (Perhaps a separate issue so we can ship this?)",
          "createdAt": "2021-02-17T03:20:45Z",
          "updatedAt": "2021-02-17T03:20:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxODA5Mzcz",
          "commit": {
            "abbreviatedOid": "156e968"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-17T03:26:34Z",
          "updatedAt": "2021-02-17T03:30:49Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nfor a service, as performed by the client.  SVCB resolution is implemented as follows:\r\n```\r\n\r\nI think that the MUST here is too strong.  The W3C and WHATWG, who specialize in writing algorithmic specifications, only ever say that the outcome should be equivalent to (or indistinguishable from) the algorithm as described.",
              "createdAt": "2021-02-17T03:26:34Z",
              "updatedAt": "2021-02-17T14:42:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 292,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc0OTk0Mzc5",
      "title": "Add changelog for -03",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/292",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-02-17T15:17:48Z",
      "updatedAt": "2021-02-17T15:49:29Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "4d7097007a4fcb47c4b23a1f0d90ebc14c3d79cf",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-changelog",
      "headRefOid": "317384a8964912b849aafdc825cd5fa251d8b424",
      "closedAt": "2021-02-17T15:49:25Z",
      "mergedAt": "2021-02-17T15:49:25Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "56ab3850e30653ece5bc141a37e8d56ccb11fb17"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "OK.  Let's push out -03 and follow up with any additional clarifications as needed.",
          "createdAt": "2021-02-17T15:49:19Z",
          "updatedAt": "2021-02-17T15:49:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyMzM3OTA4",
          "commit": {
            "abbreviatedOid": "317384a"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks fine unless we want to address #293 before publishing.  (We can also do a -04 with that.)",
          "createdAt": "2021-02-17T15:45:18Z",
          "updatedAt": "2021-02-17T15:45:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 294,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc1NzQ0OTg3",
      "title": "Proposal: Recommend not exceeding chain length 8",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/294",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wg"
      ],
      "body": "This change instructs zone operators not to create excessively long\r\nalias chains.  This change does not affect the normative requirements\r\nfor resolvers, which are only required to follow at least one AliasMode\r\nalias.",
      "createdAt": "2021-02-18T14:56:13Z",
      "updatedAt": "2021-02-24T16:27:53Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "56ab3850e30653ece5bc141a37e8d56ccb11fb17",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-limit8",
      "headRefOid": "7fe75d9644df2c7c18878bb9f8f107c3a90f1006",
      "closedAt": "2021-02-24T16:27:50Z",
      "mergedAt": "2021-02-24T16:27:50Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "5dd865364abfde0747493577516f518197b8fcef"
      },
      "comments": [
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "Since other parties are only required to follow at least one, I would make the zone operator recommendation similarly short to maximize compatibility.  I don't think that would be an overburdensome recommendation since it's only a SHOULD, not a MUST.",
          "createdAt": "2021-02-18T19:08:55Z",
          "updatedAt": "2021-02-18T19:08:55Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "8 seems reasonable as proposed",
          "createdAt": "2021-02-18T19:11:01Z",
          "updatedAt": "2021-02-18T19:11:01Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@ericorth, Are you saying you would prefer a lower number here?  Note that, as currently phrased, this is the combined total number of CNAME and AliasMode records in the chain, and this section already says \"domain owners SHOULD minimize the use of AliasMode records\".\r\n\r\nI'd like to avoid setting too tight a bound here, given previous discussions in DNSOP where participants emphasized that resolvers must be free to choose their own limits.  While this is not quite the same context, it seems like smaller numbers may make it harder to get consensus.",
          "createdAt": "2021-02-18T19:19:03Z",
          "updatedAt": "2021-02-18T19:19:03Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "I have a weak preference for a lower number but won't fight for it if you think it would cause consensus-building issues.\r\n\r\nHow about a compromise that might be easier for consensus.  Leave the formal \"SHOULD\" recommendation at 8, but include a sentence after it pointing out that shorter chain links, ideally at most 1, are best for compatibility and performance.  (Assuming there's not already language to about that effect that I'm forgetting about.)",
          "createdAt": "2021-02-18T19:27:00Z",
          "updatedAt": "2021-02-18T19:27:00Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "If this was just AliasMode chains something shorter would be fine.  With this also including CNAMEs, I don't think we can go below 8.",
          "createdAt": "2021-02-18T19:29:23Z",
          "updatedAt": "2021-02-18T19:29:23Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "Fair enough.  Do you think it would be more reasonable to, after the overall chain recommendation of 8, to more explicitly recommend a short number of SVCB-alias links in that chain? Or would that just be too redundant with the \"should avoid alias\" part already in there?",
          "createdAt": "2021-02-18T19:31:48Z",
          "updatedAt": "2021-02-18T19:31:48Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> Fair enough. Do you think it would be more reasonable to, after the overall chain recommendation of 8, to more explicitly recommend a short number of SVCB-alias links in that chain? Or would that just be too redundant with the \"should avoid alias\" part already in there?\r\n\r\nThat seems redundant to me.  It's also a compatibility issue (not performance), so this doesn't seem like exactly the right place for it.  I feel like we already have relevant normative text about the number of AliasModes twice (once in the AliasMode section and again in this section) so a third version is not needed.",
          "createdAt": "2021-02-18T22:02:55Z",
          "updatedAt": "2021-02-18T22:02:55Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "Okay.  Sounds like I'm just being forgetful on how much relevant recommendation is already in the draft, and that we're already in a good place.  So recommended full chain length maximum of 8 SGTM.",
          "createdAt": "2021-02-18T22:07:01Z",
          "updatedAt": "2021-02-18T22:07:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNDQ3OTk5",
          "commit": {
            "abbreviatedOid": "7fe75d9"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "8 is a sensible limit. If anything, it could be lower.",
          "createdAt": "2021-02-18T17:07:01Z",
          "updatedAt": "2021-02-18T17:07:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNTU4MzM2",
          "commit": {
            "abbreviatedOid": "7fe75d9"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-18T19:10:45Z",
          "updatedAt": "2021-02-18T19:10:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk3NjcxMDMz",
          "commit": {
            "abbreviatedOid": "7fe75d9"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-24T16:24:20Z",
          "updatedAt": "2021-02-24T16:24:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 295,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc1OTI5OTcy",
      "title": "DNS for SVCB-reliant proxy usage",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/295",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses one aspect of #293\r\n\r\nDo we need to give more details on how a proxy might be used for DNS lookups (eg, to a DoH server) or is this fine as-is?  Should this be non-normative?",
      "createdAt": "2021-02-18T19:31:41Z",
      "updatedAt": "2021-02-24T21:23:42Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "3325f69984a64b525b4f770a8dd82c69b4b0197f",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-proxy-reliant",
      "headRefOid": "63c7eea80680faeb46cbba90d24d011d83c176bd",
      "closedAt": "2021-02-24T21:23:42Z",
      "mergedAt": "2021-02-24T21:23:42Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "ca7b0236cedc4f2c1dda1e63d8152f52b81d31ed"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd prefer not to recommend DNS-over-proxy to an unaffiliated DNS resolver, since it violates the constraint earlier in the paragraph about disclosing information to more parties.",
          "createdAt": "2021-02-18T20:38:55Z",
          "updatedAt": "2021-02-18T20:38:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNTk1OTA5",
          "commit": {
            "abbreviatedOid": "bbc2f2a"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Text seems reasonable! I expect we can specify more details here in another document.",
          "createdAt": "2021-02-18T19:59:00Z",
          "updatedAt": "2021-02-18T19:59:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNjI0NDY2",
          "commit": {
            "abbreviatedOid": "bbc2f2a"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T20:38:00Z",
          "updatedAt": "2021-02-18T20:38:00Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nconcerns apply, SVCB-optional clients SHOULD disable SVCB resolution.\r\nSVCB-reliant clients cannot function in this configuration, so they must\r\narrange for SVCB resolution with appropriate privacy and routing properties.\r\n```",
              "createdAt": "2021-02-18T20:38:00Z",
              "updatedAt": "2021-02-24T20:18:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNjQ0OTY4",
          "commit": {
            "abbreviatedOid": "bbc2f2a"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T21:07:10Z",
          "updatedAt": "2021-02-18T21:07:11Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Perhaps we also allow for \"SVCB-optional clients SHOULD disable SVCB resolution\r\nunless they arrange for SVCB resolution with appropriate privacy and routing properties.\"",
              "createdAt": "2021-02-18T21:07:10Z",
              "updatedAt": "2021-02-24T20:18:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNjU3MDgy",
          "commit": {
            "abbreviatedOid": "d28e624"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T21:24:22Z",
          "updatedAt": "2021-02-18T21:49:05Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "```suggestion\r\nSVCB resolution separately, likely disclosing the destinations to additional parties.\r\n```",
              "createdAt": "2021-02-18T21:24:22Z",
              "updatedAt": "2021-02-24T20:18:37Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nClients that support such proxies SHOULD arrange for a separate SVCB resolution\r\nprocedure with appropriate privacy properties, or disable SVCB resolution entirely if\r\nSVCB-optional.\r\n```",
              "createdAt": "2021-02-18T21:25:11Z",
              "updatedAt": "2021-02-24T20:18:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk3ODg5NTM5",
          "commit": {
            "abbreviatedOid": "b729c4c"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-24T20:20:34Z",
          "updatedAt": "2021-02-24T20:20:34Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Need to cleanup.\r\n```suggestion\r\ndestinations to an additional party, creating privacy concerns.\r\n```",
              "createdAt": "2021-02-24T20:20:34Z",
              "updatedAt": "2021-02-24T20:20:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk3OTQ3NDE4",
          "commit": {
            "abbreviatedOid": "63c7eea"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-24T21:23:37Z",
          "updatedAt": "2021-02-24T21:23:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 297,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc4NTMwMjM2",
      "title": "Add reference to domain name syntax",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/297",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #296",
      "createdAt": "2021-02-23T15:18:06Z",
      "updatedAt": "2021-02-24T16:36:22Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "3325f69984a64b525b4f770a8dd82c69b4b0197f",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-domain-name",
      "headRefOid": "07eddcdcf0286f9421480193228980b8fd38f1db",
      "closedAt": "2021-02-24T16:36:18Z",
      "mergedAt": "2021-02-24T16:36:18Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "bb8b33f072c8355646668459dbb84739205ffa5b"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood Please review",
          "createdAt": "2021-02-23T15:18:46Z",
          "updatedAt": "2021-02-23T15:18:46Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Committing trivial fix without coauthor review.",
          "createdAt": "2021-02-24T16:36:12Z",
          "updatedAt": "2021-02-24T16:36:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk2NDUzODQ4",
          "commit": {
            "abbreviatedOid": "07eddcd"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM -- thanks!",
          "createdAt": "2021-02-23T15:19:46Z",
          "updatedAt": "2021-02-23T15:19:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 299,
      "id": "MDExOlB1bGxSZXF1ZXN0NTgxMDkzNTkz",
      "title": "s/echconfig/ech/",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/299",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wg"
      ],
      "body": "See #298 and https://github.com/tlswg/draft-ietf-tls-esni/pull/391",
      "createdAt": "2021-02-26T20:13:37Z",
      "updatedAt": "2021-04-20T20:40:01Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "f0a2249acd0faa1369fde4d1f284f90c2aaa8f88",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-ech",
      "headRefOid": "5ca6c254ab70b9abe99729c1150f492a26c9c139",
      "closedAt": "2021-04-20T20:40:01Z",
      "mergedAt": "2021-04-20T20:40:01Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "3f39d8ed16e598dc5f3ed8eced5503f8961f669c"
      },
      "comments": [
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "This should not be happening.  You are abusing the code point allocation.  The record format is supposed to be FIXED when the code point is allocated.  I complained before the code point was allocated that it was not the right time in the development process to perform the allocation.  When the code point is allocated the DNS record should be stable. That is both WIRE and PRESENTATION formats.  Remember master file format is a INTERCHANGE specification.\n\nThe DNS has a reserved range for private types which are fine for experimentation.\n\nMark\n\n> On 27 Feb 2021, at 07:13, Benjamin M. Schwartz <notifications@github.com> wrote:\n> \n> See #298 and tlswg/draft-ietf-tls-esni#391\n> \n> You can view, comment on, or merge this pull request online at:\n> \n>   https://github.com/MikeBishop/dns-alt-svc/pull/299\n> \n> Commit Summary\n> \n> \t\u2022 s/echconfig/ech/\n> File Changes\n> \n> \t\u2022 M draft-ietf-dnsop-svcb-https.md (60)\n> Patch Links:\n> \n> \t\u2022 https://github.com/MikeBishop/dns-alt-svc/pull/299.patch\n> \t\u2022 https://github.com/MikeBishop/dns-alt-svc/pull/299.diff\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n> \n\n-- \nMark Andrews, ISC\n1 Seymour St., Dundas Valley, NSW 2117, Australia\nPHONE: +61 2 9871 4742              INTERNET: marka@isc.org\n\n",
          "createdAt": "2021-02-26T22:16:38Z",
          "updatedAt": "2021-02-26T22:16:38Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Does this argue that we should change the codepoint and abandon echconfig/5 as part of the switch to the \"ech\" key name?  (In some ways this is happening due to the dependent ECH draft making changes.)  That then makes this a key addition rather than a change.",
          "createdAt": "2021-02-26T22:22:05Z",
          "updatedAt": "2021-02-26T22:22:05Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "+1.  If there's any concern whatsoever about compatibility problems from renaming \"echconfig\", let's add a new service parameter codepoint for the renamed param.  In a quick review of the current draft, I don't see any reason that would break stability of SVCB/HTTPS themselves.  I could see an argument if \"echconfig\" were in the automatically-mandatory list, but it's not.",
          "createdAt": "2021-02-26T22:48:36Z",
          "updatedAt": "2021-02-26T22:48:36Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "As a practical matter, I don't think we need to go through a deprecation procedure.  The \"echconfig\" contents are defined by a draft (draft-ietf-tls-esni) that is not finished, and indeed has multiple breaking changes in progress.  I don't think anyone who is using \"echconfig\" in a zone today expects it to be interoperable.  The only deployment I'm aware of exists specifically for interoperability testing of draft versions of ECH, and that is the only appropriate use at this stage.\r\n\r\nAs for the Early Allocation rules, note that \"echconfig\" is not part of the SVCB draft standard presentation format.  Rather, it is a proposed entry in an IANA registry that doesn't exist yet.\r\n\r\nWhile I think it's annoying to have to burn a codepoint in order to change the name, I'm happy to do so if necessary.  If that's the consensus, I think we might as well wait until the ECH draft is final before making any change, to avoid having to do this again.",
          "createdAt": "2021-02-26T23:58:10Z",
          "updatedAt": "2021-02-26T23:58:10Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "How do we get to consensus here?  Options seem to be:\r\n\r\n1. Stick with echconfig and current codepoint.  (Not preferable.)\r\n2. Switch to ech and use new codepoint.   (Burns a codepoint, not strictly necessary.)\r\n3. Switch to ech and keep existing codepoint.   (Changes the presentation to wire format mapping of an existing codepoint.)\r\n\r\nI could go with either 2/3.  @marka63 seems to strongly prefer 2.  @bemasc seems to strongly prefer 3.\r\n",
          "createdAt": "2021-03-15T19:11:01Z",
          "updatedAt": "2021-03-15T19:11:01Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I am fine with any of these three things.  From most preferred to least: 3, 1, 2.  My main point is that, if we go with 2, we should delay the switch as long as possible, to wait until after any possible compatibility-breaking changes in ECH.  (Whereas if we go with 3, we should do it as soon as possible to minimize disruption.)",
          "createdAt": "2021-03-15T19:16:30Z",
          "updatedAt": "2021-03-15T19:16:30Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "What about going with 2, but leaving instructions for that switch to happen once TLS ECH passes its last-call? \r\nCan we do something like updating the text to use \"ech\" but leave the codepoint listed as \"to-be-assigned\"\r\nand then assign it shortly before publication?",
          "createdAt": "2021-03-15T19:49:24Z",
          "updatedAt": "2021-03-15T19:49:24Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@enygren That sounds complicated.  I don't know how to explain it to the RFC Editor, and I don't know what advice I would give to an implementer.  It seems a lot easier to just change nothing (which might be less confusing after s/ECHConfigs/ECHConfigList/).",
          "createdAt": "2021-03-15T20:45:30Z",
          "updatedAt": "2021-03-15T20:45:30Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Changing nothing will remain confusing because ECH has a structure called ECHConfig, and that is *not* the structure that goes in SVCB. The intent hasn't been for SVCB to contain an ECHConfig since draft-ietf-tls-esni-07, the very first draft that used the ECH name. The \"echconfig\" name was a mistake from the beginning.\r\n\r\nGiven SVCB and ECH are getting published at different times, should the code point definition just be moved out of SVCB and into ECH? Though this is somewhat moot because, on the compatibility side, the ECHConfigList structure is already internally versioned.",
          "createdAt": "2021-03-15T21:55:29Z",
          "updatedAt": "2021-03-15T21:55:29Z"
        },
        {
          "author": "bwelling",
          "authorAssociation": "NONE",
          "body": "An alternative solution could be to change the parameter name to `ech`, and support `echconfig` as an alias.  I think that would satisfy at least some backwards compatibility issues.",
          "createdAt": "2021-03-16T00:33:36Z",
          "updatedAt": "2021-03-16T00:33:36Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Most of the SVCB parameters are singular-name, multiple-value, so `echconfig=<ECHConfigList>` seems to fit the pattern.  However, I'm certainly happy to change it if it still seems confusing.\r\n\r\nMaintaining an alias is possible, but I would rank it lower than the other three options.  It makes \"echconfig\" different from all other parameters, it seems to create a permanent burden to deal with a temporary problem, and I'm not sure it actually satisfies the desire for zone-file compatibility with existing draft implementations.  (Of course, burning the codepoint is even worse for zone file compatibility.)",
          "createdAt": "2021-03-16T02:00:00Z",
          "updatedAt": "2021-03-16T02:00:00Z"
        },
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "You have already introduced incompatible changes with alpn comma escape processing.  All these incompatible changes are, in part, why BIND hasn't shipped a version which supports these record types despite the requests for them from our customers.\r\n\r\nWhether the type codes and mnemonics are already burnt or not I don't know.  Every vendor that has already shipped parsers could treat the changes as incompatible bug fixes and one could get away with it.  ",
          "createdAt": "2021-03-16T03:04:38Z",
          "updatedAt": "2021-03-16T03:04:38Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "> How do we get to consensus here? Options seem to be:\r\n> \r\n> 1. Stick with echconfig and current codepoint.  (Not preferable.)\r\n> 2. Switch to ech and use new codepoint.   (Burns a codepoint, not strictly necessary.)\r\n> 3. Switch to ech and keep existing codepoint.   (Changes the presentation to wire format mapping of an existing codepoint.)\r\n> \r\n> I could go with either 2/3. @marka63 seems to strongly prefer 2. @bemasc seems to strongly prefer 3.\r\n\r\n3 is good, 2 is fine but seems a bit officious, and 1 seems kind of bad but livable.\r\n\r\nSo, they're all ok.",
          "createdAt": "2021-03-16T04:04:42Z",
          "updatedAt": "2021-03-16T04:04:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Like @enygren, I'm fine with 3 or 2, but lean towards 3 given the state of this record and its users. ",
          "createdAt": "2021-03-16T15:48:58Z",
          "updatedAt": "2021-03-16T15:48:58Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "I prefer 3.  There's a certain appeal to just letting ECH register the codepoint in their doc, but that seems orthogonal to this question.",
          "createdAt": "2021-03-16T20:09:17Z",
          "updatedAt": "2021-03-16T20:09:17Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, moving the registration mostly relates if we're doing (2) + delay. If we do the delay thing, we may as well move the codepoint IMO.\r\n\r\nI also prefer (3), in which case I agree it's orthogonal and doesn't matter much.",
          "createdAt": "2021-03-16T22:01:08Z",
          "updatedAt": "2021-03-16T22:01:08Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "For comparison, I've created a draft meta-PR that allocates a new codepoint for \"ech\": #316.  Hopefully this helps people weigh the options here in terms of complexity, compatibility, and potential for confusion.",
          "createdAt": "2021-04-16T15:59:19Z",
          "updatedAt": "2021-04-16T15:59:19Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I prefer 3 as well, FWIW. ",
          "createdAt": "2021-04-18T13:17:09Z",
          "updatedAt": "2021-04-18T13:17:09Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm with option 3 as well. ",
          "createdAt": "2021-04-20T20:11:36Z",
          "updatedAt": "2021-04-20T20:11:36Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I'm going to merge this as-is and publish a new version for further discussion.",
          "createdAt": "2021-04-20T20:39:53Z",
          "updatedAt": "2021-04-20T20:39:53Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5OTYyMjUx",
          "commit": {
            "abbreviatedOid": "6814b02"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-26T21:41:45Z",
          "updatedAt": "2021-02-26T21:41:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 301,
      "id": "MDExOlB1bGxSZXF1ZXN0NTgzMzUzMTA5",
      "title": "Remove all shortnames for RFC references",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/301",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I surveyed the ten most recent RFCs, and many of them use shortname\r\nreferences, but not for RFCs.",
      "createdAt": "2021-03-02T21:25:15Z",
      "updatedAt": "2021-03-13T18:34:10Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "ca7b0236cedc4f2c1dda1e63d8152f52b81d31ed",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-rfc",
      "headRefOid": "92225e11623cce8fb41f58dba30c96aed9bdbd50",
      "closedAt": "2021-03-13T18:34:10Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "It looks like RFC 8470 is an example that _does_ use shortnames for RFCs, so there's not a clear rule against this.  I think we can leave this as-is until closer to publication.",
          "createdAt": "2021-03-13T18:34:10Z",
          "updatedAt": "2021-03-13T18:34:10Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 302,
      "id": "MDExOlB1bGxSZXF1ZXN0NTkzMzYxNzM3",
      "title": "s/ECHConfigs/ECHConfigList/",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/302",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See #298 and tlswg/draft-ietf-tls-esni#391",
      "createdAt": "2021-03-15T20:12:24Z",
      "updatedAt": "2021-03-15T20:37:02Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "25f908144dc49d1cb3b91f90bd1f4ca453a84a12",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-echconfiglist",
      "headRefOid": "bd2377203b9fa21d735e7f85014b4e4a27b21e74",
      "closedAt": "2021-03-15T20:36:59Z",
      "mergedAt": "2021-03-15T20:36:59Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "5a5a54676d99b1ee3dbd48de2a682b99fc6f6e1c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjEyNjE3NzE2",
          "commit": {
            "abbreviatedOid": "bd23772"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-15T20:31:31Z",
          "updatedAt": "2021-03-15T20:31:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 303,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk0MDA1NDIy",
      "title": "Using TargetName to a proxy should be a MUST",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/303",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When using a proxy with a SVCB record, using TargetName is a \"MUST\" as otherwise a client\r\nmight attempt to use parameters from a SVCB record with the service name which \r\nwill not always work.",
      "createdAt": "2021-03-16T15:27:29Z",
      "updatedAt": "2021-03-16T20:24:05Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "5a5a54676d99b1ee3dbd48de2a682b99fc6f6e1c",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-proxy-targetname-must",
      "headRefOid": "fec3559d73b2c2f992d5c9bdbf870f1681bcc1f2",
      "closedAt": "2021-03-16T20:24:05Z",
      "mergedAt": "2021-03-16T20:24:05Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "5b61912583c93a06215b980fa9b9e5aaa65f14a4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjEzNDAyNTAy",
          "commit": {
            "abbreviatedOid": "8d2698d"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-16T15:35:10Z",
          "updatedAt": "2021-03-16T15:35:16Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nusing a SVCB record, clients MUST provide the final TargetName and port to the\r\n```",
              "createdAt": "2021-03-16T15:35:10Z",
              "updatedAt": "2021-03-16T20:19:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 304,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk0MjQ2ODQ2",
      "title": "Add release notes for -04",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/304",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-16T21:24:11Z",
      "updatedAt": "2021-03-17T16:54:21Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "5b61912583c93a06215b980fa9b9e5aaa65f14a4",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-release-notes",
      "headRefOid": "4ffd05e79957234f601b1e8959459e0ed096f452",
      "closedAt": "2021-03-17T16:54:18Z",
      "mergedAt": "2021-03-17T16:54:18Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "1b9fb2e671d04766595c81a5198e13472491c06c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjEzNzg4ODYz",
          "commit": {
            "abbreviatedOid": "4ffd05e"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-16T22:51:26Z",
          "updatedAt": "2021-03-16T22:51:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 306,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk0Nzc1NTY2",
      "title": "Remove the name for \"invalid\"",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/306",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Requested in #305",
      "createdAt": "2021-03-17T14:41:40Z",
      "updatedAt": "2021-03-17T16:19:22Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "5b61912583c93a06215b980fa9b9e5aaa65f14a4",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-iana",
      "headRefOid": "e6a70a42f9efd6d1491b219c58d1e123606b546c",
      "closedAt": "2021-03-17T16:19:15Z",
      "mergedAt": "2021-03-17T16:19:15Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "c9bcb05fb44cb2dafa7759a690e0ae13b91f4356"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE0NTA5NTEx",
          "commit": {
            "abbreviatedOid": "e6a70a4"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-17T16:06:35Z",
          "updatedAt": "2021-03-17T16:06:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 307,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk2NzM5NzM3",
      "title": "Add some test-vectors",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/307",
      "state": "CLOSED",
      "author": "pieterlexis",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed on the mailinglist, this is a PR with test vectors. I've tried to explain each set of bytes in the wire format. Let me know if there's anything that needs changing.",
      "createdAt": "2021-03-19T16:57:44Z",
      "updatedAt": "2021-04-08T14:54:40Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "1b9fb2e671d04766595c81a5198e13472491c06c",
      "headRepository": "pieterlexis/dns-alt-svc",
      "headRefName": "test-vectors",
      "headRefOid": "ef5473d2e597818789cf1bb92f78a2af892c0b62",
      "closedAt": "2021-04-08T14:54:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "Needed an escaped comma alpn example.",
          "createdAt": "2021-03-25T05:17:09Z",
          "updatedAt": "2021-03-25T05:17:09Z"
        },
        {
          "author": "pieterlexis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Needed an escaped comma alpn example.\r\n\r\nI'll add that as well\r\n\r\n@bwelling thanks! I had to hand-craft these values :). I'll fix them",
          "createdAt": "2021-03-25T10:13:42Z",
          "updatedAt": "2021-03-25T10:13:42Z"
        },
        {
          "author": "marka63",
          "authorAssociation": "NONE",
          "body": "add out-of-order mandatory example",
          "createdAt": "2021-03-29T03:19:52Z",
          "updatedAt": "2021-03-29T03:19:52Z"
        },
        {
          "author": "pieterlexis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> add out-of-order mandatory example\r\n\r\nI modified an existing vector to showcase this.",
          "createdAt": "2021-03-29T14:46:38Z",
          "updatedAt": "2021-03-29T14:46:38Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@pieterlexis Thanks.  I guess we might as well add an ALPN with an embedded backslash to that list...",
          "createdAt": "2021-03-29T14:55:22Z",
          "updatedAt": "2021-03-29T14:55:22Z"
        },
        {
          "author": "pieterlexis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @pieterlexis Thanks. I guess we might as well add an ALPN with an embedded backslash to that list...\r\n\r\nDone, please check, this was artisinally handcrafted :) (and found an issue in the PowerDNS text writer)",
          "createdAt": "2021-03-29T17:08:48Z",
          "updatedAt": "2021-03-29T17:08:48Z"
        },
        {
          "author": "bwelling",
          "authorAssociation": "NONE",
          "body": "If there are examples of escaping in ALPN parameters, it might also be good to have examples of escaping in the unregistered key (keyNN) format.",
          "createdAt": "2021-03-29T17:49:52Z",
          "updatedAt": "2021-03-29T17:49:52Z"
        },
        {
          "author": "pieterlexis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If there are examples of escaping in ALPN parameters, it might also be good to have examples of escaping in the unregistered key (keyNN) format.\r\n\r\nThe section on mandatory says \"To enable simpler parsing, this SvcParamValue MUST NOT contain escape sequences.\"",
          "createdAt": "2021-03-29T20:02:51Z",
          "updatedAt": "2021-03-29T20:02:51Z"
        },
        {
          "author": "bwelling",
          "authorAssociation": "NONE",
          "body": "> > If there are examples of escaping in ALPN parameters, it might also be good to have examples of escaping in the unregistered key (keyNN) format.\r\n> \r\n> The section on mandatory says \"To enable simpler parsing, this SvcParamValue MUST NOT contain escape sequences.\"\r\n\r\nThe text for all of the defined formats other than ALPN says that, but the text for the unregistered key format (which is what I was suggesting an example for) does not.  It specifically says that the value is a char-string, whose definition (as far as I can tell) includes escaping.",
          "createdAt": "2021-03-29T20:12:25Z",
          "updatedAt": "2021-03-29T20:12:25Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@bwelling correct.  For example, you can spell `port=123` as `key3=\\000\\123`. ",
          "createdAt": "2021-03-30T01:03:29Z",
          "updatedAt": "2021-03-30T01:03:29Z"
        },
        {
          "author": "wtoorop",
          "authorAssociation": "NONE",
          "body": "FYI, we're planning to create a pull request including the commits in this one, with some failure cases added",
          "createdAt": "2021-04-07T08:54:25Z",
          "updatedAt": "2021-04-07T08:54:25Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@pieterlexis Should we close this in favor of #312?",
          "createdAt": "2021-04-07T15:58:11Z",
          "updatedAt": "2021-04-07T15:58:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5ODU5Mjc4",
          "commit": {
            "abbreviatedOid": "68bfcda"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me.  I wonder if it would be clearer to use a little less whitespace in the RFC 3597 examples, to highlight the distinction between uint16, uint8, and bytestring sequences, but that's up to you.\r\n\r\nWaiting for another coauthor to confirm before merging.",
          "createdAt": "2021-03-24T15:18:48Z",
          "updatedAt": "2021-03-24T15:18:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMjgzODU4",
          "commit": {
            "abbreviatedOid": "68bfcda"
          },
          "author": "bwelling",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "I just tried testing the RFC 3597 for of these test vectors, and found a number of issues.",
          "createdAt": "2021-03-24T22:31:23Z",
          "updatedAt": "2021-03-24T22:33:55Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "This should be 00 01, not 00 10.",
              "createdAt": "2021-03-24T22:31:23Z",
              "updatedAt": "2021-03-29T17:08:15Z"
            },
            {
              "originalPosition": 77,
              "body": "This should be 00 01, not 00 10.",
              "createdAt": "2021-03-24T22:31:37Z",
              "updatedAt": "2021-03-29T17:08:15Z"
            },
            {
              "originalPosition": 95,
              "body": "This should be 00 01, not 00 10.",
              "createdAt": "2021-03-24T22:31:48Z",
              "updatedAt": "2021-03-29T17:08:15Z"
            },
            {
              "originalPosition": 117,
              "body": "This should be \\\\# 46, not \\\\# 48",
              "createdAt": "2021-03-24T22:32:10Z",
              "updatedAt": "2021-03-29T17:08:15Z"
            },
            {
              "originalPosition": 94,
              "body": "This should be \\\\# 55, not \\\\# 57\r\n",
              "createdAt": "2021-03-24T22:33:10Z",
              "updatedAt": "2021-03-29T17:08:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 308,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk5MzE2NDY3",
      "title": "Specify interaction with ECS",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/308",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change explains how to make SVCB play nicely with ECS, for both\r\nrecursive and authoritative servers.  The proposed behavior is\r\nconservative, staying fully compliant with RFC 7871 (ECS) while allowing\r\nimproved caching performance when it is safe to do so.",
      "createdAt": "2021-03-24T02:09:32Z",
      "updatedAt": "2021-04-16T15:49:38Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "1b9fb2e671d04766595c81a5198e13472491c06c",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-ecs",
      "headRefOid": "2982b3bd35e4a1bfbdfa7dd76922e6da2d2d8913",
      "closedAt": "2021-04-16T15:49:38Z",
      "mergedAt": "2021-04-16T15:49:38Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "f0a2249acd0faa1369fde4d1f284f90c2aaa8f88"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the feedback, everyone.  There have been several requests for a simpler version that permits more creative use of ECS, so I've drawn up #309 as an alternative.  Please take a look.\r\n\r\nThis is a confusing topic.  Hopefully, #309 will help make it clearer that\r\n1. The ECS-conditional behavior for authoritative servers is unavoidable because Additional records always have an implicit SCOPE PREFIX-LENGTH of zero.\r\n2. The key question is whether full-service resolvers MUST, SHOULD, MAY, or SHOULD NOT send the same ECS on SVCB as A/AAAA.  This is essentially a tradeoff between cache efficiency (SHOULD NOT) and usage flexibility (SHOULD/MUST).",
          "createdAt": "2021-03-29T02:14:55Z",
          "updatedAt": "2021-03-29T02:14:55Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems that we have consensus to support non-address variation with ECS (e.g. ECS-dependent CNAME), so I've merged #309, which simplifies this PR by removing the cache optimization.",
          "createdAt": "2021-03-31T17:04:18Z",
          "updatedAt": "2021-03-31T17:04:18Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks everyone for your input and reviews.  It seems like we've found a broadly acceptable solution here, but please continue to provide feedback if there's something you'd like to change.",
          "createdAt": "2021-04-16T15:49:27Z",
          "updatedAt": "2021-04-16T15:49:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5MjU2NTY0",
          "commit": {
            "abbreviatedOid": "e7cc129"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T02:29:16Z",
          "updatedAt": "2021-03-24T02:29:16Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I'm not sure I follow the \"unless it knows they will not be used\".  How does the resolver know that ipv*hint might not be used?",
              "createdAt": "2021-03-24T02:29:16Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5MjYwNTgz",
          "commit": {
            "abbreviatedOid": "e7cc129"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T02:39:40Z",
          "updatedAt": "2021-03-24T02:39:41Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Clients only use ipv*hint if the response doesn't include A+AAAA records for TargetName in the Additional section.  If the recursive resolver knows that it is going to include those additional address records in the response, then it knows the hints will never be used.",
              "createdAt": "2021-03-24T02:39:40Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5Mjc1Mzkw",
          "commit": {
            "abbreviatedOid": "e7cc129"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T03:16:42Z",
          "updatedAt": "2021-03-24T03:16:42Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Where this gets confusing is with the subsequent guidance that records in the Additional section should not be included if ECS is being used.   Isn't the guidance effectively then \"Send ECS so SVCB records can be usable with ipv*hint.  Plan to not send Additional records.\" ?",
              "createdAt": "2021-03-24T03:16:42Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5MzczMDIy",
          "commit": {
            "abbreviatedOid": "e7cc129"
          },
          "author": "mmuhaime",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T06:48:18Z",
          "updatedAt": "2021-03-24T06:48:18Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I think the proposal is saying: \r\nwhen a recursive resolver does not include additional records for the client, it knows hints may be used by the client, so it needs to ensure that the ipv4hint answer is answered properly honoring ECS info. So the recursive needs to send ECS to the authorities. Whether the auths include additionals or not in this case (that is the the subject of \"According to Section 7.3.1 of {{!RFC7871}}, \" paragraph) does not matter because the recursive is not including the additionals in its response to the client anyway. \r\n\r\nWhen recursive resolver does include additional records for the client, ipv[46]hint should not be used, so the ipv[46]hint from auths don't need to vary by ECS, hence the /0 suggestion to avoid extra per-subnet caching. Additionally, the recommendation in the draft is for auths to not return additionals if they think the additionals should also vary by ECS (this is a general recommendation, not just for when an auth sees /0). The recursive, not finding additionals, will subsequently ask A/AAAA queries with proper ECS and will include ECS based answers in in its additional section that it sends to clients. I think the following is implicit: if auths do respond with additionals then recrusives will use those non-ECS based additionals in its response to the client. \r\n\r\nI think your recommendation about auths not responding with additionals when receiving ECS data for SVCB queries is the right thing to do.  \r\n\r\nSo overall the proposal looks ok but I am a little worried about the ipv4hint complexity (setting ECS source mask to /0). /0 is kind of a special case and I am worried that many auths will return non-ECS additionals when sent /0 and it will take time for people to realize and fix this for SVCB. Making recursives always send the same ECS prefix with SVCB (that is sent for A/AAAA) seems desirable from a reducing complexity point of view. ",
              "createdAt": "2021-03-24T06:48:18Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NzQ0MTM3",
          "commit": {
            "abbreviatedOid": "e7cc129"
          },
          "author": "jdreed",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T13:52:41Z",
          "updatedAt": "2021-03-24T13:52:41Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I agree with Mashooq, I don't like the idea of the recursive potentially changing its ECS behavior for SVCB.  That's going to be a mess for debugging, and will potentially trigger some authoritative behavior that tries to infer whether the resolver supports ECS or not.  Sending a source prefix of 0 means \"I understand ECS, but I'm not going to use it\", and is used as a signal for a desire for privacy on the part of the end user.   I don't like the idea of overloading that for a SVCB-specific meaning.  \r\n\r\nRFC7871 is pretty clear about the circumstances under which a resolver that supports ECS would not send it:  a) when it's asking for a TLD/PSL; b) when it has learned that a given auth doesn't support ECS; c) when it is using an explicit ACL and the auth isn't on that list.  (b) is already pretty ambiguous and highly subjective, I'm not excited about adding another exception to that list.",
              "createdAt": "2021-03-24T13:52:41Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5ODQ1MzQy",
          "commit": {
            "abbreviatedOid": "e7cc129"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T15:08:11Z",
          "updatedAt": "2021-03-24T15:08:11Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "@mmuhaime's interpretation matches my intent here.\r\n\r\nI don't think the \"/0\" behavior is too tricky for Authoritative servers: \"see ECS -> no Additional\" seems simpler than \"see ECS with nonzero prefix -> no Additional\".  I also don't think that this will take time to sort out.  Neither of these codepaths exists today, so if we clearly specify which behavior nameservers should implement, I think we can get it.  If we don't specify, we might get a mix of both.\r\n\r\n@jdreed Having different behavior for SVCB is entirely in line with RFC 7871, which says\r\n\r\n>   Implementations MAY also allow additional configuring of this based\r\n>   on other criteria, such as zone or query type.\r\n\r\nSending \"/0\" means \"I support ECS but I have disabled it for this query\".  That's exactly how this PR uses it.\r\n\r\nHere are some alternative designs:\r\n* ECS recursives send the same ECS for SVCB as they do for A/AAAA.  This significantly reduces cache efficiency when IP hints are included and the recursive resolver knows they will not be used (\"full service resolver\").\r\n  - Also bind A/AAAA in the Additional section to the ECS scope of the SVCB response.  This reduces latency (no followup query to get ECS A/AAAA) but violates (updates?) the letter of RFC 7871's prohibition against ECS in the Additional section.  (I don't think it violates the spirit: that requirement is for records that will be used by the recursive resolver itself, which these are not.)\r\n     * And also let full service resolvers treat all SVCB records as cacheable for \"/0\" (i.e. ECS applies _only_ to the Additional section).  This maximizes performance but substantially deviates from RFC 7871.\r\n* Let full service resolvers disable ECS for SVCB, but don't require nameservers to distinguish \"/0\" from \"no ECS\".  This has good caching efficiency but adds latency: it requires the resolver to ignore all Additional A/AAAA records if ECS could be used, even when ECS is not actually in use.",
              "createdAt": "2021-03-24T15:08:11Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5ODY0OTA3",
          "commit": {
            "abbreviatedOid": "e7cc129"
          },
          "author": "jdreed",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T15:23:12Z",
          "updatedAt": "2021-03-24T15:23:12Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "OK, fair, I think I misread this initially and thought it was proposing one case under which no ECS option would be sent (vs sending a /0), and that was the part I was most worried about.",
              "createdAt": "2021-03-24T15:23:12Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMDE1MDg1",
          "commit": {
            "abbreviatedOid": "e7cc129"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T17:21:27Z",
          "updatedAt": "2021-03-24T17:21:28Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Possible improvement to help with any confusion over \"unless it knows they will not be used, due to resolver's implementation of Additional section processing\": maybe convert to something along the lines of \"unless it implements Additional section processing, and therefore knows they will be unnecessary to a client that properly prefers A/AAAA results over ipv*hint SvcParams\".  As written, the statement is kinda backwards in that it explains the justification (\"knows they will not be used\") before the clear, concise condition (\"implements Additional section processing\").",
              "createdAt": "2021-03-24T17:21:28Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMTA4NTE2",
          "commit": {
            "abbreviatedOid": "e7cc129"
          },
          "author": "mmuhaime",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T18:31:46Z",
          "updatedAt": "2021-03-24T18:31:47Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "The original technical proposal seems good to me. I do like @ericorth 's wording better because I think it will make it easier to understand. \r\nWe could also use something like: \" If a recursive resolver knows that the client may use the ipv[46]hints, it should use the same ECS prefix for SVCB query that it uses for A/AAAA queries when questioning Authoritative servers.  \r\n If a recursive resolver knows that the client will not use ipv[46]hints, then it MAY include an ECS with a SOURCE PREFIX-LENGTH of zero to indicate that ECS is supported but disabled. One scenario where the recursive knows ipv[46]hints won't be used is when it includes resolved addresses for the SVCB target names in the additionals section in its response to clients.\" ",
              "createdAt": "2021-03-24T18:31:46Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMTIwODY3",
          "commit": {
            "abbreviatedOid": "063a815"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T18:45:54Z",
          "updatedAt": "2021-03-24T18:45:54Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "OK, I've reworked the text for clarity based on the feedback in this thread.",
              "createdAt": "2021-03-24T18:45:54Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMTg4MTcx",
          "commit": {
            "abbreviatedOid": "757d8a2"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-24T20:10:24Z",
          "updatedAt": "2021-03-24T20:10:24Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzE5NDM1",
          "commit": {
            "abbreviatedOid": "757d8a2"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T23:50:11Z",
          "updatedAt": "2021-03-24T23:50:11Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Would it be acceptable to encode geo information into a TargetName based on ECS?  Or to not include QUIC in ASNs where QUIC is known to be broken?  What is the rationale for this SHOULD NOT?",
              "createdAt": "2021-03-24T23:50:11Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzIwNzcy",
          "commit": {
            "abbreviatedOid": "757d8a2"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T23:53:46Z",
          "updatedAt": "2021-03-24T23:53:46Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Do we also want a bullet/entry suggesting that recursive resolvers implementing ECS for client performance MAY/SHOULD disable sending Additional A/AAAA records to clients in-favor of being able to use ECS to authorities?  The DNS performance may be better but the overall experience/performance could be much worse. ",
              "createdAt": "2021-03-24T23:53:46Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzI3MTk4",
          "commit": {
            "abbreviatedOid": "757d8a2"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T00:10:43Z",
          "updatedAt": "2021-03-25T00:10:43Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "The behavior described here means that many (most?) ECS-capable resolvers will send \"/0\" in SVCB queries, so any attempt to make use of ECS for those features will fail.\r\n\r\nAlso, the majority of resolvers simply don't do ECS at all, so ECS generally is not usable for anything other than performance optimizations.",
              "createdAt": "2021-03-25T00:10:43Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzI4MjEz",
          "commit": {
            "abbreviatedOid": "757d8a2"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T00:13:27Z",
          "updatedAt": "2021-03-25T00:13:28Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I don't think that makes sense.  If the recursive resolver disables ECS for SVCB, clients will still be using ECS-derived A and AAAA records, so connection performance should not be impaired.",
              "createdAt": "2021-03-25T00:13:27Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMjU1MTA1",
          "commit": {
            "abbreviatedOid": "757d8a2"
          },
          "author": "puneetsood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "LGTM with slight wording changes.",
          "createdAt": "2021-03-24T21:41:07Z",
          "updatedAt": "2021-03-25T20:44:39Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Suggest rewording: \"A recursive resolver that performs A/AAAA resolution for TargetName, as recommended in {{recursive-behavior}}, SHOULD ...\" to clarify the resolution is the key part - there may/may not be A/AAAA records added to the response for other reasons (NODATA, query failures/timeouts).",
              "createdAt": "2021-03-24T21:41:07Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            },
            {
              "originalPosition": 38,
              "body": "Similarly reword: \"If the resolver does not perform TargetName resolution, ...\".",
              "createdAt": "2021-03-24T21:42:23Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            },
            {
              "originalPosition": 39,
              "body": "ECS extension -> ECS option.\r\n\r\nOther places too.",
              "createdAt": "2021-03-25T19:16:00Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIxNTc1NjM0",
          "commit": {
            "abbreviatedOid": "5a0f8ba"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T21:01:33Z",
          "updatedAt": "2021-03-25T21:01:33Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Done",
              "createdAt": "2021-03-25T21:01:33Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIxNTgzMjYz",
          "commit": {
            "abbreviatedOid": "4dc994b"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T21:12:01Z",
          "updatedAt": "2021-03-25T21:12:02Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "OK, changed to \"If the resolver plans to resolve A/AAAA records for TargetName and return them in the Additional section, ...\".",
              "createdAt": "2021-03-25T21:12:02Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIxNTgzMzIz",
          "commit": {
            "abbreviatedOid": "4dc994b"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T21:12:06Z",
          "updatedAt": "2021-03-25T21:12:06Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "OK, changed to \"If the resolver does not plan to perform this resolution...\".",
              "createdAt": "2021-03-25T21:12:06Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIxNjI0NTA5",
          "commit": {
            "abbreviatedOid": "4dc994b"
          },
          "author": "rs",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T22:18:55Z",
          "updatedAt": "2021-03-25T22:18:55Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "What is the reasoning here? The HTTPSSVC record has great potentials for DNS steering with the use of the priority field to favor closer location while providing some higher latency fallback locations.\r\n\r\nDefining per qtype behavior for ECS will also add complexity and is most likely unexpected by most auth DNS operators.",
              "createdAt": "2021-03-25T22:18:55Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyMTc4ODk4",
          "commit": {
            "abbreviatedOid": "4dc994b"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-26T14:04:03Z",
          "updatedAt": "2021-03-26T14:04:04Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "DNS steering with priority is allowed within this rule.  It would look like\r\n```dns\r\n; static\r\nwww.example.com HTTPS IN 600 1 .\r\n                             2 fallback.example.com.\r\n; ECS-controlled\r\nwww.example.com AAAA ...\r\nfallback.example.com AAAA ...\r\n```\r\n\r\nFrom the auth side, the per-QTYPE behavior here is only for authoritative servers that already have per-QTYPE behavior for SVCB (appending the Additional A/AAA records).  Arguably, this is not actually per-QTYPE behavior: the same logic applies to MX and SRV, if anyone wanted to use ECS with them, because they do the same trick of putting A/AAAA in Additional, and Additional can't use ECS.",
              "createdAt": "2021-03-26T14:04:04Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyMjMwOTYz",
          "commit": {
            "abbreviatedOid": "4dc994b"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-26T14:53:10Z",
          "updatedAt": "2021-03-26T14:53:10Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "For what it's worth, there are also plenty of places where ECS will get used today\r\non CNAME records that end up pointing to SVCB records.  For example\r\nthe following will be part of a very common deployment path that is widely used today:\r\n\r\n```\r\nwww.foo.example. CNAME IN 600 foo.georedir.example.net.\r\nfoo.georedir.example.net CNAME IN 600 foo.cdn.example.\r\nfoo.cdn.example. HTTPS IN 600 ...\r\nfoo.cdn.example. A IN 600 ...\r\nfoo.cdn.example. AAAA IN 600 ...\r\n```\r\n\r\nIn this case, \"foo.georedir.example.net.\" may be doing multi-CDN splitting\r\nbased on client geo/asn and using ECS as part of this.  \r\nAs such, having a \"SHOULD NOT\" for ECS with SVCB seems likely\r\nto be problematic since the authority here issuing the SVCB has no control\r\nover whether a CNAME pointing to it is using ECS.\r\n\r\nJust changing the A/AAAA case won't help when the protocols may need \r\nto vary (eg, \"ISP ___ in the US breaks QUIC by randomly dropping UDP\r\nand thus we don't want to offer it for clients in their ASN\").\r\n",
              "createdAt": "2021-03-26T14:53:10Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyMjcxNzI5",
          "commit": {
            "abbreviatedOid": "4dc994b"
          },
          "author": "rs",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-26T15:30:08Z",
          "updatedAt": "2021-03-26T15:30:08Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "> DNS steering with priority is allowed within this rule. It would look like\r\n> \r\n> ```\r\n> ; static\r\n> www.example.com HTTPS IN 600 1 .\r\n>                              2 fallback.example.com.\r\n> ; ECS-controlled\r\n> www.example.com AAAA ...\r\n> fallback.example.com AAAA ...\r\n> ```\r\n\r\nThat will requires two round trips from the resolver to the auth, assuming the resolver supports filling the iphints or worse, RTT from the client when resolver support is missing. We are losing a latency improvement opportunity here, where the auth could just provide a self contained response to minimize traffic and latency while doing steering. \r\n\r\nI think iphint from auth is especially important in the context of DNS steering as those A/AAAA have limited TTL and thus, those additional round trips won't be the exception.\r\n\r\nTo me the only reason for adding this clause is economical on the resolver side. Having a new popular qtype with ECS cache split can be expensive, especially for a huge resolver like quad8. If that's the motivation, it should be stated clearly, as I see no purely technical reason for this change.",
              "createdAt": "2021-03-26T15:30:08Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNzc1MDQ2",
          "commit": {
            "abbreviatedOid": "4cbd66c"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-28T19:23:52Z",
          "updatedAt": "2021-03-28T19:23:52Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "```suggestion\r\nMUST omit such records if they wish to serve subnet-specific addresses.\r\n```\r\n\r\n???",
              "createdAt": "2021-03-28T19:23:52Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyODIyMDQ1",
          "commit": {
            "abbreviatedOid": "4cbd66c"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-29T02:02:19Z",
          "updatedAt": "2021-03-29T02:02:19Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "@enygren\r\n> For what it's worth, there are also plenty of places where ECS will get used today on CNAME records\r\n\r\nI think ECS-variant CNAMEs should probably have been banned in the ECS spec, and this seems like a good opportunity to start phasing them out.  However, if we decide that they should be well-supported, then you're right that we need ECS on the SVCB queries.  I've drawn up #309 to show what I think that would look like.\r\n\r\n> Just changing the A/AAAA case won't help when the protocols may need\r\n> to vary (eg, \"ISP ___ in the US breaks QUIC by randomly dropping UDP\r\n> and thus we don't want to offer it for clients in their ASN\").\r\n\r\nYuck.  You can't rely on ECS, so clients need to handle this anyway.  Any network of this kind is horribly broken, so we shouldn't be trying to put in performance optimizations for it.\r\n\r\n@rs\r\n> That will requires two round trips from the resolver to the auth\r\n\r\nThe number of roundtrips actually has nothing to do with whether the resolver is allowed to disable ECS.  I made a slight text update that I hope makes the reasoning clearer; you can also look at #309.\r\n\r\n> To me the only reason for adding this clause is economical on the resolver side. Having a new popular qtype with ECS cache split can be expensive\r\n\r\nYes, the motivation is cache performance, but the resolver can operate with any cache size it likes, so it's not exactly an \"expense\".  Even with an infinite cache size, unnecessary use of ECS harms performance for users, by making cache hits less likely.",
              "createdAt": "2021-03-29T02:02:19Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyODI1Njg3",
          "commit": {
            "abbreviatedOid": "4cbd66c"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-29T02:17:24Z",
          "updatedAt": "2021-03-29T02:17:24Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "\"MUST if you wish\" in all-caps seems strange to me.",
              "createdAt": "2021-03-29T02:17:24Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NzIzNzIy",
          "commit": {
            "abbreviatedOid": "57be5d9"
          },
          "author": "puneetsood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T21:35:03Z",
          "updatedAt": "2021-03-30T21:35:03Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "> @enygren\r\n> \r\n> > For what it's worth, there are also plenty of places where ECS will get used today on CNAME records\r\n> \r\n> I think ECS-variant CNAMEs should probably have been banned in the ECS spec, and this seems like a good opportunity to start phasing them out. However, if we decide that they should be well-supported, then you're right that we need ECS on the SVCB queries. I've drawn up #309 to show what I think that would look like.\r\n\r\nFWIW CNAME processing is mentioned in RFC 7871 (section 7.2.1). Quote:\r\n   Since some queries can result in multiple RRsets being added to the\r\n   response, there is an unfortunate ambiguity from the original\r\n   specification as to how SCOPE PREFIX-LENGTH would apply to each\r\n   individual RRset.  For example, multiple types in response to an ANY\r\n   metaquery could all have different applicable SCOPE PREFIX-LENGTH\r\n   values, but this protocol only has the ability to signal one.  The\r\n   response SHOULD therefore, include the longest relevant PREFIX-LENGTH\r\n   of any RRset in the answer, which could have the unfortunate side\r\n   effect of redundantly caching some data that could be cached more\r\n   broadly.  For the specific case of a Canonical Name (CNAME) chain,\r\n   the Authoritative Nameserver SHOULD only place the initial CNAME\r\n   record in the Answer section, to have it cached unambiguously and\r\n   appropriately. Most modern Recursive Resolvers restart the query\r\n   with the CNAME, so the remainder of the chain is typically ignored\r\n   anyway.  For message-focused resolvers, rather than RRset-focused\r\n   ones, this will mean caching the entire CNAME chain at the longest\r\n   PREFIX-LENGTH of any RRset in the chain.\r\n\r\nThere is no mention of the scope to use for the CNAME response which would imply a non-zero scope is allowed. It does however recommend splitting the response across CNAME, requested RR if the prefix-length scope is different (especially if the CNAME scope is /0) for more efficient caching. It will be good to have reference to this section and a similar recommendation to split CNAME, SVCB alias, SVCB target RRs with different ECS scopes.\r\n\r\n> \r\n> > Just changing the A/AAAA case won't help when the protocols may need\r\n> > to vary (eg, \"ISP ___ in the US breaks QUIC by randomly dropping UDP\r\n> > and thus we don't want to offer it for clients in their ASN\").\r\n> \r\n> Yuck. You can't rely on ECS, so clients need to handle this anyway. Any network of this kind is horribly broken, so we shouldn't be trying to put in performance optimizations for it.\r\n> \r\n> @rs\r\n> \r\n> > That will requires two round trips from the resolver to the auth\r\n> \r\n> The number of roundtrips actually has nothing to do with whether the resolver is allowed to disable ECS. I made a slight text update that I hope makes the reasoning clearer; you can also look at #309.\r\n> \r\n> > To me the only reason for adding this clause is economical on the resolver side. Having a new popular qtype with ECS cache split can be expensive\r\n> \r\n> Yes, the motivation is cache performance, but the resolver can operate with any cache size it likes, so it's not exactly an \"expense\". Even with an infinite cache size, unnecessary use of ECS harms performance for users, by making cache hits less likely.\r\n\r\n",
              "createdAt": "2021-03-30T21:35:03Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NzI3NTk4",
          "commit": {
            "abbreviatedOid": "57be5d9"
          },
          "author": "puneetsood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T21:41:27Z",
          "updatedAt": "2021-03-30T21:41:28Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Suggested wording to put the ECS RFC text first and the recommendations for auth, recursive after that. Keeping this here instead of in #309 since all the discussion is here.\r\n\r\n```suggestion\r\nSVCB records may contain IP addresses (in ipv*hint SvcParams),\r\nor direct users to a TargetName. In these cases, a recursive\r\nresolver and authoritative server can use ECS [expand] to request and\r\nreceive answers suitable for a particular client IP range.\r\n\r\nAccording to Section 7.3.1 of RFC7871, \"Any records from \\[the\r\nAdditional section\\] MUST NOT be tied to a network\". In addition,\r\nSection 7.2.1 states \"For the specific case of a Canonical Name (CNAME) chain,\r\nthe Authoritative Nameserver SHOULD only place the initial CNAME\r\nrecord in the Answer section, to have it cached unambiguously and\r\nappropriately.\". This is meant to allow caching different RRs at the\r\nappropriate scope prefix-length by a resolver.\r\n\r\nAccordingly, authoritative servers SHOULD not include additional RRs\r\nin a response to an HTTPS query if their prefix-length scope is\r\ndifferent from the first RR in the response (which could be a CNAME or an SVCB record). A recursive resolver SHOULD include the same ECS option in SVCB queries as in A/AAAA queries.\r\n```",
              "createdAt": "2021-03-30T21:41:27Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NjIwODgx",
          "commit": {
            "abbreviatedOid": "57be5d9"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T18:57:39Z",
          "updatedAt": "2021-03-31T18:57:39Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Thanks for the suggestion.  I've incorporated these references in https://github.com/MikeBishop/dns-alt-svc/pull/308/commits/9e0fe746a458fdd2bf7f63d0c357009efcfdb428.",
              "createdAt": "2021-03-31T18:57:39Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NjIxMzkx",
          "commit": {
            "abbreviatedOid": "9e0fe74"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T18:58:15Z",
          "updatedAt": "2021-03-31T18:58:16Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "I've reworded this so that a normative MUST now makes sense.",
              "createdAt": "2021-03-31T18:58:15Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NjM3MTIy",
          "commit": {
            "abbreviatedOid": "9e0fe74"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T19:18:21Z",
          "updatedAt": "2021-03-31T19:18:21Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Here's an alternative interpretation of \"MUST NOT be tied to a network\".  This might allow more use of Additional records, resulting in lower latency.\r\n\r\n@puneetsood FYI\r\n\r\n```suggestion\r\nSOURCE PREFIX-LENGTH zero and SCOPE PREFIX-LENGTH as specified\r\nin the ECS option, and MAY cache them on this basis.  Authoritative\r\nservers MUST omit such records if they are not suitable\r\nfor use by any stub resolvers that set SOURCE PREFIX-LENGTH to zero.\r\n```",
              "createdAt": "2021-03-31T19:18:21Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI5MDU3MjUy",
          "commit": {
            "abbreviatedOid": "9e0fe74"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-06T14:42:02Z",
          "updatedAt": "2021-04-06T14:42:02Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "On reflection, I'm leaning toward this interpretation, because it makes it more likely that we can revise RFC 7871 in the future to make these records ECS-enabled without creating a compatibility problem.",
              "createdAt": "2021-04-06T14:42:02Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI5MDk5OTcy",
          "commit": {
            "abbreviatedOid": "1a0afa0"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-06T15:17:35Z",
          "updatedAt": "2021-04-06T15:17:35Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I've reworked the text since this comment.  It now discusses this topic (line 679).",
              "createdAt": "2021-04-06T15:17:35Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI5NDY1ODkw",
          "commit": {
            "abbreviatedOid": "1a0afa0"
          },
          "author": "puneetsood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-06T22:45:40Z",
          "updatedAt": "2021-04-06T22:45:41Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "https://tools.ietf.org/html/rfc2181#section-5.4.1 recommends not forwarding Additional section records to clients.\r\n\r\n_**Unauthenticated RRs received and cached from the least trustworthy of\r\nthose groupings, that is data from the additional data section, and\r\ndata from the authority section of a non-authoritative answer, should\r\nnot be cached in such a way that they would ever be returned as\r\nanswers to a received query.  They may be returned as additional\r\ninformation where appropriate.  Ignoring this would allow the\r\ntrustworthiness of relatively untrustworthy data to be increased\r\nwithout cause or excuse.**_\r\n\r\nTherefore the recommendation:\r\n_**Accordingly,\r\nresolvers SHOULD treat any records in the Additional section as having\r\nSOURCE PREFIX-LENGTH zero and SCOPE PREFIX-LENGTH as specified\r\nin the ECS option, and MAY cache them on this basis.**_\r\n\r\nis unlikely to have an impact in the real world - popular DNS resolvers/implementations (e.g. Quad{189}, OpenDNS) do not propagate the ECS information to their clients (stubs mentioned here). This can be seen in the handling of MX records.\r\n\r\n$ dig @ns1.google.com -t MX google.com +nostats\r\n<snip>\r\n;; ANSWER SECTION:\r\ngoogle.com.\t\t600\tIN\tMX\t20 alt1.aspmx.l.google.com.\r\ngoogle.com.\t\t600\tIN\tMX\t30 alt2.aspmx.l.google.com.\r\ngoogle.com.\t\t600\tIN\tMX\t50 alt4.aspmx.l.google.com.\r\ngoogle.com.\t\t600\tIN\tMX\t10 aspmx.l.google.com.\r\ngoogle.com.\t\t600\tIN\tMX\t40 alt3.aspmx.l.google.com.\r\n\r\n;; ADDITIONAL SECTION:\r\nalt1.aspmx.l.google.com. 293\tIN\tA\t173.194.216.26\r\nalt1.aspmx.l.google.com. 293\tIN\tAAAA\t2607:f8b0:400c:c12::1a\r\nalt2.aspmx.l.google.com. 293\tIN\tA\t64.233.186.26\r\nalt2.aspmx.l.google.com. 293\tIN\tAAAA\t2800:3f0:4003:c00::1a\r\nalt4.aspmx.l.google.com. 293\tIN\tA\t172.253.120.26\r\nalt4.aspmx.l.google.com. 293\tIN\tAAAA\t2a00:1450:400c:c01::1a\r\naspmx.l.google.com.\t293\tIN\tA\t142.250.123.26\r\naspmx.l.google.com.\t293\tIN\tAAAA\t2607:f8b0:4023:1402::1a\r\nalt3.aspmx.l.google.com. 293\tIN\tA\t209.85.203.26\r\nalt3.aspmx.l.google.com. 293\tIN\tAAAA\t2a00:1450:400b:c03::1a\r\n\r\n$ dig @9.9.9.9 -t MX google.com +nostats\r\n<snip>\r\n;; ANSWER SECTION:\r\ngoogle.com.\t\t600\tIN\tMX\t10 aspmx.l.google.com.\r\ngoogle.com.\t\t600\tIN\tMX\t20 alt1.aspmx.l.google.com.\r\ngoogle.com.\t\t600\tIN\tMX\t40 alt3.aspmx.l.google.com.\r\ngoogle.com.\t\t600\tIN\tMX\t50 alt4.aspmx.l.google.com.\r\ngoogle.com.\t\t600\tIN\tMX\t30 alt2.aspmx.l.google.com.\r\n ",
              "createdAt": "2021-04-06T22:45:41Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI5NTE5NTgz",
          "commit": {
            "abbreviatedOid": "1a0afa0"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-07T01:11:58Z",
          "updatedAt": "2021-04-07T01:11:58Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Thanks for investigating that.  I didn't know about RFC 2181.\r\n\r\nI think the text you quoted is (surprisingly?) in line with this draft.\r\n\r\n> **Unauthenticated** RRs ... from the additional data section ... should\r\n> not be cached in such a way that they would ever be returned as\r\n> answers\r\n\r\nSVCB Section 4.1:\r\n> If the zone is signed, the server SHOULD also include positive or negative DNSSEC responses for these records in the Additional section.\r\n\r\nSo these Additional records could actually end up cached and used for general purposes.\r\n\r\nRFC 2181\r\n> They may be returned as additional information where appropriate.\r\n\r\nSVCB Section 4.2:\r\n> ... adding all useful RRs from the response to the Additional section\r\n\r\nSo even without authentication, we're using these records as recommended in RFC 2181.\r\n\r\nThanks for showing an easy way to check the real world behavior.\r\n> ... popular DNS resolvers/implementations (e.g. Quad{189}, OpenDNS) do not propagate the ECS information to their clients\r\n\r\nI think they do not propagate any Additional data to their clients.  That seems like a compliant, but perhaps not highly optimized behavior.  A highly optimized resolver could comply with RFC 2181 by maintaining a separate cache for records returned in the Additional section, to be used only when populating the Additional section of responses (when appropriate).  If that cache assumes SCOPE /0, only global records can go in the Additional section, whereas if it assumes SOURCE /0, authoritative servers can safely return ECS-tailored Additional records.\r\n\r\nAs a practical matter this may be moot in current implementations, but as a matter of requirements I think the text here still makes sense.",
              "createdAt": "2021-04-07T01:11:58Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMzNjExNzk2",
          "commit": {
            "abbreviatedOid": "1a0afa0"
          },
          "author": "puneetsood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-12T14:32:46Z",
          "updatedAt": "2021-04-12T14:32:46Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "To provide context to a reader, will be be good to have a reference to https://tools.ietf.org/html/rfc2181#section-5.4.1 after the phrase \"and MAY cache them on this basis\".",
              "createdAt": "2021-04-12T14:32:46Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMzNjEyMDky",
          "commit": {
            "abbreviatedOid": "1a0afa0"
          },
          "author": "puneetsood",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-12T14:33:00Z",
          "updatedAt": "2021-04-12T14:33:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMzNjYxNDIy",
          "commit": {
            "abbreviatedOid": "cff2ee0"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-12T15:14:08Z",
          "updatedAt": "2021-04-12T15:14:08Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "OK.  The caching question is mostly independent of ECS, so I moved it to the preceding section and added the full quote from RFC 2181.",
              "createdAt": "2021-04-12T15:14:08Z",
              "updatedAt": "2021-04-16T15:47:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3MjkxMTUy",
          "commit": {
            "abbreviatedOid": "cff2ee0"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-16T02:49:09Z",
          "updatedAt": "2021-04-16T02:49:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3ODQ5NDQw",
          "commit": {
            "abbreviatedOid": "2982b3b"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-16T15:48:20Z",
          "updatedAt": "2021-04-16T15:48:21Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "@enygren @MikeBishop I added this line to scope the normative requirement more explicitly.",
              "createdAt": "2021-04-16T15:48:21Z",
              "updatedAt": "2021-04-16T15:48:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 309,
      "id": "MDExOlB1bGxSZXF1ZXN0NjAyMjkyOTUz",
      "title": "Alternative ECS integration text",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/309",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is an alternative to #308.  It offer lower performance in certain\r\ncases but is simpler to understand.",
      "createdAt": "2021-03-28T19:09:23Z",
      "updatedAt": "2021-03-31T17:02:30Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "bemasc-ecs",
      "baseRefOid": "57be5d9826c4fa50b58a6e91463a5d17fc4a9036",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-ecs2",
      "headRefOid": "6d62de25f43023444ac97d5c0f7eea34e627fdef",
      "closedAt": "2021-03-31T17:02:26Z",
      "mergedAt": "2021-03-31T17:02:26Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "3fede4bcaaaff3a77864bfabdc4db7e01c3355a8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNzc0OTQ2",
          "commit": {
            "abbreviatedOid": "28f1ade"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-28T19:22:31Z",
          "updatedAt": "2021-03-28T19:22:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 311,
      "id": "MDExOlB1bGxSZXF1ZXN0NjEwMTMzNzMx",
      "title": "Add an example of HTTPS with a non-default port",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/311",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Suggested by @sftcd",
      "createdAt": "2021-04-06T20:00:09Z",
      "updatedAt": "2021-04-16T15:33:24Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "1b9fb2e671d04766595c81a5198e13472491c06c",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-prefix",
      "headRefOid": "45efe9e6bb514be956221a96519677f70afd437d",
      "closedAt": "2021-04-16T15:33:21Z",
      "mergedAt": "2021-04-16T15:33:20Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "f8330f28cef63b474c7681040e12aa6ee1108bed"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI5Mzk1OTU4",
          "commit": {
            "abbreviatedOid": "420b8b6"
          },
          "author": "Habbie",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-06T20:48:08Z",
          "updatedAt": "2021-04-06T20:48:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3MjkxNTYw",
          "commit": {
            "abbreviatedOid": "420b8b6"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-16T02:50:37Z",
          "updatedAt": "2021-04-16T02:50:38Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nto indicate that https://simple.example (and http://simple.example)\r\nuse HTTPS, and supports QUIC\r\n```",
              "createdAt": "2021-04-16T02:50:37Z",
              "updatedAt": "2021-04-16T15:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3MjkxOTEy",
          "commit": {
            "abbreviatedOid": "420b8b6"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-16T02:51:50Z",
          "updatedAt": "2021-04-16T02:51:51Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Corner-case that I'm not sure we cover.  What happens to http://simple.example:8443 in this case?  Does it also get forced to HTTPS?",
              "createdAt": "2021-04-16T02:51:51Z",
              "updatedAt": "2021-04-16T15:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3NzI2NjU1",
          "commit": {
            "abbreviatedOid": "420b8b6"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-16T13:56:58Z",
          "updatedAt": "2021-04-16T13:57:52Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I added a sentence about this at the end of the example.",
              "createdAt": "2021-04-16T13:56:58Z",
              "updatedAt": "2021-04-16T15:33:15Z"
            },
            {
              "originalPosition": 25,
              "body": "Yes, it does.  I added this to the last sentence of this example.",
              "createdAt": "2021-04-16T13:57:47Z",
              "updatedAt": "2021-04-16T15:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3Nzg3NzA5",
          "commit": {
            "abbreviatedOid": "e4498ff"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-16T14:55:21Z",
          "updatedAt": "2021-04-16T14:55:22Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\nThese records also respectively tell clients to replace the scheme with \"https\" when\r\n```",
              "createdAt": "2021-04-16T14:55:21Z",
              "updatedAt": "2021-04-16T15:33:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 312,
      "id": "MDExOlB1bGxSZXF1ZXN0NjEwNTIyMTU0",
      "title": "Test vectors with failure cases",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/312",
      "state": "MERGED",
      "author": "wtoorop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This includes Pieter Lexis' test vectors and has some additional failure cases added.",
      "createdAt": "2021-04-07T09:55:10Z",
      "updatedAt": "2021-04-16T15:02:20Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "1b9fb2e671d04766595c81a5198e13472491c06c",
      "headRepository": "NLnetLabs/dns-alt-svc",
      "headRefName": "test-vectors-with-failure-cases",
      "headRefOid": "51a6bcc67ddc0dafbf163bc99c87d5a8d9d5e2bd",
      "closedAt": "2021-04-16T14:59:17Z",
      "mergedAt": "2021-04-16T14:59:17Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "4a6a21fc3a8e86ab0f76980b209fa08ff1662a6c"
      },
      "comments": [
        {
          "author": "wtoorop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "More commits with more failure cases (from @TCY16) will follow shortly...",
          "createdAt": "2021-04-07T09:56:01Z",
          "updatedAt": "2021-04-07T09:56:01Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Do we have an example of a published RFC with such a detailed catalog of invalid test vectors?  If not, perhaps it's inappropriate for a standards document.  After all, we are not trying to ship a complete test suite.",
          "createdAt": "2021-04-08T00:11:18Z",
          "updatedAt": "2021-04-08T00:11:18Z"
        },
        {
          "author": "wtoorop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @bemasc , I can't think of a RFC from head, but I know that two ZONEMD implementations completely missed that they should not try to validate, and *fail* verification when there are two ZONEMD RR's with the same algorithm in a zone. A test-vector for the failure case would probably have prevented that, as implementations tend to copy and use those in their test suits. \r\n\r\nWhat would be a good reason to not include them?\r\nDo you want me to ask the workgroup again about whether they think it should be included or not?\r\n\r\nAlso, @pieterlexis' test-vectors already payed off! Because both the ldns implementation and the Net::DNS implementation missed that alpn values have to be escaped and unescaped twice!",
          "createdAt": "2021-04-08T08:01:28Z",
          "updatedAt": "2021-04-08T08:03:29Z"
        },
        {
          "author": "TCY16",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @bemasc,\r\n\r\nI do get what you\u2019re saying about the complete test suite and agree that some are slightly trivial, though I think there is still added value of including at least some of the tests. \r\nI started this list mainly for the NSD test suite, but as both you and @marka63 pointed out, there were some mistakes/improvements. By adding a subset of these tests me and @wtoorop hope that other implementers are less prone to incorrect implementations.\r\n\r\nDo you disagree?",
          "createdAt": "2021-04-08T10:48:28Z",
          "updatedAt": "2021-04-08T12:06:36Z"
        },
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @TCY16 - we should more inclusive with the examples.  They seem to trivial to us, but we are not the people whom will reading this and attempting to updating their DNS zone data.   Trivial examples are the turtles folks will use to reach the next set of turtles. \r\n\r\n(speaking only for myself)",
          "createdAt": "2021-04-08T11:15:49Z",
          "updatedAt": "2021-04-08T11:15:49Z"
        },
        {
          "author": "Habbie",
          "authorAssociation": "NONE",
          "body": "> Do we have an example of a published RFC with such a detailed catalog of invalid test vectors? If not, perhaps it's inappropriate for a standards document. After all, we are not trying to ship a complete test suite.\r\n\r\nThe few positive examples in CSYNC really helped me in implementing the type, and I wouldn't have minded some 'negative' examples in there too.\r\n\r\nIn general, I feel RFCs generally have too few test vectors (often zero), not too many.\r\n\r\nI think shipping a complete test suite would be an excellent way to lead by example!",
          "createdAt": "2021-04-09T19:58:37Z",
          "updatedAt": "2021-04-09T19:58:37Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Opened issue #315  to test the test vectors.  It would be great if people could confirm there if they've tested the test vectors.",
          "createdAt": "2021-04-16T15:02:20Z",
          "updatedAt": "2021-04-16T15:02:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMwMTAwNjU5",
          "commit": {
            "abbreviatedOid": "827d625"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-07T14:44:38Z",
          "updatedAt": "2021-04-07T14:44:38Z",
          "comments": [
            {
              "originalPosition": 241,
              "body": "No, this record is perfectly valid.  \"automatically mandatory\" means \"if these keys are present, clients must act as if they were in the `mandatory=...` list\".",
              "createdAt": "2021-04-07T14:44:38Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMwMTAxNTA5",
          "commit": {
            "abbreviatedOid": "827d625"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-07T14:45:19Z",
          "updatedAt": "2021-04-07T14:45:20Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "As your text notes, this is a \"should not\", so the record is not invalid.",
              "createdAt": "2021-04-07T14:45:20Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMwMTI0NzYz",
          "commit": {
            "abbreviatedOid": "4dfe4db"
          },
          "author": "TCY16",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-07T15:04:12Z",
          "updatedAt": "2021-04-07T15:04:13Z",
          "comments": [
            {
              "originalPosition": 241,
              "body": "Removed",
              "createdAt": "2021-04-07T15:04:12Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMwMTI1MTI5",
          "commit": {
            "abbreviatedOid": "4dfe4db"
          },
          "author": "TCY16",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-07T15:04:32Z",
          "updatedAt": "2021-04-07T15:04:32Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "and removed, thanks for the feedback Ben!",
              "createdAt": "2021-04-07T15:04:32Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMwNDQ5MjM4",
          "commit": {
            "abbreviatedOid": "4dfe4db"
          },
          "author": "wtoorop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-07T18:56:36Z",
          "updatedAt": "2021-04-07T18:59:58Z",
          "comments": [
            {
              "originalPosition": 206,
              "body": "```suggestion\r\nThis example has multiple instances of the same\r\n```",
              "createdAt": "2021-04-07T18:56:36Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            },
            {
              "originalPosition": 219,
              "body": "```suggestion\r\nThe \"no-default-alpn\" SvcParamKey value MUST be empty ({{alpn-key}}).\r\n```",
              "createdAt": "2021-04-07T18:57:49Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            },
            {
              "originalPosition": 227,
              "body": "```suggestion\r\nThe \"mandatory\" SvcParamKey MUST not be included in mandatory\r\n```",
              "createdAt": "2021-04-07T18:58:44Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMwNjY2MjM5",
          "commit": {
            "abbreviatedOid": "4dfe4db"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-07T21:53:09Z",
          "updatedAt": "2021-04-07T21:53:10Z",
          "comments": [
            {
              "originalPosition": 216,
              "body": "These should be done in individual records rather than 1 record to ensure proper error detection.",
              "createdAt": "2021-04-07T21:53:09Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMwNjY4MDQy",
          "commit": {
            "abbreviatedOid": "4dfe4db"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-07T21:54:28Z",
          "updatedAt": "2021-04-07T21:54:29Z",
          "comments": [
            {
              "originalPosition": 216,
              "body": "Add keyXXX forms as well.",
              "createdAt": "2021-04-07T21:54:28Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMwNjczMDE3",
          "commit": {
            "abbreviatedOid": "4dfe4db"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-07T21:57:45Z",
          "updatedAt": "2021-04-07T21:57:45Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "This may need to done in multi-line format to allow it to fit nicely into .txt format.",
              "createdAt": "2021-04-07T21:57:45Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMwNjc0NzQ0",
          "commit": {
            "abbreviatedOid": "4dfe4db"
          },
          "author": "marka63",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-07T21:58:44Z",
          "updatedAt": "2021-04-07T21:58:44Z",
          "comments": [
            {
              "originalPosition": 216,
              "body": "add mandatory to the list.",
              "createdAt": "2021-04-07T21:58:44Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMxMjQ1Mzg4",
          "commit": {
            "abbreviatedOid": "de2b769"
          },
          "author": "TCY16",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-08T10:46:00Z",
          "updatedAt": "2021-04-08T10:46:00Z",
          "comments": [
            {
              "originalPosition": 216,
              "body": "resolved",
              "createdAt": "2021-04-08T10:46:00Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMxMjQ1NDI0",
          "commit": {
            "abbreviatedOid": "de2b769"
          },
          "author": "TCY16",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-08T10:46:03Z",
          "updatedAt": "2021-04-08T10:46:03Z",
          "comments": [
            {
              "originalPosition": 216,
              "body": "resolved",
              "createdAt": "2021-04-08T10:46:03Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMxMjQ1NTI4",
          "commit": {
            "abbreviatedOid": "de2b769"
          },
          "author": "TCY16",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-08T10:46:10Z",
          "updatedAt": "2021-04-08T10:46:11Z",
          "comments": [
            {
              "originalPosition": 216,
              "body": "resolved",
              "createdAt": "2021-04-08T10:46:10Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMxMjQ2MjIz",
          "commit": {
            "abbreviatedOid": "de2b769"
          },
          "author": "TCY16",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-08T10:46:59Z",
          "updatedAt": "2021-04-08T10:47:00Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "This _should_ fit the .txt file as it is lined out to be on the exact maximum",
              "createdAt": "2021-04-08T10:46:59Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMxNDI4NDE2",
          "commit": {
            "abbreviatedOid": "de2b769"
          },
          "author": "wtoorop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-08T13:57:18Z",
          "updatedAt": "2021-04-08T13:57:18Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "```suggestion\r\n    example.com.   SVCB   1 foo.example.com. key123\r\n```",
              "createdAt": "2021-04-08T13:57:18Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMxNTAxODU3",
          "commit": {
            "abbreviatedOid": "56fa322"
          },
          "author": "pieterlexis",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-08T14:56:52Z",
          "updatedAt": "2021-04-08T14:56:53Z",
          "comments": [
            {
              "originalPosition": 215,
              "body": "Another failure case would be:\r\n\r\n```\r\n     example.com.   SVCB   1 foo.example.com. mandatory=\r\n```",
              "createdAt": "2021-04-08T14:56:52Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMxNTE5NTEz",
          "commit": {
            "abbreviatedOid": "56fa322"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "OK, it sounds like there is a lot of interest in including invalid RDATA.",
          "createdAt": "2021-04-08T15:11:29Z",
          "updatedAt": "2021-04-08T15:16:24Z",
          "comments": [
            {
              "originalPosition": 219,
              "body": "This is a tricky one.  The param indicates a valid SVCB `echconfig` parameter whose value is \"\" (which is what you get when you base64-decode \"\").\r\n\r\nOf course, \"\" is currently not a valid ECHConfigList, and is unlikely to be, but the ECH specification is not final.  In any event, I don't think there's an obligation for zone file parsers to check whether the ECHConfigList is valid, which may be difficult if they're not linked to an ECH-capable TLS library.",
              "createdAt": "2021-04-08T15:11:29Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            },
            {
              "originalPosition": 221,
              "body": "This is definitely allowed.  `key123` could someday be registered as a key that uses an empty value.  Until it's registered, zone files can't apply any limits.",
              "createdAt": "2021-04-08T15:12:20Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMxNTMwMjM4",
          "commit": {
            "abbreviatedOid": "56fa322"
          },
          "author": "pieterlexis",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-08T15:20:39Z",
          "updatedAt": "2021-04-08T15:20:40Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "I know an earlier draft mentioned that empty generic keys were not allowed and only no-default-alpn was defined as having no value? I can't seem to find this kind of wording in the 04 draft.",
              "createdAt": "2021-04-08T15:20:40Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMxNTM3OTAw",
          "commit": {
            "abbreviatedOid": "56fa322"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-08T15:27:02Z",
          "updatedAt": "2021-04-08T15:27:02Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "I don't recall a limit like that.  Perhaps an early draft implied that this should be spelled `key123=\"\"`, but there is no such requirement now.",
              "createdAt": "2021-04-08T15:27:02Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMxNzgzOTI0",
          "commit": {
            "abbreviatedOid": "56fa322"
          },
          "author": "wtoorop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Suggestions based on review comments from @bemasc ",
          "createdAt": "2021-04-08T19:59:47Z",
          "updatedAt": "2021-04-08T20:01:50Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "```suggestion\r\n```\r\nkeyXXX SvcParam do not have to have values",
              "createdAt": "2021-04-08T19:59:47Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            },
            {
              "originalPosition": 219,
              "body": "```suggestion\r\n```\r\nAllow for empty echconfig lists. Because ECH spec is not final.",
              "createdAt": "2021-04-08T20:01:19Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMxNzg4MTEz",
          "commit": {
            "abbreviatedOid": "6d57b73"
          },
          "author": "wtoorop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-08T20:05:31Z",
          "updatedAt": "2021-04-08T20:05:31Z",
          "comments": [
            {
              "originalPosition": 219,
              "body": "Removed that one.",
              "createdAt": "2021-04-08T20:05:31Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMxNzg4MzU5",
          "commit": {
            "abbreviatedOid": "6d57b73"
          },
          "author": "wtoorop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-08T20:05:51Z",
          "updatedAt": "2021-04-08T20:05:52Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "Removed this line too.",
              "createdAt": "2021-04-08T20:05:52Z",
              "updatedAt": "2021-04-09T13:19:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMxNzk3NjYw",
          "commit": {
            "abbreviatedOid": "6d57b73"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Waiting for coauthor approval.",
          "createdAt": "2021-04-08T20:18:45Z",
          "updatedAt": "2021-04-08T20:18:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 313,
      "id": "MDExOlB1bGxSZXF1ZXN0NjExNjE2MjIz",
      "title": "Relax requirements for resolvers and SvcParams",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/313",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It's probably better for everyone if resolvers don't inspect the\r\nSvcParams, but it's not really a requirement, and it has been a\r\ncontroversial point due to implementation details and RDATA-based\r\nfiltering.",
      "createdAt": "2021-04-08T14:38:15Z",
      "updatedAt": "2021-04-16T15:38:36Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "1b9fb2e671d04766595c81a5198e13472491c06c",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-should-not-alter",
      "headRefOid": "6c46e0f5c3720813ebda754b0002ec1e6419d8f2",
      "closedAt": "2021-04-16T15:38:32Z",
      "mergedAt": "2021-04-16T15:38:32Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "807fbd35fa22de2a9b2f9000d65a19489f6c8a4e"
      },
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems like entering into risky territory.  A big part of the current SHOULD NOT text is that there is much more ossification risk if recursive resolvers start looking at parameters.  It's critical that we be able to add new parameters without recursive resolvers looking at them.  (SHOULD NOT does not prevent them from doing so if they have a good reason to do so.)  ",
          "createdAt": "2021-04-16T02:55:12Z",
          "updatedAt": "2021-04-16T02:55:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMxNDg4NjIx",
          "commit": {
            "abbreviatedOid": "aa18547"
          },
          "author": "vcunat",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-08T14:46:09Z",
          "updatedAt": "2021-04-08T14:46:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMyNzQzNjY2",
          "commit": {
            "abbreviatedOid": "aa18547"
          },
          "author": "Habbie",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-09T19:54:55Z",
          "updatedAt": "2021-04-09T19:54:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3ODA2NzY5",
          "commit": {
            "abbreviatedOid": "aa18547"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-16T15:14:22Z",
          "updatedAt": "2021-04-16T15:14:23Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nRecursive resolvers MUST be able to convey SVCB records with unrecognized\r\nSvcParamKeys or malformed SvcParamValues.  Resolvers MAY treat the entire\r\nSvcParams portion of the record as opaque.  No part of this specification requires\r\nrecursive resolvers to alter their behavior based on its contents, even if the contents\r\nare invalid.\r\n```",
              "createdAt": "2021-04-16T15:14:23Z",
              "updatedAt": "2021-04-16T15:34:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 314,
      "id": "MDExOlB1bGxSZXF1ZXN0NjEyNjA0NDQ2",
      "title": "Relax recommendation to have a default set",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/314",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change trades normative language for more explanation about how to\r\nchoose an appropriate default set for a scheme.",
      "createdAt": "2021-04-09T17:07:49Z",
      "updatedAt": "2021-04-16T14:44:31Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "1b9fb2e671d04766595c81a5198e13472491c06c",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-no-alpn-must",
      "headRefOid": "28f1d269d057a6cb7a775b4ee44c6ec5bf0c55d3",
      "closedAt": "2021-04-16T14:44:28Z",
      "mergedAt": "2021-04-16T14:44:28Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "d06401f55d77d14721505a88c55c516bf51122a4"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "See https://github.com/bemasc/svcb-dns/pull/2",
          "createdAt": "2021-04-09T17:25:12Z",
          "updatedAt": "2021-04-09T17:25:12Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that this is guidance for specification-writers this makes sense.  ",
          "createdAt": "2021-04-16T02:56:43Z",
          "updatedAt": "2021-04-16T02:56:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMyNzAwMjE3",
          "commit": {
            "abbreviatedOid": "28f1d26"
          },
          "author": "Habbie",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-09T18:48:00Z",
          "updatedAt": "2021-04-09T18:48:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 316,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE2OTQyMjE3",
      "title": "Move ECH codepoint",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/316",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This simplifies the compatibility questions related to changing the name\r\nof \"echconfig\" to \"ech\".",
      "createdAt": "2021-04-16T15:57:12Z",
      "updatedAt": "2021-04-20T20:25:17Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "bemasc-ech",
      "baseRefOid": "4f969692e5216dc88431bc028cda7b5355810312",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-ech7",
      "headRefOid": "5a8fb98b23e577c89098264cb84bb25f1dc46016",
      "closedAt": "2021-04-20T20:25:17Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "It looks like we don't have consensus for this change.",
          "createdAt": "2021-04-20T20:25:17Z",
          "updatedAt": "2021-04-20T20:25:17Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 317,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE5Njc1NjA4",
      "title": "Release notes for draft-05",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/317",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-04-20T20:49:10Z",
      "updatedAt": "2021-04-21T13:35:42Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "3f39d8ed16e598dc5f3ed8eced5503f8961f669c",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-release-notes",
      "headRefOid": "4a8b8cecdf25e3d7f152feb4aca643e78467eb93",
      "closedAt": "2021-04-21T13:35:42Z",
      "mergedAt": "2021-04-21T13:35:41Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "361df8edbe9c7ca6864b7b2ab1fd316c0104f213"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "(Please ignore the CI failure, which appears to be due to a bug in the `i-d-template` library.)",
          "createdAt": "2021-04-20T21:21:31Z",
          "updatedAt": "2021-04-20T21:21:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwNDgyMDk0",
          "commit": {
            "abbreviatedOid": "4a8b8ce"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-20T22:46:44Z",
          "updatedAt": "2021-04-20T22:46:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 318,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIwMjUzNDg0",
      "title": "Expand acknowledgements",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/318",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-04-21T14:08:51Z",
      "updatedAt": "2021-06-08T16:06:15Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "361df8edbe9c7ca6864b7b2ab1fd316c0104f213",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-ack",
      "headRefOid": "870afae0bb9954a4fe717df54a790c3d79fdc4b7",
      "closedAt": "2021-06-08T16:06:10Z",
      "mergedAt": "2021-06-08T16:06:10Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "422f7e930a938910315a296ea6f31455657267cb"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@enygren @MikeBishop Please note anyone else who we ought to include in this list.\r\n\r\n@pieterlexis @wtoorop @puneetsood Please let us know if you would prefer not to be included.",
          "createdAt": "2021-04-21T14:10:59Z",
          "updatedAt": "2021-04-21T14:10:59Z"
        },
        {
          "author": "wtoorop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks! Appreciated.\r\nTom Carpay (@TCY16 ) should be listed there too.\r\nTom did the commits with the failure-cases.",
          "createdAt": "2021-04-21T14:36:35Z",
          "updatedAt": "2021-04-21T14:36:35Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Others?\r\n@rs ( Olivier Poitrey )\r\n@mmuhaime ( Mashooq Muhaimen )\r\n@jdreed ( Jonathan Reed )\r\n\r\nNot a comprehensive check, but some who I noticed as missing but who have provided valuable feedback on recent PRs.\r\n",
          "createdAt": "2021-04-21T14:49:56Z",
          "updatedAt": "2021-04-21T14:49:56Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, added.",
          "createdAt": "2021-04-21T15:04:07Z",
          "updatedAt": "2021-04-21T15:04:07Z"
        },
        {
          "author": "pieterlexis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @pieterlexis [...] Please let us know if you would prefer not to be included.\r\n\r\nI'm ok with being included.",
          "createdAt": "2021-04-22T07:59:53Z",
          "updatedAt": "2021-04-22T07:59:53Z"
        },
        {
          "author": "rs",
          "authorAssociation": "NONE",
          "body": "Ok too",
          "createdAt": "2021-04-22T09:58:20Z",
          "updatedAt": "2021-04-22T09:58:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxMTg1MzEw",
          "commit": {
            "abbreviatedOid": "5ccdaef"
          },
          "author": "wtoorop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-21T14:45:47Z",
          "updatedAt": "2021-04-21T14:45:47Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nTom Carpay, and many others for their feedback\r\n```",
              "createdAt": "2021-04-21T14:45:47Z",
              "updatedAt": "2021-04-21T15:03:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 319,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIwNDg0MTY0",
      "title": "Adjust requirements for invalid SvcParamValues",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/319",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "enygren"
      ],
      "labels": [],
      "body": "This change relaxes the requirement not to validate SvcParamValues, while encouraging resolvers to distinguish lightweight validation from deep parsing of complex value types.",
      "createdAt": "2021-04-21T19:46:24Z",
      "updatedAt": "2021-06-01T15:45:28Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "361df8edbe9c7ca6864b7b2ab1fd316c0104f213",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-invalid",
      "headRefOid": "049aadeacaa458fb28e09f7e3f4c87ab2cd4aac9",
      "closedAt": "2021-06-01T15:45:25Z",
      "mergedAt": "2021-06-01T15:45:25Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "402475aa3f5de0f6ed24bf1d016638fbfd0d0daa"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@enygren I've reworded this based on feedback from @paulehoffman.  Please take another look.",
          "createdAt": "2021-04-28T22:18:40Z",
          "updatedAt": "2021-04-28T22:18:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNTA2ODI5",
          "commit": {
            "abbreviatedOid": "0507862"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-21T20:44:36Z",
          "updatedAt": "2021-04-21T20:44:37Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nare invalid.  To ensure compatibility with complex and/or future SvcParam specifications,\r\n```",
              "createdAt": "2021-04-21T20:44:36Z",
              "updatedAt": "2021-04-27T20:29:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNTEwODE2",
          "commit": {
            "abbreviatedOid": "0507862"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-21T20:50:04Z",
          "updatedAt": "2021-04-21T20:50:04Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Why isn't this covered by the preceding requirement to pass unrecognized keys?",
              "createdAt": "2021-04-21T20:50:04Z",
              "updatedAt": "2021-04-27T20:29:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNTI3MjY1",
          "commit": {
            "abbreviatedOid": "0507862"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-21T21:13:28Z",
          "updatedAt": "2021-04-21T21:13:28Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I guess it mostly is, but if we're adding justification does it hurt to remind people over and over?",
              "createdAt": "2021-04-21T21:13:28Z",
              "updatedAt": "2021-04-27T20:29:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNTQ2NDQ5",
          "commit": {
            "abbreviatedOid": "0507862"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-21T21:22:35Z",
          "updatedAt": "2021-04-21T21:22:36Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I don't think it's relevant to this sentence, unless you're imagining changes that formally alter the range of allowed values for an existing key.",
              "createdAt": "2021-04-21T21:22:36Z",
              "updatedAt": "2021-04-27T20:29:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNTUzMjM1",
          "commit": {
            "abbreviatedOid": "0507862"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-21T21:25:37Z",
          "updatedAt": "2021-04-21T21:25:37Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "An example might be future alpn values.  Perhaps there's a better way to work?",
              "createdAt": "2021-04-21T21:25:37Z",
              "updatedAt": "2021-04-27T20:29:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNTYwODY3",
          "commit": {
            "abbreviatedOid": "0507862"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-21T21:29:02Z",
          "updatedAt": "2021-04-21T21:29:03Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "\"evolving\"?",
              "createdAt": "2021-04-21T21:29:03Z",
              "updatedAt": "2021-04-27T20:29:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQyNTcyNzUw",
          "commit": {
            "abbreviatedOid": "0507862"
          },
          "author": "bwelling",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-22T19:04:12Z",
          "updatedAt": "2021-04-22T19:04:12Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This spec identifies ALPN IDs as \"a sequence of 1-255 octets\", and in no way implies that anyone should restrict validation to currently defined identifiers.  If some future ALPN ID is more than 255 octets, there are larger problems, in that the existing parameter format wouldn't be able to encode them.",
              "createdAt": "2021-04-22T19:04:12Z",
              "updatedAt": "2021-04-27T20:29:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQyNjQ1MDU5",
          "commit": {
            "abbreviatedOid": "0507862"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-22T20:36:40Z",
          "updatedAt": "2021-04-22T20:36:41Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "(TLS uses a 1-byte length prefix for ALPN, so it's limited to 255 octets there too.)",
              "createdAt": "2021-04-22T20:36:41Z",
              "updatedAt": "2021-04-27T20:29:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYwMzg1MzQy",
          "commit": {
            "abbreviatedOid": "03effb0"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-15T19:59:48Z",
          "updatedAt": "2021-05-15T19:59:49Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "We should use something more descriptive/specific here.  \r\nThis wording is confusing.  (The term \"sanity checks\"\r\nis also one that should avoid using from an inclusive\r\nlanguage perspective, if better and more descriptive terms\r\nare available.)\r\n\r\nPerhaps:\r\n\r\n```suggestion\r\nSvcParamKeys and reject records containing values \r\nwhich are invalid according to the SvsParam specification.\r\nFor complex value types whose interpretation might differ \r\nbetween implementations or have additional future\r\nallowed values added (e.g. URIs or \"alpn\"), resolvers \r\nSHOULD limit validation to specified constraints.\r\n```",
              "createdAt": "2021-05-15T19:59:48Z",
              "updatedAt": "2021-05-15T19:59:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjczMjQwMzk0",
          "commit": {
            "abbreviatedOid": "a3c1c2b"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Good other than typo",
          "createdAt": "2021-06-01T15:43:36Z",
          "updatedAt": "2021-06-01T15:43:53Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nwhich are invalid according to the SvcParam specification.\r\n```",
              "createdAt": "2021-06-01T15:43:36Z",
              "updatedAt": "2021-06-01T15:43:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 320,
      "id": "MDExOlB1bGxSZXF1ZXN0NjI3MTY2MTQ2",
      "title": "Use the correct prefix for v4 mapped v6",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/320",
      "state": "MERGED",
      "author": "pieterlexis",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "RFC 3513 section 2.5.5 tells us IPv4-mapped IPv6 lives in the ::ffff\r\nprefix.",
      "createdAt": "2021-04-30T09:34:57Z",
      "updatedAt": "2021-05-02T23:23:50Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "361df8edbe9c7ca6864b7b2ab1fd316c0104f213",
      "headRepository": "pieterlexis/dns-alt-svc",
      "headRefName": "ipv6-mapped-prefix",
      "headRefOid": "ac534acb831881feb2e7d72d7a98769b8452f27b",
      "closedAt": "2021-04-30T17:38:10Z",
      "mergedAt": "2021-04-30T17:38:10Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "b468190fd88496621189c6fc28150ad2fc1b71c8"
      },
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "What is the use-case for having a v4 mapped v6 address in a ipv6hint?  This seems like an invalid use-case and something we should prohibit?  Using v4 mapped v6 addresses in AAAA records used to be a way to break sites and is usually considered broken.",
          "createdAt": "2021-04-30T21:12:28Z",
          "updatedAt": "2021-04-30T21:12:28Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems like using a v4-mapped address in ipv6hint would break the site if served on the public internet, but could semi-plausibly be permissible in a closed network environment.\r\n\r\nThis is theoretically separate from the question of whether the syntax is allowed.\r\n\r\nI'm happy to revert this change if you think it's less confusing to use the documentation prefix in this example.  We would also need to change the text not to say \"IPv4-mapped\", since it would merely (weirdly) be using the \"decimal notation\" syntax for a generic IPv6 address.",
          "createdAt": "2021-04-30T23:31:03Z",
          "updatedAt": "2021-04-30T23:31:03Z"
        },
        {
          "author": "pieterlexis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do note that converting the documentation format mapped addresses `2001:db8:ffff:[..]:192.0.2.1` to wire format and calling `inet_ntop` will not yield the mapped address but a 'true' v6 address in presentation format.",
          "createdAt": "2021-05-01T12:03:10Z",
          "updatedAt": "2021-05-01T12:03:10Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ5NDQxNDkw",
          "commit": {
            "abbreviatedOid": "ac534ac"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-30T17:38:05Z",
          "updatedAt": "2021-04-30T17:38:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 321,
      "id": "MDExOlB1bGxSZXF1ZXN0NjI3MTgzNTgz",
      "title": "Fix a test-vector.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/321",
      "state": "MERGED",
      "author": "pieterlexis",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "One of the formats was not updated when the alpn was updated",
      "createdAt": "2021-04-30T09:49:47Z",
      "updatedAt": "2021-04-30T17:39:22Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "361df8edbe9c7ca6864b7b2ab1fd316c0104f213",
      "headRepository": "pieterlexis/dns-alt-svc",
      "headRefName": "fix-vectors",
      "headRefOid": "a082bf94dde3d04e605b5085139e10d934838e07",
      "closedAt": "2021-04-30T17:39:22Z",
      "mergedAt": "2021-04-30T17:39:22Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "a62e434a7bcc9ff93b643d2a8fecb23bb690b175"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ5NDQyNDIz",
          "commit": {
            "abbreviatedOid": "a082bf9"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-30T17:39:18Z",
          "updatedAt": "2021-04-30T17:39:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 322,
      "id": "MDExOlB1bGxSZXF1ZXN0NjMyOTAyMzkx",
      "title": "Test Vector presentation format full dns records",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/322",
      "state": "MERGED",
      "author": "moonshiner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Updated the Test Vectors in the appendix so they appear as DNS records, similar to the failure cases below them. \r\n\r\n",
      "createdAt": "2021-05-07T14:57:50Z",
      "updatedAt": "2021-05-07T17:06:14Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "a62e434a7bcc9ff93b643d2a8fecb23bb690b175",
      "headRepository": "moonshiner/dns-alt-svc",
      "headRefName": "tjw-appendix-edits",
      "headRefOid": "8bb16cef4c1fae26313d78e0850fc6d828802028",
      "closedAt": "2021-05-07T17:06:14Z",
      "mergedAt": "2021-05-07T17:06:14Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "6357e034a31d29bcc10d13745e64e568e7509eab"
      },
      "comments": [
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ARRGH thought I caught them all.  thanks",
          "createdAt": "2021-05-07T15:53:00Z",
          "updatedAt": "2021-05-07T15:53:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0NTk4MDQ1",
          "commit": {
            "abbreviatedOid": "1882c8d"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-07T15:21:30Z",
          "updatedAt": "2021-05-07T15:21:31Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "When compiling, I see\r\n> /tmp/dns-alt-svc/draft-ietf-dnsop-svcb-https.xml(2536): Warning: Artwork too wide, reducing indentation from 3 to 0\r\n> /tmp/dns-alt-svc/draft-ietf-dnsop-svcb-https.xml(2536): Warning: Too long line found (L2213), 6 characters longer than 72 characters: \r\n\r\n```suggestion\r\n    example.com.   SVCB   1 foo.example.com. (\r\n                          ipv6hint=\"2001:db8::1,2001:db8::53:1\"\r\n                          )\r\n```",
              "createdAt": "2021-05-07T15:21:31Z",
              "updatedAt": "2021-05-07T15:23:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0NjkzMTky",
          "commit": {
            "abbreviatedOid": "8bb16ce"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-07T17:06:05Z",
          "updatedAt": "2021-05-07T17:06:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 323,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQwOTQ5MzY0",
      "title": "Document the rationale for Params in the RDATA",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/323",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-11T16:03:04Z",
      "updatedAt": "2021-08-17T15:26:32Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "6357e034a31d29bcc10d13745e64e568e7509eab",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-rationale",
      "headRefOid": "54322c645235a19f6362b88f46ecaacecb33924f",
      "closedAt": "2021-08-17T15:26:32Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I proposed this language in response to a conversation on the mailing list, but it looks like that conversation ended up going in a different direction.  Maybe we don't need this at all.\r\n\r\nI've changed the status to \"draft\".  I'm happy to put it in an appendix if anyone thinks that would help.",
          "createdAt": "2021-06-01T15:52:21Z",
          "updatedAt": "2021-06-01T15:52:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjczMjQzMTYw",
          "commit": {
            "abbreviatedOid": "54322c6"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Do we want this in an appendix?  It seems distracting up-top.  (Otherwise looks fine?)",
          "createdAt": "2021-06-01T15:46:03Z",
          "updatedAt": "2021-06-01T15:46:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 325,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ4Mjk5ODcw",
      "title": "Make comma escaping support optional if it's not needed",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/325",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change makes support for comma escaping in value lists mandatory\r\nonly after an ALPN ID is registered that contains a special character.\r\nThis gives zone file implementers the option to avoid implementation of\r\nthe value-list escaping now, and perhaps indefinitely.",
      "createdAt": "2021-05-20T01:25:13Z",
      "updatedAt": "2021-06-02T20:41:43Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "430d1917ab2f6bc52c84cb0260c7e1cb1adfd701",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-comma-escaping",
      "headRefOid": "2252b834d494d4f69bba1f49d9a85c8f9b170677",
      "closedAt": "2021-06-02T20:41:40Z",
      "mergedAt": "2021-06-02T20:41:40Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "e57e8e85899057e62594a3d91ec03d0ca946d7c1"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've removed the conditional related to the IANA registry and explained the workaround.",
          "createdAt": "2021-05-21T04:53:36Z",
          "updatedAt": "2021-05-21T04:53:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYzODMzNDI3",
          "commit": {
            "abbreviatedOid": "6685440"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Mark points out (and I was going to make the same comment) that we should also mention that such implementations may choose to display such entries as key1=\"...\" instead of alpn=\"...\".\r\n\r\nRather than referencing the ALPN registry, we could just have the MAY and say that in this case it is still possible to use key1=\"...\" with these implementations for any ALPN values needing special characters.",
          "createdAt": "2021-05-20T02:19:27Z",
          "updatedAt": "2021-05-20T02:19:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjczMjQ4NTQy",
          "commit": {
            "abbreviatedOid": "c6b403a"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Seems fine, but we may want to include this example?\r\n",
          "createdAt": "2021-06-01T15:50:57Z",
          "updatedAt": "2021-06-01T15:51:18Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nor \"\\\\\", this is trivial.  If items in the list are allowed to contain \",\",\r\nit can be specified by escaping as \"\\\\,\"  or by relying on the \r\nrelying on the opaque key format (e.g. `key1=\\002h2`) for \r\nimplementations that do not support escaping.\r\n(For simplicity, empty items are not allowed.)\r\n```\r\n\r\nIt seems worth including an example here for here for potential zone file authors, not just implementors?",
              "createdAt": "2021-06-01T15:50:57Z",
              "updatedAt": "2021-06-01T15:51:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjczMjU1MTM5",
          "commit": {
            "abbreviatedOid": "c6b403a"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-01T15:56:04Z",
          "updatedAt": "2021-06-01T15:56:04Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I think it's OK to mention the opaque key format here (although I doubt many zone file authors will be reading the appendix), but I would prefer not to duplicate the example.",
              "createdAt": "2021-06-01T15:56:04Z",
              "updatedAt": "2021-06-01T15:56:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc0NTk3MTky",
          "commit": {
            "abbreviatedOid": "2252b83"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-02T19:18:56Z",
          "updatedAt": "2021-06-02T19:18:57Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I expanded the text here in a different way.  Please review.",
              "createdAt": "2021-06-02T19:18:56Z",
              "updatedAt": "2021-06-02T19:18:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc0NjUzNTA3",
          "commit": {
            "abbreviatedOid": "2252b83"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-02T20:30:17Z",
          "updatedAt": "2021-06-02T20:30:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 327,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ5NjQ0OTYy",
      "title": "Expand explanation of Alt-Svc/ECH interaction",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/327",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #326",
      "createdAt": "2021-05-21T04:33:51Z",
      "updatedAt": "2021-06-15T21:22:50Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "430d1917ab2f6bc52c84cb0260c7e1cb1adfd701",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-ech-alt-svc",
      "headRefOid": "d98dd191a91975bd3063db012eb9b9e286bd2332",
      "closedAt": "2021-06-15T21:22:50Z",
      "mergedAt": "2021-06-15T21:22:50Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "d98dd191a91975bd3063db012eb9b9e286bd2332"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Converted to draft as #329 seems to have more support.",
          "createdAt": "2021-05-27T16:16:31Z",
          "updatedAt": "2021-05-27T16:16:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2MzIwNjAz",
          "commit": {
            "abbreviatedOid": "095b3c0"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "This doesn't really say all it needs to say.  Well, at least it is a pretty user-unfriendly way of presenting the information.\r\n\r\nTo start with, you have to go off and read the other section to understand that SVCB-optional mode is something that is implicitly disabled when an ECH-enabled client encounters an ECH attribute.  You also have to appreciate understand that Alt-Svc operates by including the origin name in SNI and not the alternative service name.  Then you need to connect the dots from there to realize that Alt-Svc as specified in RFC 7838 is incompatible with ECH.\r\n\r\nIt would also be nice to lay out how server operators deal with this mess.  As it stands, server operators currently need to choose between the two with the understanding that ECH-enabled clients might not follow Alt-Svc, that clients without ECH might follow Alt-Svc, AND that all of this might change if Alt-Svc is ever revised (we can't promise that it will change, though we really need to - at least in my opinion).",
          "createdAt": "2021-05-24T00:11:24Z",
          "updatedAt": "2021-05-24T00:11:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 328,
      "id": "MDExOlB1bGxSZXF1ZXN0NjUwODQ3OTgw",
      "title": "Remove underscore prefix for SVCB TargetName resolving",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/328",
      "state": "CLOSED",
      "author": "Habbie",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "proposed to close"
      ],
      "body": "Hello authors,\r\n\r\nI'm putting this in as a PR because I suspect -not- having these words was an unintentional oversight; I talked to a few people familiar with this draft (and the svcb-dns) one and several of them thought I was wrong and the words are just missing.\r\n\r\nThere's one FIXME in this PR; there might be other places where a few words should also be added.\r\n\r\nIf you tell me 'this makes sense' I will clean up this PR. Otherwise, if you prefer I take this to dnsop, I'll do that.\r\n\r\nThanks!",
      "createdAt": "2021-05-23T20:05:40Z",
      "updatedAt": "2021-09-07T22:17:58Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "430d1917ab2f6bc52c84cb0260c7e1cb1adfd701",
      "headRepository": "PowerDNS/dns-alt-svc",
      "headRefName": "svcb-underscore-dot",
      "headRefOid": "99e048bf86cba3785859019e89dc1438ce03743e",
      "closedAt": "2021-09-07T22:17:58Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "See #252 by @squarooticus, which was discussed in [this WG thread](https://mailarchive.ietf.org/arch/msg/dnsop/K6uyh2B5uFpNgNcgLc8PtOK9uEg/).  At the time, the authors concluded that there was insufficient support for this change in the working group.",
          "createdAt": "2021-05-24T02:05:17Z",
          "updatedAt": "2021-05-24T02:05:17Z"
        },
        {
          "author": "Habbie",
          "authorAssociation": "NONE",
          "body": "Thanks, managed to miss that in my searches. In that case, the draft needs to clarify that underscore prefixes are -not- stripped. I might PR that later.",
          "createdAt": "2021-05-24T08:06:32Z",
          "updatedAt": "2021-05-24T08:06:32Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 329,
      "id": "MDExOlB1bGxSZXF1ZXN0NjU0MjQzNTcx",
      "title": "Alternative Alt-Svc+HTTPS-RR integration",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/329",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This version places the burden of consistency on domain owners instead\r\nof client implementors.\r\n\r\nAddresses #326.",
      "createdAt": "2021-05-26T21:20:10Z",
      "updatedAt": "2021-06-15T21:22:52Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "430d1917ab2f6bc52c84cb0260c7e1cb1adfd701",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-ech-alt-svc-2",
      "headRefOid": "d0caa54b1042993d2876fffaf07a24f3f7113d76",
      "closedAt": "2021-06-15T21:22:49Z",
      "mergedAt": "2021-06-15T21:22:49Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "457ff5fca1ee813c0fbebc5776c2b263409d6d51"
      },
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "I like this direction better.  Some things we should cover:\r\n\r\n* alt-authorities may not have HTTPS records, just A/AAAA records.  \r\n* What to do if an alt-authority has no HTTPS records, just A/AAAA, and a client is SVCB-required.  (Answer would be to ignore the Alt-Svc.)\r\n* How to handle ports in the HTTPS record vs Alt-Svc record.  Should they be required to match?  We should be explicit.\r\n* How to handle compatible ALPNs where negotiation happens at TLS-time (eg, h2 vs http/1.1).  We have better logic here and this is something Alt-Svc-bis will want to fix.  In the meantime, do we want to allow these to be considered compatible or not?",
          "createdAt": "2021-05-26T21:34:40Z",
          "updatedAt": "2021-05-26T21:34:40Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, please suggest text on those counts.\r\n\r\nPersonally, I think your list looks like a list of reasons not to do this.  We are attempting to delicately stitch together two different data models, with an N^2-like complexity of interacting features, which seems much more difficult than just declaring that you do one or the other.",
          "createdAt": "2021-05-26T21:39:29Z",
          "updatedAt": "2021-05-26T21:39:29Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I've updated the text to address some of those concerns.\r\n\r\n> * alt-authorities may not have HTTPS records, just A/AAAA records.\r\n\r\nI think this case is clear in the text.\r\n\r\n> * What to do if an alt-authority has no HTTPS records, just A/AAAA, and a client is SVCB-required.  (Answer would be to ignore the Alt-Svc.)\r\n\r\n\"Clients for pre-existing protocols (e.g.  HTTPS) SHALL implement SVCB-optional behavior\", so I don't think we need to worry about that.\r\n\r\n> * How to handle ports in the HTTPS record vs Alt-Svc record.  Should they be required to match?  We should be explicit.\r\n\r\nOK, added a sentence.\r\n\r\n> * How to handle compatible ALPNs where negotiation happens at TLS-time (eg, h2 vs http/1.1).  We have better logic here and this is something Alt-Svc-bis will want to fix.  In the meantime, do we want to allow these to be considered compatible or not?\r\n\r\nThe endless debate is about this text in RFC 7838\r\n\r\n> If the connection to the alternative service does not negotiate the expected protocol (for example, ALPN fails to negotiate h2, or an Upgrade request to h2c is not accepted), the connection to the alternative service MUST be considered to have failed.\r\n\r\nThis text is ambiguous, but I think \"fails to negotiate\" means that clients MAY send just the specified ALPN, not that servers MUST prefer it.  Regardless, I am hesitant to mess with this here, due to the risk of needing to Update RFC 7838.  I added a sentence alluding to that.\r\n\r\nThere is an alternative formulation in which we says that the Alt-Svc ALPN is added to the SVCB ALPN set, but that seems like a bigger change to Alt-Svc, and it would not improve security.",
          "createdAt": "2021-05-27T14:43:35Z",
          "updatedAt": "2021-05-27T16:08:41Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "> > * How to handle compatible ALPNs where negotiation happens at TLS-time (eg, h2 vs http/1.1).  We have better logic here and this is something Alt-Svc-bis will want to fix.  In the meantime, do we want to allow these to be considered compatible or not?\r\n> \r\n> The endless debate is about this text in RFC 7838\r\n> \r\n> > If the connection to the alternative service does not negotiate the expected protocol (for example, ALPN fails to negotiate h2, or an Upgrade request to h2c is not accepted), the connection to the alternative service MUST be considered to have failed.\r\n> \r\n> This text is ambiguous, but I think \"fails to negotiate\" means that clients MAY send just the specified ALPN, not that servers MUST prefer it. Regardless, I am hesitant to mess with this here, due to the risk of needing to Update RFC 7838. I added a sentence alluding to that.\r\n> \r\n> There is an alternative formulation in which we says that the Alt-Svc ALPN is added to the SVCB ALPN set, but this seems like a bigger change to Alt-Svc, and it would not improve security.\r\n\r\nI agree that HTTPS's looser ALPN renegotiation is generally better, but I think Ben has it right that we can't mess with that here without updating RFC7838.  (Doesn't make a difference either way for Chrome's current implementations where we only support h3 Alt-Svc which as far as I know can't be renegotiated.)",
          "createdAt": "2021-05-27T16:11:22Z",
          "updatedAt": "2021-05-27T16:11:22Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "And in general, yes, I like this direction and feel it does a good job capturing my earlier proposal.",
          "createdAt": "2021-05-27T16:13:39Z",
          "updatedAt": "2021-05-27T16:13:39Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "I think we might need to add a sentence clarifying SVCB-optional behavior.\r\n\r\nWhen, per the SVCB-optional behavior the client acts as if there's an extra endpoint at the end without any SvcParams, I assume we want to be able to connect to that using the Alt-Svc protocol.  But I think things could be misinterpreted into technically blocking fallback to that endpoint because it is specified as an endpoint with \"no SvcParams\", which is just the default ALPN and thus not consistent with the Alt-Svc if the Alt-Svc specifies a different protocol.\r\n\r\nShould this text clarify that the extra SVCB-optional endpoint is treated as having the necessary SvcParams to be consistent with Alt-Svc parameters to allow a normal connection that follows SVCB aliases? Or is there a desire to not allow SVCB aliasing with Alt-Svc, and thus only allow fallback to pure non-SVCB connection?",
          "createdAt": "2021-05-27T22:17:50Z",
          "updatedAt": "2021-05-27T22:17:50Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "> When, per the SVCB-optional behavior the client acts as if there's an extra endpoint at the end without any SvcParams, I assume we want to be able to connect to that using the Alt-Svc protocol. But I think things could be misinterpreted into technically blocking fallback to that endpoint because it is specified as an endpoint with \"no SvcParams\", which is just the default ALPN and thus not consistent with the Alt-Svc if the Alt-Svc specifies a different protocol.\r\n\r\nAs you noted, this only applies to \"Alias-only\" HTTPS record setups on the alt-authority.  For that weird case, I think either client behavior is acceptable.  If you really want Alt-Svc clients to follow that alias, you should really just update your Alt-Svc hostname to point to the target ... or use a CNAME.  (Alt-authorities aren't user-visible, so there's no need for them to be at a zone apex.)",
          "createdAt": "2021-06-01T18:22:03Z",
          "updatedAt": "2021-06-01T18:22:03Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "> > When, per the SVCB-optional behavior the client acts as if there's an extra endpoint at the end without any SvcParams, I assume we want to be able to connect to that using the Alt-Svc protocol. But I think things could be misinterpreted into technically blocking fallback to that endpoint because it is specified as an endpoint with \"no SvcParams\", which is just the default ALPN and thus not consistent with the Alt-Svc if the Alt-Svc specifies a different protocol.\r\n> \r\n> As you noted, this only applies to \"Alias-only\" HTTPS record setups on the alt-authority. For that weird case, I think either client behavior is acceptable. If you really want Alt-Svc clients to follow that alias, you should really just update your Alt-Svc hostname to point to the target ... or use a CNAME. (Alt-authorities aren't user-visible, so there's no need for them to be at a zone apex.)\r\n\r\nI think you're right that enough alternatives exist here for that the server should be able to easily do what it needs to do either way.  I'm just worried about whether or not the client should have to worry about making sure something specific happen or just let it get treated however the client implementation would otherwise treat it.  I think a simple added \"MAY\" could simplify implementations quite a bit to make it explicit that either client behavior is acceptable and non-important.  Otherwise, I'm worried that things technically work out into an implicit MUST that the client has to make sure to block the extra endpoint in some scenarios, and I'm honestly not sure which way things will work out easiest to implement.\r\n\r\nHow about:\r\n\"SVCB-optional clients MAY make use of AliasMode HTTPS records with Alt-Svc parameters by attempting connections to the final alias query name with the Alt-Svc parameters.\"?",
          "createdAt": "2021-06-01T18:44:02Z",
          "updatedAt": "2021-06-01T18:44:02Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "@ericorth This whole section is only at \"SHOULD\" strength, so I don't think we need to worry about an \"implicit MUST\".\r\n\r\nThe client behavior for Alt-Svc (in RFC 7838) is specified loosely, with the understanding that if it doesn't work clients will normally just fall back to regular connection.  Clients can pretty much try, or not try, whatever they want.  From that perspective, I think adding more text on every corner case is likely to obscure the essentials more than it helps.",
          "createdAt": "2021-06-01T20:14:24Z",
          "updatedAt": "2021-06-01T20:14:24Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "> @ericorth This whole section is only at \"SHOULD\" strength, so I don't think we need to worry about an \"implicit MUST\".\r\n> \r\n> The client behavior for Alt-Svc (in RFC 7838) is specified loosely, with the understanding that if it doesn't work clients will normally just fall back to regular connection. Clients can pretty much try, or not try, whatever they want. From that perspective, I think adding more text on every corner case is likely to obscure the essentials more than it helps.\r\n\r\nMaybe some of the other text elsewhere around SVCB-optional client algorithms and such are bordering on over-specified, because it feels to me that they mandate a specific behavior that doesn't quite make sense here.  But if nobody else feels that way and everybody is happy with the practical interpretation of clients doing reasonable things falling back to using Alt-Svc parameters with SVCB alias-only or non-alias, then I guess I'm fine with that.",
          "createdAt": "2021-06-01T20:52:45Z",
          "updatedAt": "2021-06-01T20:52:45Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this is the last remaining PR blocking the post-WGLC revision.  Please review this version (especially if you have thoughts on ECH) and indicate whether it looks acceptable.",
          "createdAt": "2021-06-02T20:49:35Z",
          "updatedAt": "2021-06-02T20:49:35Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson  and @ericorth : are you good with what we have here now?",
          "createdAt": "2021-06-03T18:28:12Z",
          "updatedAt": "2021-06-03T18:28:12Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "> @martinthomson and @ericorth : are you good with what we have here now?\r\n\r\nLooks good to me.  I think we've hit all the main necessary points.",
          "createdAt": "2021-06-03T18:42:00Z",
          "updatedAt": "2021-06-03T18:42:00Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "I suspect that any detailed specification of how these state machines are integrated is likely to be unimplementable for some clients, so I would prefer to avoid excessive detail here.  I also think it's unnecessary: Alt-Svc always falls back to the origin, so apart from security issues, we don't have to standardize the corner cases.\r\n\r\nThat said, please suggest any extra text that you would like to see added.",
          "createdAt": "2021-06-09T02:30:33Z",
          "updatedAt": "2021-06-09T02:30:33Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh gosh GitHub is the worst. It got confused and duplicated one of my comments, but in trying to delete the duplicate, it deleted my entire set of comments. Let me try to recreate them...",
          "createdAt": "2021-06-11T03:37:17Z",
          "updatedAt": "2021-06-11T03:37:17Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hrm, or maybe it didn't delete it, just the outer \"code review\" grouping?",
          "createdAt": "2021-06-11T03:42:20Z",
          "updatedAt": "2021-06-11T03:42:20Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks to everyone for helping to shape this section.  If there are no more comments in 24 hours, I'm going to regard this text as approved and publish a new draft version.",
          "createdAt": "2021-06-14T14:26:03Z",
          "updatedAt": "2021-06-14T14:26:03Z"
        },
        {
          "author": "ericorth",
          "authorAssociation": "NONE",
          "body": "All looks good to me.",
          "createdAt": "2021-06-14T15:47:34Z",
          "updatedAt": "2021-06-14T15:47:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjcwODQ2ODc3",
          "commit": {
            "abbreviatedOid": "1e95050"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I like this a lot more than the other one.\r\n\r\nI have my reservations about the squishiness here.\r\n\r\nI would be interested in the opinion of @ekr, @huitema, @chris-wood, @carickdb, @cjpatton, and @davidben on this issue as this relates directly to ECH.",
          "createdAt": "2021-05-28T00:42:06Z",
          "updatedAt": "2021-05-28T00:44:53Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Is it the case that the client will use the alternative service without ECH, or that it won't use the alternative service?\r\n\r\nOr do we want to leave that unspecified?  I know that we allow some HTTPS/SVCB records to include ECH and some to omit it and that client policy governs which are chosen.  Is this just another case where client policy applies?\r\n\r\nPersonally, I would very much prefer saying that if you use ECH to connect, you MUST NOT use an alternative that doesn't have an ECH config.  \"SHOULD NOT\" would be acceptable on the grounds that we aren't dictating client policy.  But it's a pretty bad leak, and one that could be the result of a mistake in server configuration.",
              "createdAt": "2021-05-28T00:42:06Z",
              "updatedAt": "2021-05-28T00:44:53Z"
            },
            {
              "originalPosition": 38,
              "body": "```suggestion\r\nSimilar consistency considerations could apply to future SvcParamKeys, so\r\n```",
              "createdAt": "2021-05-28T00:44:31Z",
              "updatedAt": "2021-05-28T00:44:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjcwODUzNjcx",
          "commit": {
            "abbreviatedOid": "8cd6d1a"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-28T01:03:39Z",
          "updatedAt": "2021-05-28T01:03:39Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "> Or do we want to leave that unspecified?\r\n\r\nFWIW, that's what I mean in this text (equivalent to normative MAY).\r\n\r\n> Personally, I would very much prefer saying that if you use ECH to connect, you MUST NOT use an alternative that doesn't have an ECH config.\r\n\r\nA client that wanted to implement that behavior would have to query _both_ the origin and the alt-authority for HTTPS records before it could proceed with an Alt-Svc connection.  If we want clients to take responsibility for ensuring ECH isn't lost, I think #327 makes more sense.\r\n\r\nP.S. Typo: @carrickdb",
              "createdAt": "2021-05-28T01:03:39Z",
              "updatedAt": "2021-05-28T01:03:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjcwOTM4MDcw",
          "commit": {
            "abbreviatedOid": "8cd6d1a"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-28T05:25:15Z",
          "updatedAt": "2021-05-28T05:25:15Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "> > Personally, I would very much prefer saying that if you use ECH to connect, you MUST NOT use an alternative that doesn't have an ECH config.\r\n> \r\n> A client that wanted to implement that behavior would have to query _both_ the origin and the alt-authority for HTTPS records before it could proceed with an Alt-Svc connection. If we want clients to take responsibility for ensuring ECH isn't lost, I think #327 makes more sense.\r\n\r\nI think we're sufficiently covered due to the assumption (supported by a SHOULD here in the text) that if an origin publishes ECH for the origin endpoints, it also publishes ECH for the Alt-Svc endpoints.  Means that with a single DNS query, the client can find whether the server supports ECH unless the domains are stupidly configured (a similar level of stupidity as just forgetting to publish ECH keys on any other endpoint).\r\n\r\nThe current requirement is already that only if all endpoints found have ECH, the client MUST use the the ECH endpoints.  If a server is misconfigured to give non-ECH endpoints, I think it's best left to client choice how to prioritize ECH vs other factors like h3 (e.g. a non-privacy-sensitive client may choose to prioritize using an h3 endpoint if only h2 endpoints have ECH, or an extra-privacy-sensitive client may choose to not allow Alt-Svc at all unless ECH endpoints are found or may want to take the performance hit to query all Alt-Svc names and the origin to find any possible ECH endpoints before connecting to anything).\r\n\r\nNo matter what the client chooses as endpoint priorities, the proper configuration for an origin to force ECH is clear (and clearly recommended by section 9.2): Include ECH on all endpoints and section 9.1 requires ECH-capable clients to only connect via those endpoints.  This just now would apply to endpoints given on Alt-Svc names too.",
              "createdAt": "2021-05-28T05:25:15Z",
              "updatedAt": "2021-05-28T05:25:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjczMjE5ODM5",
          "commit": {
            "abbreviatedOid": "8cd6d1a"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-01T15:26:30Z",
          "updatedAt": "2021-06-01T15:26:30Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nalso publish an \"ech\" SvcParam for any Alt-Svc alt-authority hostnames.  Otherwise,\r\n```",
              "createdAt": "2021-06-01T15:26:30Z",
              "updatedAt": "2021-06-01T15:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjczMjI0MDY4",
          "commit": {
            "abbreviatedOid": "8cd6d1a"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This is looking generally good.  I'll leave the question as to whether we want to be stricter about ECH to others.  Perhaps we merge this and then look at the ECH section to see if we want some tightening or clarification there?",
          "createdAt": "2021-06-01T15:30:15Z",
          "updatedAt": "2021-06-01T15:37:08Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Do we also want to add an example in the appendix without the port prefix?",
              "createdAt": "2021-06-01T15:30:15Z",
              "updatedAt": "2021-06-01T15:37:08Z"
            },
            {
              "originalPosition": 33,
              "body": "Do we also want to add a:\r\n\"Clients MAY choose to ignore individual returned HTTPS RRs,\r\nor the Alt-Svc entry entirely, based on mismatches between the \r\nAlt-Svc record and HTTPS RR SvcParams.\"\r\nThis gives flexibility here for client behavior based on ECS\r\nas well as for cases like the Chrome behavior of wanting\r\nto match h3-to-h3 and h2-to-tcp but without over-specifying.",
              "createdAt": "2021-06-01T15:34:01Z",
              "updatedAt": "2021-06-01T15:37:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjczNDIxNDk1",
          "commit": {
            "abbreviatedOid": "8cd6d1a"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-01T17:48:47Z",
          "updatedAt": "2021-06-01T17:48:48Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "It seems clear enough to me as-is, but if you think it's confusing, we can add it.",
              "createdAt": "2021-06-01T17:48:48Z",
              "updatedAt": "2021-06-01T17:48:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjczNDMyOTIz",
          "commit": {
            "abbreviatedOid": "8cd6d1a"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-01T18:01:33Z",
          "updatedAt": "2021-06-01T18:01:33Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "I'm not sure I understand, but I don't think this is necessary.  If a record cannot be used in a way that is consistent with the Alt-Svc Field Value, then the record is effectively ignored when attempting to use that Alt-Svc Field Value.",
              "createdAt": "2021-06-01T18:01:33Z",
              "updatedAt": "2021-06-01T18:01:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjczNDUxMDYw",
          "commit": {
            "abbreviatedOid": "20398f2"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-01T18:23:48Z",
          "updatedAt": "2021-06-01T18:23:48Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Fixed!",
              "createdAt": "2021-06-01T18:23:48Z",
              "updatedAt": "2021-06-01T18:23:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc0ODI2MzI5",
          "commit": {
            "abbreviatedOid": "20398f2"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-03T02:37:28Z",
          "updatedAt": "2021-06-03T02:37:28Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\n    Alt-Svc: h3=\"alt.example.com:8443\"; h2=\"alt.example.com:443\"; ...\r\n\r\nThe client would retrieve the following HTTPS records:\r\n    alt.example.com. ... 1 alt2.example.com. (\r\n            port=9443 alpn=h2,h3 ech=... )\r\n    _8443._https.alt.example.com. ... 1 alt2.example.com. (\r\n```\r\n",
              "createdAt": "2021-06-03T02:37:28Z",
              "updatedAt": "2021-06-03T02:41:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc0ODI2NTI3",
          "commit": {
            "abbreviatedOid": "20398f2"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-03T02:38:04Z",
          "updatedAt": "2021-06-03T02:38:04Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "It seems good to add just to be crystal clear that h3=\"alt.example.com:443\" only looks up the HTTPS RR for \"alt.example.com\".\r\nJust showing both forms here as below might be one way to do this.",
              "createdAt": "2021-06-03T02:38:04Z",
              "updatedAt": "2021-06-03T02:38:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc0ODI4NDAy",
          "commit": {
            "abbreviatedOid": "20398f2"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-03T02:43:28Z",
          "updatedAt": "2021-06-03T02:43:28Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "This would be giving the client permission to do filtering.  In the above example, h3 would only be used for the HTTPS RR at _8443._https.alt.example.com and h2 would only be used for the HTTPS RR at alt.example.com",
              "createdAt": "2021-06-03T02:43:28Z",
              "updatedAt": "2021-06-03T02:43:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc1MzI3MTc4",
          "commit": {
            "abbreviatedOid": "257c387"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-03T14:12:18Z",
          "updatedAt": "2021-06-03T14:12:19Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "OK, I added your suggested example and tweaked it slightly to (1) simplify, (2) cover the case where there is no `port` SvcParam, and (3) cover the case where the Alt-Svc hostname is implicit.",
              "createdAt": "2021-06-03T14:12:18Z",
              "updatedAt": "2021-06-03T14:12:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc1MzMxODQ5",
          "commit": {
            "abbreviatedOid": "257c387"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-03T14:16:19Z",
          "updatedAt": "2021-06-03T14:16:20Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "In this example, neither RR is \"ignored\".  They're \"constrained\" or \"filtered\", perhaps.\r\n\r\nI've expanded the text to match the new example.  I think the new text conveys the idea pretty clearly.",
              "createdAt": "2021-06-03T14:16:19Z",
              "updatedAt": "2021-06-03T14:16:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc1NjA1MTE5",
          "commit": {
            "abbreviatedOid": "257c387"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The new example covers things fairly well.  It seems like more clear clarification can be in a future Alt-Svc update.  Hopefully this is not under-specified?",
          "createdAt": "2021-06-03T18:27:34Z",
          "updatedAt": "2021-06-03T18:27:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc1ODMwODY5",
          "commit": {
            "abbreviatedOid": "257c387"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-06-04T00:31:10Z",
          "updatedAt": "2021-06-04T00:36:19Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\n\r\n    alt.example.com. IN HTTPS 1 . alpn=h2,h3 ech=...\r\n```\r\nI think that you need vertical space here for this to render correctly.\r\n\r\nUsing `~~~` around figures is good hygiene and that allows you to [annotate](https://www.rfc-editor.org/materials/sourcecode-types.txt) them correctly.  (Like using `~~~http-message` for the example above.)",
              "createdAt": "2021-06-04T00:31:10Z",
              "updatedAt": "2021-06-04T00:36:19Z"
            },
            {
              "originalPosition": 38,
              "body": "I would prefer:\r\n\r\n> Clients that connect to an alt-authority would reveal the name of the server in an unencrypted ClientHello.  Clients SHOULD NOT use an alt-authority if the original connection uses ECH and no \"ech\" SvcParam is provided for the alt-authority.\r\n\r\nThis is not saying that the client could (or may) reveal identity, but saying that if it did connect then it would.  THEN I want a recommendation against doing the stupid thing.  I would settle for just the first sentence, but I do really prefer both.",
              "createdAt": "2021-06-04T00:36:16Z",
              "updatedAt": "2021-06-04T00:36:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc1ODUwMDk1",
          "commit": {
            "abbreviatedOid": "02afe0b"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T01:29:23Z",
          "updatedAt": "2021-06-04T01:29:24Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Just to be clear, you're proposing that implementations should add an indication to each Alt-Svc cache entry about whether ECH was in use on the connection over which that entry was received, so that ECH consistency can be enforced when that cache entry is used (perhaps several weeks later)?",
              "createdAt": "2021-06-04T01:29:24Z",
              "updatedAt": "2021-06-04T01:29:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc1ODg2NTE5",
          "commit": {
            "abbreviatedOid": "02afe0b"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T03:20:12Z",
          "updatedAt": "2021-06-04T03:20:13Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "No, I'm suggesting that client implementations that start using ECH keep using ECH.  The decision to use an alternative is made in the moment and can be based on what is active. That's consistent with the other text you have.  \r\n\r\nI hadn't fully considered the point about caching.  That is, if we use ECH on Tuesday, but fetch and reject an Alt-Svc advertisement for lack of ECH, do you cache that entry?  \r\n\r\nThis is really something that an Alt-Svc revision needs to deal with, so we might need to be careful here.  I can imagine that the decision about whether to insist on ECH would be made anew on Friday.  My preference is that yes, if you do cache the Alt-Svc advertisement you also remember that it was disqualified for lack of ECH or just that it was not acceptable at the time it was retrieved.  For me, that marker would be cause to avoid connecting immediately to the alternative without first going to the primary.  Which gets back to the SHOULD.",
              "createdAt": "2021-06-04T03:20:12Z",
              "updatedAt": "2021-06-04T03:20:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc1ODk2MTM4",
          "commit": {
            "abbreviatedOid": "02afe0b"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T03:51:25Z",
          "updatedAt": "2021-06-04T03:51:25Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I certainly hope most clients would get smart about not changing away from an ECH connection to a non-ECH connection, but I think this is hard to create any actual rules about without over-specifying things and I suggest we not get into it.  E.g., how long after a successful ECH connection should a client be rejecting non-ECH Alt-Svc?\r\n\r\nPlus, I think leaving this up to the client to make a good decision is consistent with the rest of the spec.  If the server gives some ECH endpoints and some non-ECH endpoints, it's up to the client to make the decisions over how/if to prefer endpoints that support ECH.  So the spec is saying if a server really wants to require ECH for ECH-capable clients, they need to include ECH on all endpoints, including Alt-Svc endpoints, and this is the recommended/should'ed server configuration.  If the server doesn't configure that, most clients will ideally still choose to prefer ECH, but that's up to the client, and some clients may have reason to prefer any route to h3, thus potentially disabling ECH.",
              "createdAt": "2021-06-04T03:51:25Z",
              "updatedAt": "2021-06-04T03:51:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2MzA3Mjgw",
          "commit": {
            "abbreviatedOid": "338f579"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T13:50:22Z",
          "updatedAt": "2021-06-04T13:50:22Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "> My preference is that yes, if you do cache the Alt-Svc advertisement you also remember that it was disqualified for lack of ECH or just that it was not acceptable at the time it was retrieved.\r\n\r\nAlt-Svc field values don't say anything about ECH.  That's a property of the HTTPS record for the alt-authority, which is not known (and may change) until the client attempts the Alt-Svc connection, which may not be until much later.\r\n\r\nIt sounds like we want to support this behavior, but the details are too unsettled to make a normative recommendation.  I've adjusted the explanation based on @martinthomson's suggestion, and added the following sentence:\r\n> Clients MAY impose their own consistency conditions on Alt-Svc connections, e.g. requiring ECH if the origin's SvcParams offered ECH.\r\n\r\nPlease review.",
              "createdAt": "2021-06-04T13:50:22Z",
              "updatedAt": "2021-06-04T13:50:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2MzY2OTQx",
          "commit": {
            "abbreviatedOid": "338f579"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-04T14:47:17Z",
          "updatedAt": "2021-06-04T14:47:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc4NjgzODQ3",
          "commit": {
            "abbreviatedOid": "338f579"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-08T15:36:32Z",
          "updatedAt": "2021-06-08T15:36:32Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Current text still looks good to me.  The important thing here is that we give clients a technical path to ECH and make clear to domains the strongly recommended way to configure it to make sure clients can use it.  I think we have that.",
              "createdAt": "2021-06-08T15:36:32Z",
              "updatedAt": "2021-06-08T15:36:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc5MTA1MzYw",
          "commit": {
            "abbreviatedOid": "338f579"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This works for me. Specifically, it meets these goals:\r\n\r\n* Origins should not have to choose between their current h3 deployments and ECH. It should be easy for an origin to reliably enable ECH after having previously deployed h3 with Alt-Svc, and without sacrificing that deployment.\r\n* It should not be a requirement to stick ECH keys inside Alt-Svc. Alt-Svc only applies to the next HTTP request, which means it needs a qualitatively longer lifetime than HTTPS/SVCB. ECH keys in Alt-Svc may well be something to explore later, but it should be possible to deploy ECH without committing yourself to that lifetime of key.",
          "createdAt": "2021-06-09T00:12:44Z",
          "updatedAt": "2021-06-09T00:32:22Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Probably good to have an incompatible example too. Something like...\r\n\r\nAlt-Svc example:\r\n```\r\nAlt-Svc: h2=\"alt.example.com:443\", h2=\"alt2.example.com:443\", h3=\":8443\"\r\n```\r\n\r\nDNS example:\r\n```\r\n    alt.example.com. IN HTTPS 1 . alpn=h2,h3 ech=...\r\n    alt2.example.com. IN HTTPS 1 . alpn=h3 ech=...\r\n    _8443._https.example.com. IN HTTPS 1 alt3.example.com. (\r\n        port=9443 alpn=h2,h3 ech=... )\r\n```\r\n\r\nNew text:\r\n\r\n> The client could then attempt an HTTP/3 connection to `alt3.example.com:9443` with ECH, or an HTTP over TLS connection to `alt.example.com:443` with ECH, as these options are consistent with both an Alt-Svc field value and its HTTPS record. It, however, could not attempt an HTTP over TLS connection to `alt2.example.com:443` as this option is not compatible with the Alt-Svc value's ALPN protocol.\r\n\r\nPerhaps it's also worth something like:\r\n\r\n> An incompatible SVCB option for an Alt-Svc value is considered to have failed. If all SVCB options for an Alt-Svc value fail, a SVCB-optional client ({{client-behavior}}) MAY fall back to a direct connection to the Alt-Svc value, unless prohibited by {{client-failures}} or {{ech-client-behavior}}. If all permitted SVCB or fallback options for an Alt-Svc value fail, the Alt-Svc connection is considered to have failed. The client MAY then fall back to using the origin or another alternative service, as described in {{Section 2.4 of RFC7838}}.",
              "createdAt": "2021-06-09T00:12:45Z",
              "updatedAt": "2021-06-09T00:34:22Z"
            },
            {
              "originalPosition": 46,
              "body": "This sentence is unclear to me. Is the idea that the client would still fetch the origin's HTTPS record? Or is it that the client maintains some state from the last time it fetched the HTTPS record, which may have been quite some time ago? I assume it's not the former. But the latter is very stateful and probably deserves more specific text if that's the intent.",
              "createdAt": "2021-06-09T00:15:24Z",
              "updatedAt": "2021-06-09T00:32:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc5MTQ3MjU1",
          "commit": {
            "abbreviatedOid": "4d7b96b"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-09T02:08:39Z",
          "updatedAt": "2021-06-09T02:08:39Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "OK, I've added that example and incorporated various elements of this text.",
              "createdAt": "2021-06-09T02:08:39Z",
              "updatedAt": "2021-06-09T02:08:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc5MTUxNjg3",
          "commit": {
            "abbreviatedOid": "4d7b96b"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-09T02:20:36Z",
          "updatedAt": "2021-06-09T02:20:36Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "We don't have consensus to do any specific version of this, so there's no need to write it out in great detail.  I've made this vaguer, which I hope is clearer: \"Clients MAY impose their own consistency conditions on Alt-Svc connections, e.g. requiring ECH **if the origin is known to support** ECH.\".\r\n\r\nI wouldn't recommend Alt-Svc ECH consistency enforcement to a client implementor, but I think it's permissible within the very lax rules of Alt-Svc, and some people clearly want to implement it.  A correct and reliable implementation would have to re-query the origin's HTTPS record along with the alt-authority's in order to have them both fresh for a comparison (your first option).  However, a client that only wants partial consistency enforcement could gate this check on a cached hint (your second option), or apply the enforcement only when a connection to the origin is still open, or when the origin's HTTPS record is still in the local cache.\r\n\r\nBut this is all complicated and speculative, and I don't think it goes in the draft.\r\n\r\n@martinthomson Please review this version.",
              "createdAt": "2021-06-09T02:20:36Z",
              "updatedAt": "2021-06-09T02:20:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc5ODUyODY5",
          "commit": {
            "abbreviatedOid": "4d7b96b"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-09T15:55:09Z",
          "updatedAt": "2021-06-09T15:55:10Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "New text looks good to me.  Adds some nice clarity.\r\n\r\nSome of the text on fallback to non-Alt-Svc gets a little bit close to impeding/redefining territory on RFC7838, but I think it's sufficiently on the safe side of the line, especially with the \"as described in ...\" reference.\r\n\r\n",
              "createdAt": "2021-06-09T15:55:10Z",
              "updatedAt": "2021-06-09T15:55:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc5ODc4MzQ2",
          "commit": {
            "abbreviatedOid": "4d7b96b"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-09T16:19:03Z",
          "updatedAt": "2021-06-09T16:19:04Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "It is still my opinion that it would be very difficult to get any more specific on how to enforce matching origin ECH usage without getting way over-specified.\r\n\r\nWe shouldn't require fresh querying the origin HTTPS because the performance cost will be unacceptable to many clients.  And anything involving caching ECH state of previous connections or looking at what's going on in parallel connections from the same client would involve a lot of finicky details where the right thing to do really depends on what the client wants to do and details of how the client is implemented.\r\n\r\nI think it is the right approach to ensure clients are capable of adding such enforcement if desired without mandating a specific approach, and I think the current text handles this well.\r\n\r\n(And the overall main case is that an ECH-supporting server should have ECH config on all endpoints, origin and Alt-Svc, and then it is very clearly defined that ECH-supporting clients will use ECH.  All this other discussion is just regarding what to do in the very discouraged case where the domains have a very silly configuration of only offering ECH on some endpoints.)",
              "createdAt": "2021-06-09T16:19:03Z",
              "updatedAt": "2021-06-09T16:19:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgwMjM1MDgx",
          "commit": {
            "abbreviatedOid": "4d7b96b"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-09T23:52:28Z",
          "updatedAt": "2021-06-09T23:52:29Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "This reads like \"the ech SvcParam triggers SVCB-reliant client behavior\" is a reason for not choosing alt2.  But it can't be, because alt2 has a SVCB record.\r\n\r\nIs there an error in the example?  Should alt2 not have the ech SvcParam, with the ech SvcParam on other records engaging the SVCB-reliant client behaviour?",
              "createdAt": "2021-06-09T23:52:28Z",
              "updatedAt": "2021-06-09T23:52:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgwMjY0NTI4",
          "commit": {
            "abbreviatedOid": "4d7b96b"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-10T01:14:40Z",
          "updatedAt": "2021-06-10T01:14:40Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Oh, my comment was more general: I wasn't sure what the text was trying to say in the first place. Whatever prescriptiveness we want here, the text should still convey that clearly! Intentionally trying not to be prescriptive isn't a reason to be unclear. :-)\r\n\r\nI see the new text says something slightly looser. I read this to mean \"if you have some out-of-band information that some origin supports ECH, you can go act on that\". Is that the intent here, or was this meant to capture some other scenario?",
              "createdAt": "2021-06-10T01:14:40Z",
              "updatedAt": "2021-06-10T01:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgwODY0NDI0",
          "commit": {
            "abbreviatedOid": "4d7b96b"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-10T14:32:14Z",
          "updatedAt": "2021-06-10T14:32:14Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Even when HTTPS records are present for some origin, their use is optional (SVCB-optional behavior, clients falling back to non-SVCB connection) unless an \"ech\" SvcParam is included.  Since a non-SVCB connection would not conflict with the Alt-Svc, alt2.example.com would be usable if \"ech\" were not included.",
              "createdAt": "2021-06-10T14:32:14Z",
              "updatedAt": "2021-06-10T14:32:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgwODc2Mjk0",
          "commit": {
            "abbreviatedOid": "4d7b96b"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-10T14:41:33Z",
          "updatedAt": "2021-06-10T14:41:33Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "My reading is that the ECH parameter triggers SVCB-reliant client behavior (because all endpoints for 'alt2.example' had an ech key) and thus the client cannot attempt a direct h2 connection to alt2.example.  If that is the intended meaning, perhaps a minor clarification to the text: 'the \"ech\" SvcParam triggers SVCB-reliant client behavior ({{ech-client-behavior}})' -> 'an ECH-capable client would not attempt a direct h2 connection to \"alt2.example\" because the \"ech\" SvcParam triggers SVCB-reliant client behavior ({{ech-client-behavior}})'",
              "createdAt": "2021-06-10T14:41:33Z",
              "updatedAt": "2021-06-10T14:41:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgwODc5MzYw",
          "commit": {
            "abbreviatedOid": "4d7b96b"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-10T14:43:55Z",
          "updatedAt": "2021-06-10T14:43:55Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I'm not sure what you mean by \"out of band\", but that sounds basically right.  If you know the origin is FOO, and the alt-authority is not FOO, you MAY decide not to use the Alt-Svc, for any value of FOO.  How you know that the origin is FOO is not specified here, but presumably involves retrieving the origin's HTTPS record at some point.\r\n\r\nIn my view, this instruction is normatively null, because clients can always decide not to use the Alt-Svc: RFC 7838 says \"By their nature, alternative services are OPTIONAL\".  However, several comments on this PR have asked for text on client enforcement of ECH consistency, so this text serves as a reminder that it is allowed.",
              "createdAt": "2021-06-10T14:43:55Z",
              "updatedAt": "2021-06-10T14:43:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgwODg2MTk4",
          "commit": {
            "abbreviatedOid": "202e2ed"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-10T14:49:17Z",
          "updatedAt": "2021-06-10T14:49:18Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "OK, adjusted.",
              "createdAt": "2021-06-10T14:49:18Z",
              "updatedAt": "2021-06-10T14:49:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgwODk5Mjcx",
          "commit": {
            "abbreviatedOid": "202e2ed"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-10T14:59:22Z",
          "updatedAt": "2021-06-10T14:59:22Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I wonder if maybe \"impose their own consistency conditions\" implies a specific reason/algorithm for doing this, when what we're really trying to do is clarify that clients can choose not to use any Alt-Svc names or any HTTPS endpoints within them for really whatever reason the client wants.  Would this be clearer: \"Clients MAY impose their own consistency conditions on Alt-Svc connections, e.g. ...\" -> \"Clients MAY choose to disallow connections to any HTTPS endpoints, e.g. disallow endpoints without an \"ech\" SvcParam if the client is aware that the origin's HTTPS endpoints support ECH.\"",
              "createdAt": "2021-06-10T14:59:22Z",
              "updatedAt": "2021-06-10T14:59:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgwOTUzOTE0",
          "commit": {
            "abbreviatedOid": "42cd7f7"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-10T15:44:47Z",
          "updatedAt": "2021-06-10T15:44:47Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "OK, changed to\r\n\r\n> As noted in Section 2.4 of\r\n> {{AltSvc}}, clients MAY disallow any Alt-Svc connection according to their\r\n> own criteria, e.g. disallowing Alt-Svc connections that lack ECH support\r\n> if ECH is supported on the origin.",
              "createdAt": "2021-06-10T15:44:47Z",
              "updatedAt": "2021-06-10T15:44:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxMzg4NjYz",
          "commit": {
            "abbreviatedOid": "42cd7f7"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T02:03:19Z",
          "updatedAt": "2021-06-11T02:03:19Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Oh, I completely missed the part where you connect based on the A/AAAA records.  Maybe again:\r\n\r\n> an ECH-capable client would not attempt a direct h2 connection to \"alt2.example\" (that is, using the address listed in A/AAAA) because the \"ech\" SvcParam triggers SVCB-reliant client behavior ({{ech-client-behavior}})\r\n\r\nIf \"direct\" is a term of art, then the clarification might not be needed, but this is hardly \"direct\" by any reckoning familiar to me.",
              "createdAt": "2021-06-11T02:03:19Z",
              "updatedAt": "2021-06-11T02:03:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNDEyMjE1",
          "commit": {
            "abbreviatedOid": "76f6e77"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T03:14:40Z",
          "updatedAt": "2021-06-11T03:14:40Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "OK, changed to\r\n\r\n> An ECH-capable client would not connect to `alt2.example`,\r\n> as there is no possible connection that is consistent with both ALPN values\r\n> (\"h2\" from Alt-Svc, \"h3\" from SvcParams), and the \"ech\" SvcParam prevents\r\n> the client from falling back to a plain A/AAAA-based connection (i.e. the\r\n> client is SVCB-reliant, {{ech-client-behavior}}).\r\n\r\nPlease review.",
              "createdAt": "2021-06-11T03:14:40Z",
              "updatedAt": "2021-06-11T03:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNDE1NjI0",
          "commit": {
            "abbreviatedOid": "42cd7f7"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T03:25:49Z",
          "updatedAt": "2021-06-11T03:34:47Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Hrm, I think this still doesn't quite capture it. The sentence (\"An ECH-capable client would not connect [...]\") seems to contain two steps at once. It's also misleading because non-ECH clients can also have see Alt-Svc vs ServiceForm incompatibilities. There's a difference between using ServiceMode records vs. A/AAAA if the alt2.example fetch gives back another TargetName. How about replacing:\r\n```\r\n    alt2.example.             IN HTTPS 1 . alpn=h3 ech=...\r\n```\r\nwith:\r\n```\r\n    alt2.example.             IN HTTPS 1 alt2b.example. alpn=h3 ech=...\r\n```\r\n\r\nAnd then replace this sentence with:\r\n\r\n> The client could not connect to `alt2b.example` because there is no possible connection that is consistent with both ALPN values (\"h2\" from Alt-Svc, \"h3\" from SvcParams). A SVCB-reliant client could not use the `alt2.example` Alt-Svc entry, but an SVCB-optional client could instead connect to `alt2.example` without the use of ServiceMode records. In an ECH-capable client, the \"ech\" SvcParam triggers SVCB-reliant client behavior ({{ech-client-behavior}}).",
              "createdAt": "2021-06-11T03:31:26Z",
              "updatedAt": "2021-06-11T03:34:47Z"
            },
            {
              "originalPosition": 46,
              "body": "I think this is the least clear of the three so far. :-P How is the client supposed to know that ECH is supported on the origin, when Alt-Svc causes them not to query the origin?\r\n\r\nIt's especially problematic because the \"ech\" consistency requirement is merely a SHOULD rather than a MUST. At the end of the day, we need to define enough of what this means so that we can clearly say what is and isn't _required_ of servers to correctly deploy ECH. The combination of merely making it a SHOULD and this clairvoyant client MAY means it's quite plausible to read this to mean that servers needn't worry about consistency since the client could just repair it.",
              "createdAt": "2021-06-11T03:34:44Z",
              "updatedAt": "2021-06-11T03:35:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNDM3Mzgy",
          "commit": {
            "abbreviatedOid": "76f6e77"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T04:21:19Z",
          "updatedAt": "2021-06-11T04:21:20Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I'm fine with \"direct\" or \"plain A/AAAA\".  Either seems clear enough to me, but maybe my understanding has just been tainted by informal usage of \"direct\" for this meaning in these various discussions.  \r\n\r\nRelated note: If we don't like \"direct\" to refer to plain A/AAAA, might also want to reword Section 9.1: \r\n\r\n> The SVCB-optional client behavior specified in Section 3 permits clients to fall back to a direct connection if all SVCB options fail.",
              "createdAt": "2021-06-11T04:21:19Z",
              "updatedAt": "2021-06-11T04:21:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNDQ3NjQy",
          "commit": {
            "abbreviatedOid": "76f6e77"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T04:52:35Z",
          "updatedAt": "2021-06-11T04:52:36Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "> I think this is the least clear of the three so far. :-P How is the client supposed to know that ECH is supported on the origin, when Alt-Svc causes them not to query the origin?\r\n\r\nI would do it either by adding more data to the Alt-Svc info cache to specify that the original connection (that provided the Alt-Svc header) used ECH, or I'd query the QUIC connection pool for a still-active connection to the origin and leave info there about whether or not ECH was used.  But I imagine this would all be very dependent on the client-specifics of how Alt-Svc info is stored and how other connections are kept track of, so I don't know if there's a reasonable way to get any more specific in the draft.  Overall, I assume any client that wanted to do something like this could find a way.\r\n\r\n> It's especially problematic because the \"ech\" consistency requirement is merely a SHOULD rather than a MUST. At the end of the day, we need to define enough of what this means so that we can clearly say what is and isn't required of servers to correctly deploy ECH. The combination of merely making it a SHOULD and this clairvoyant client MAY means it's quite plausible to read this to mean that servers needn't worry about consistency since the client could just repair it.\r\n\r\nThe server requirements are only a SHOULD because servers are not required to support ECH and not required to have a reasonable configuration to ensure clients use ECH.\r\n\r\nBut if a server wants to do the right thing and have a good configuration, I think all the text is already pretty clear how to do that (by including \"ech=\" on all endpoints in the origin and Alt-Svc).  Section 9.2 states pretty clearly that an RRSet with mixed ECH configuration is vulnerable to downgrade attacks.  And the current draft text here says servers with ECH on the origin should also include it on Alt services or the client might make non-ECH-protected connections.\r\n\r\nI think it would be getting redundant, but do you think we need a final clarifying \"servers SHOULD NOT rely on clients doing this to avoid leaking unencrypted Client Hello\" after the \"clients MAY...\"?",
              "createdAt": "2021-06-11T04:52:35Z",
              "updatedAt": "2021-06-11T04:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNDUwMDEy",
          "commit": {
            "abbreviatedOid": "76f6e77"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T04:59:03Z",
          "updatedAt": "2021-06-11T04:59:03Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Could break up the 2 things completely, and stop trying to contain the SVCB-reliant stuff just to the alt2 example.  One sentence about how the client could not use the HTTPS info from alt2.example (or state this via the alt2b.example stuff).  Then another sentence saying something along the lines of \"For all 3 of these names, an ECH-capable client could not fall back to plain A/AAAA-based connection because the \"ech\" SvcParam triggers SVCB-reliant client behavior ({{...}}).\"",
              "createdAt": "2021-06-11T04:59:03Z",
              "updatedAt": "2021-06-11T04:59:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNDUyNDUy",
          "commit": {
            "abbreviatedOid": "76f6e77"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T05:06:21Z",
          "updatedAt": "2021-06-11T05:06:21Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Well, I guess this goes back to what this text is trying to say in the first place. Again, the problem isn't the prescriptiveness but clarity. If the intent is about adding bits to the Alt-Svc cache, or looking at live connections (which are not guaranteed to be present), that doesn't check if \"ECH is supported on the origin\" but \"if the origin was previously known to support ECH\". If that's the intent (I'm still not sure, since the text is unclear), something like that may be better.\r\n\r\nI don't think not being required to support ECH has any bearing on SHOULD/MUST. The text already only applies to \"Origins that publish an 'ech' SvcParam in their HTTPS record\". But, sure, a MUST may be impractical for other reasons. E.g. you may be mid-roll-out. I'm not saying that it should be a MUST, but that the combination of the SHOULD and the client mitigation coming immediately afterwards in the same paragraph is misleading.\r\n\r\nPerhaps simply remove it from the server paragraph, and instead integrate it into the paragraph about the client's rules?",
              "createdAt": "2021-06-11T05:06:21Z",
              "updatedAt": "2021-06-11T05:13:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNDU0NDAy",
          "commit": {
            "abbreviatedOid": "76f6e77"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T05:11:51Z",
          "updatedAt": "2021-06-11T05:11:51Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Ah yeah, good point. The A/AAAA fallback case is relevant for both incompatible Alt-Svc/SVCB and plain connection error. I think that means we should also incorporate some more text from my original suggestion. The aim was not to be prescriptive about the order and timing of connection attempts, but to translate these new notions of incompatibility and expanded Alt-Svc connection attempts into the existing notions of failure and fallback. I think we should spell out the general rule here.\r\n\r\n`alt2b.example` isn't as important, but without it, there is no difference for an ECH-incapable client between the A/AAAA version and the ServiceForm version. Introducing a TargetName makes them different, which makes it clearer that this actually makes a difference.",
              "createdAt": "2021-06-11T05:11:51Z",
              "updatedAt": "2021-06-11T05:12:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNDYwNzI1",
          "commit": {
            "abbreviatedOid": "76f6e77"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T05:28:05Z",
          "updatedAt": "2021-06-11T05:28:05Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "> if the origin was previously known to support ECH\r\n\r\nI guess that's also slightly tricky because \"previously\" encompasses some random stale fetch you did 5 months ago, even though you have more recent information. \"if the most recent fetch of the origin's HTTPS record supported ECH\", but that's really long. I suppose we could be wishy-washy and say \"a recent fetch\", but this is getting pretty vague.\r\n\r\nThough, thinking about this some more, maybe we're better off just dropping this. If the problem is a stale Alt-Svc record, the next time you visit the origin, when you learn about ECH support, you'll also get a new Alt-Svc record:\r\n\r\n>   When an Alt-Svc response header field is received from an origin, its\r\n>   value invalidates and replaces all cached alternative services for\r\n>   that origin.\r\n\r\nIf the problem is a server misconfiguration, that basically the same as this one, which we haven't suggested clients repair:\r\n\r\n> An HTTPS RRSet containing some RRs with \"ech\" and some without is vulnerable to a downgrade attack. This configuration is NOT RECOMMENDED.\r\n\r\nRemoving the text also doesn't change whether it's allowed because:\r\n\r\n> As noted in Section 2.4 of {{AltSvc}}, clients MAY disallow any Alt-Svc connection according to their own criteria\r\n\r\nWhat we're doing by calling it out is emphasizing it. That is, we actually want to suggest clients do this. But given how unwilling we are to write down what \"this\" is, and the inconsistency with the other analogous error, it's unclear to me that's actually true.\r\n\r\nFinally, on SHOULD vs. MUST, I'll note that we already have other text where we have MUST-level requirements to capture things that, if you fail to do, your deployment won't work as expected.\r\n\r\n> When publishing a record containing an \"ech\" parameter, the publisher MUST ensure that all IP addresses of TargetName correspond to servers that have access to the corresponding private key or are authoritative for the public name.",
              "createdAt": "2021-06-11T05:28:05Z",
              "updatedAt": "2021-06-11T05:30:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxOTMwNjUy",
          "commit": {
            "abbreviatedOid": "52a61f6"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T15:02:31Z",
          "updatedAt": "2021-06-11T15:02:31Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "I added the `alt2b.example` TargetName and restructured this section as an enumeration instead of prose.  Please review.",
              "createdAt": "2021-06-11T15:02:31Z",
              "updatedAt": "2021-06-11T15:02:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxOTM1NDUy",
          "commit": {
            "abbreviatedOid": "52a61f6"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T15:06:13Z",
          "updatedAt": "2021-06-11T15:06:13Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I broke this sentence into its own paragraph and changed the example to\r\n\r\n> e.g. disallowing Alt-Svc connections that lack ECH support when there is an active ECH-protected connection for this origin.\r\n\r\nThat's a specific example of an allowed, plausible behavior, and I don't think it will give any server operator the impression that they can safely skip ECH on their alt-authority.",
              "createdAt": "2021-06-11T15:06:13Z",
              "updatedAt": "2021-06-11T15:06:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxOTM1OTgw",
          "commit": {
            "abbreviatedOid": "52a61f6"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T15:06:46Z",
          "updatedAt": "2021-06-11T15:06:46Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I've restructured this section to avoid the need for this terminology.  Please review.",
              "createdAt": "2021-06-11T15:06:46Z",
              "updatedAt": "2021-06-11T15:06:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxOTU1NDQ4",
          "commit": {
            "abbreviatedOid": "52a61f6"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T15:26:14Z",
          "updatedAt": "2021-06-11T15:26:14Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Is there a way to make this more clear that the consistency constraint\r\nis between a selected Alt-Svc record and the selected HTTPS RR \r\ncorresponding to the alt-authority?  The word \"any\" in \r\n\"any received HTTPS SvcParams\" makes this feel a little more \r\nambiguous.   Maybe removing \"any\" would help?",
              "createdAt": "2021-06-11T15:26:14Z",
              "updatedAt": "2021-06-11T15:26:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxOTU2MjYz",
          "commit": {
            "abbreviatedOid": "52a61f6"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T15:26:59Z",
          "updatedAt": "2021-06-11T15:27:00Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nand any received HTTPS SvcParams.  If present, the HTTPS record's TargetName\r\n```",
              "createdAt": "2021-06-11T15:27:00Z",
              "updatedAt": "2021-06-11T15:27:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxOTYzNzY5",
          "commit": {
            "abbreviatedOid": "52a61f6"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T15:34:37Z",
          "updatedAt": "2021-06-11T15:34:38Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "@enygren Do you prefer this version?  I think it's slightly over-specified, but at SHOULD strength maybe that's OK.\r\n\r\n```suggestion\r\nperform standard HTTPS-record-aware connection establishment to the Alt-Svc\r\nalt-authority ({{client-behavior}}), excluding any connection attempts that are not\r\nconsistent with the ALPN and parameters of the Alt-Svc field value.  If present,\r\nthe HTTPS record's TargetName\r\n```",
              "createdAt": "2021-06-11T15:34:37Z",
              "updatedAt": "2021-06-11T15:42:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxOTY0MjUy",
          "commit": {
            "abbreviatedOid": "2a43c54"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T15:35:06Z",
          "updatedAt": "2021-06-11T15:35:06Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Should we point out that there may be areas of transition where there may be inconsistencies?  For example, when origins are adding ECH?  (Due to the lack of an SVCB-Used or equivalent, the server returning the Alt-Svc has no way to know which version of an HTTPS RR was returned.  As such, there is may be mismatch during transitions.  This is probably OK, but clients MUST NOT break when there is a mismatch.",
              "createdAt": "2021-06-11T15:35:06Z",
              "updatedAt": "2021-06-11T15:35:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxOTY3NzAy",
          "commit": {
            "abbreviatedOid": "2a43c54"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T15:38:50Z",
          "updatedAt": "2021-06-11T15:38:50Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Perhaps append to \"consistent with the Alt-Svc ALPN and parameters\" :\r\n\" for the selected Alt-Svc record\"\r\n?",
              "createdAt": "2021-06-11T15:38:50Z",
              "updatedAt": "2021-06-11T15:38:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxOTY4Njg1",
          "commit": {
            "abbreviatedOid": "2a43c54"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T15:39:53Z",
          "updatedAt": "2021-06-11T15:39:53Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Clients would have to go out of their way to create brokenness here, so I don't think we need this warning.",
              "createdAt": "2021-06-11T15:39:53Z",
              "updatedAt": "2021-06-11T15:39:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxOTcxMTY4",
          "commit": {
            "abbreviatedOid": "2a43c54"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T15:42:28Z",
          "updatedAt": "2021-06-11T15:42:28Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "OK, updated.",
              "createdAt": "2021-06-11T15:42:28Z",
              "updatedAt": "2021-06-11T15:42:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMDA3MTY3",
          "commit": {
            "abbreviatedOid": "2a43c54"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T16:08:41Z",
          "updatedAt": "2021-06-11T16:08:41Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "As long as we're just talking about Alt-Svc, I think it's acceptable for a client to completely \"break\" and disallow the entire Alt-Svc for whatever reason the client chooses.  Just the nature of Alt-Svc as an optional mechanism.",
              "createdAt": "2021-06-11T16:08:41Z",
              "updatedAt": "2021-06-11T16:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMDEzODE4",
          "commit": {
            "abbreviatedOid": "2a43c54"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T16:16:43Z",
          "updatedAt": "2021-06-11T16:16:44Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Ignoring the Alt-Svc entirely in this case is fine, as long as the client falls back to the standard origin.  I guess that is clear in Alt-Svc so we don't need to spell it out here.",
              "createdAt": "2021-06-11T16:16:43Z",
              "updatedAt": "2021-06-11T16:16:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMDE3NTk4",
          "commit": {
            "abbreviatedOid": "2a43c54"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T16:21:13Z",
          "updatedAt": "2021-06-11T16:21:13Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "\"HTTPS over TLS\" -> \"HTTP/2 over TLS\"?\r\n\r\nAlso, I don't understand what \"(Alt-Svc and HTTPS record)\" means here.  Is it \"(Consistent with both Alt-Svc and HTTPS record)\"? Otherwise, I start wondering if this is trying to say something around SVCB vs direct connection.",
              "createdAt": "2021-06-11T16:21:13Z",
              "updatedAt": "2021-06-11T17:17:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMDI4Njk5",
          "commit": {
            "abbreviatedOid": "2b84c5d"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T16:35:13Z",
          "updatedAt": "2021-06-11T16:35:13Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "It says \"HTTPS over TLS\" because this is about what connections the client may attempt, not about what ALPN the server will choose on that connection.\r\n\r\n> Is it \"(Consistent with both Alt-Svc and HTTPS record)\"?\r\n\r\nYes.  I've changed the text to that phrasing.",
              "createdAt": "2021-06-11T16:35:13Z",
              "updatedAt": "2021-06-11T16:35:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMDQzNTIz",
          "commit": {
            "abbreviatedOid": "2b84c5d"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T16:50:42Z",
          "updatedAt": "2021-06-11T16:50:43Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "> It says \"HTTPS over TLS\" because this is about what connections the client may attempt, not about what ALPN the server will choose on that connection.\r\n\r\nGood point, but in that case, shouldn't it be \"TLS over TCP\"? I believe that would be the more accurate description of the connection itself and is more consistent with the couple other places in the draft that refer to the connection type.",
              "createdAt": "2021-06-11T16:50:42Z",
              "updatedAt": "2021-06-11T16:50:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMDQ0ODY4",
          "commit": {
            "abbreviatedOid": "2b84c5d"
          },
          "author": "ericorth",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T16:52:25Z",
          "updatedAt": "2021-06-11T16:52:25Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "(Or maybe \"HTTPS over TCP\"?)",
              "createdAt": "2021-06-11T16:52:25Z",
              "updatedAt": "2021-06-11T16:52:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMDQ5Mzc0",
          "commit": {
            "abbreviatedOid": "6b63aba"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T16:58:24Z",
          "updatedAt": "2021-06-11T16:58:25Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "OK, changed to \"HTTPS over TCP\".",
              "createdAt": "2021-06-11T16:58:24Z",
              "updatedAt": "2021-06-11T16:58:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMzUzMjI2",
          "commit": {
            "abbreviatedOid": "6b63aba"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM.\r\n\r\nThe \"disallowing Alt-Svc connections that lack ECH support when there is an active ECH-protected connection for this origin\" example seems like something that'll rare never fire, but whatever. I've probably quibbled here enough. :-) (If h2 or h3, why make a new connection when you've already got one? Seems the new connection cases are much more likely to be when you don't have a connection already open, but potentially some cached Alt-Svc values in play.)",
          "createdAt": "2021-06-12T20:43:23Z",
          "updatedAt": "2021-06-12T20:43:23Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMzUzMjU4",
          "commit": {
            "abbreviatedOid": "6b63aba"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-12T20:44:25Z",
          "updatedAt": "2021-06-12T20:44:25Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Minor nitpick, in the spirit of https://github.com/MikeBishop/dns-alt-svc/pull/331, this can be written `{{Section 2.4 of AltSvc}}` and the section will be linkified. It's *amazing*.",
              "createdAt": "2021-06-12T20:44:25Z",
              "updatedAt": "2021-06-12T20:44:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyOTY5MzUx",
          "commit": {
            "abbreviatedOid": "d0caa54"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T14:17:22Z",
          "updatedAt": "2021-06-14T14:17:23Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Done.  Note to other contributors: this required me to update to the latest kramdown-rfc2629 (`sudo gem install kramdown-rfc2629`).",
              "createdAt": "2021-06-14T14:17:22Z",
              "updatedAt": "2021-06-14T14:17:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 331,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY4OTI0MjU0",
      "title": "Link to sections in references.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/331",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This works nowadays. It's amazing.",
      "createdAt": "2021-06-12T18:00:40Z",
      "updatedAt": "2021-06-14T14:16:17Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "c0180953c4d00526fbaeadc97cc9736f5a584255",
      "headRepository": "davidben/dns-alt-svc",
      "headRefName": "cite-sections",
      "headRefOid": "3a0b495605690d7c27bcd768c529a882ac7162ce",
      "closedAt": "2021-06-14T14:16:17Z",
      "mergedAt": "2021-06-14T14:16:17Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "17d5d049a6ddd0135011f91203355733c4b40b0e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyOTY3OTgw",
          "commit": {
            "abbreviatedOid": "3a0b495"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-14T14:16:11Z",
          "updatedAt": "2021-06-14T14:16:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 332,
      "id": "MDExOlB1bGxSZXF1ZXN0NjcwNzY1ODk5",
      "title": "Changelog for -06",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/332",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-15T21:33:23Z",
      "updatedAt": "2021-06-16T14:07:44Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "457ff5fca1ee813c0fbebc5776c2b263409d6d51",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-changelog",
      "headRefOid": "3c617132f1fd9a16026adb8faab539500e5372d8",
      "closedAt": "2021-06-16T13:50:07Z",
      "mergedAt": "2021-06-16T13:50:07Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "69c6891154b5c374a76dd857a5f04bd7784f0c4b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0NTkyMzY1",
          "commit": {
            "abbreviatedOid": "971a461"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Otherwise seems fine.",
          "createdAt": "2021-06-15T23:18:40Z",
          "updatedAt": "2021-06-15T23:19:08Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n    * Remove requirement for comma-escaping related to unusual ALPN values\r\n```",
              "createdAt": "2021-06-15T23:18:41Z",
              "updatedAt": "2021-06-15T23:19:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg1MjE5MTI0",
          "commit": {
            "abbreviatedOid": "3c61713"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2021-06-16T14:07:44Z",
          "updatedAt": "2021-06-16T14:07:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 333,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk5OTIwMzQ4",
      "title": "Make Warren less grumpy",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/333",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Edits proposed in Warren Kumari's AD review.  See mail to dnsop on Jul 27, 2021, 12:35 PM.\r\nRequested sentence split is one option but there could be other ways to do this.",
      "createdAt": "2021-07-30T00:29:44Z",
      "updatedAt": "2021-08-05T14:44:56Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "69c6891154b5c374a76dd857a5f04bd7784f0c4b",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-warren-ad-review",
      "headRefOid": "f4d5bb8e490a4082515600ee9413ef675c19a798",
      "closedAt": "2021-08-05T14:44:56Z",
      "mergedAt": "2021-08-05T14:44:56Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "39873d5b67b74c53185da3350115d850b6d9108a"
      },
      "comments": [
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What is the ETA on merging and pushing out an updated draft?  \r\nAsking for a friend",
          "createdAt": "2021-08-04T15:51:52Z",
          "updatedAt": "2021-08-04T15:51:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5MTY1Mzc1",
          "commit": {
            "abbreviatedOid": "aa26f0d"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-30T14:56:35Z",
          "updatedAt": "2021-07-30T14:56:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzNDQ2Mzkx",
          "commit": {
            "abbreviatedOid": "aa26f0d"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-05T14:43:28Z",
          "updatedAt": "2021-08-05T14:44:34Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nclients that learn additional information can gain privacy, performance, \r\n```",
              "createdAt": "2021-08-05T14:43:28Z",
              "updatedAt": "2021-08-05T14:44:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 334,
      "id": "MDExOlB1bGxSZXF1ZXN0NzExMzQ2MjYz",
      "title": "Address review comments from Mark Nottingham",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/334",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://mailarchive.ietf.org/arch/msg/dnsop/JIJ6qJ53k8k4YnP4MH-AQ6kQqMA/",
      "createdAt": "2021-08-12T17:59:35Z",
      "updatedAt": "2021-09-08T19:17:40Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "d8beda3f4ecacbd53074af53289a243a24630f03",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-mnot-review",
      "headRefOid": "a6794076a32f318d3626a30470de5947a1b63c40",
      "closedAt": "2021-09-08T19:17:37Z",
      "mergedAt": "2021-09-08T19:17:37Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "a3499ea25455e7a2a194b6a2ff9b32b774508163"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI5Njg4MTk2",
          "commit": {
            "abbreviatedOid": "a27c45d"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-13T14:39:17Z",
          "updatedAt": "2021-08-13T14:56:43Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nThe presence of an ALPN protocol identifier in the SVCB ALPN set indicates that this\r\n```\r\n",
              "createdAt": "2021-08-13T14:39:17Z",
              "updatedAt": "2021-08-13T14:56:43Z"
            },
            {
              "originalPosition": 15,
              "body": "```suggestion\r\n\"port\") offers service with the protocol suite associated with this ALPN identifier.\r\n```\r\nIn both cases, there are no ALPN protocols, just identifiers that reference protocols.",
              "createdAt": "2021-08-13T14:40:30Z",
              "updatedAt": "2021-08-13T14:56:43Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nas QUIC-over-UDP or TLS-over-TCP).  ALPN protocol identifiers that do not uniquely\r\n```",
              "createdAt": "2021-08-13T14:41:01Z",
              "updatedAt": "2021-08-13T14:56:43Z"
            },
            {
              "originalPosition": 145,
              "body": "```suggestion\r\norigins with an \"http\" scheme governed by this host ({{!I-D.draft-ietf-httpbis-semantics,\r\nSection 4.3.2}}) have an equivalent origin with an \"https\" scheme ({{!I-D.draft-ietf-httpbis-semantics,\r\nSection 4.3.3}}), similar to HTTP Strict Transport\r\n```\r\n\r\nI think Mark's point is that we're making a statement about mapping between one set of origins and another, not individual resources or a single origin.  The origin transformation rules imported from HSTS below reflect this.",
              "createdAt": "2021-08-13T14:55:33Z",
              "updatedAt": "2021-08-13T14:56:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI5NzU0ODk1",
          "commit": {
            "abbreviatedOid": "a27c45d"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-13T15:50:42Z",
          "updatedAt": "2021-08-13T15:50:42Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "I'm sure your terminology is an improvement, but I think we need to tweak this.\r\n\r\nMy concern with this phrasing is that \"equivalent origin\" suggests that the resources on both origins should be the same, but that's not actually what we want.  Ideally, the HTTP origin will be blank except for a redirect to HTTPS.  That's the rationale for the current language about \"all useful HTTP resources\".\r\n\r\nCan you think of a way to represent this idea without implying the that origins have the same content?",
              "createdAt": "2021-08-13T15:50:42Z",
              "updatedAt": "2021-08-13T15:50:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ2NDU4NjMw",
          "commit": {
            "abbreviatedOid": "710e1bc"
          },
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-03T20:47:20Z",
          "updatedAt": "2021-09-03T20:47:20Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "\"By publishing a usable HTTPS RR, the server operator indicates that all origins with an \"http\" scheme governed by this host have HTTPS resources have an origin with the correct \"https\" scheme similar to HTTP Strict Transport\"\r\n\r\nno that sucks too.   I find \"equivalent\" an issue as well after reading it over a few trimes. ",
              "createdAt": "2021-09-03T20:47:20Z",
              "updatedAt": "2021-09-03T20:47:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ4MTIyMjc0",
          "commit": {
            "abbreviatedOid": "710e1bc"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-07T15:30:47Z",
          "updatedAt": "2021-09-07T15:30:47Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Seems like what we want is to communicate that you're going to end up with the same content either way.  That might be because the http:// endpoint serves content, or it might be because it sends you a 3XX telling you that you should have done https://.\r\n\r\nIf the issue is with the term \"equivalent,\" how about \"associated\"?  The origins are cooperating, they will get you to the same content (though the mechanism may vary), but they might not return identical responses.",
              "createdAt": "2021-09-07T15:30:47Z",
              "updatedAt": "2021-09-07T18:33:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ4MjAzNDQ2",
          "commit": {
            "abbreviatedOid": "710e1bc"
          },
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-07T16:53:22Z",
          "updatedAt": "2021-09-07T16:53:23Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "I like associated.  ",
              "createdAt": "2021-09-07T16:53:22Z",
              "updatedAt": "2021-09-07T16:53:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ4MjQ2NTA4",
          "commit": {
            "abbreviatedOid": "f626aa6"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-07T17:45:30Z",
          "updatedAt": "2021-09-07T17:45:30Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "I've tried to rewrite this, borrowing more text from the HSTS RFC and some of @MikeBishop's language.  It now reads\r\n\r\n>An HTTPS RR directs the client to communicate with this host only over a\r\n> secure transport, similar to HTTP Strict Transport Security {{HSTS}}.\r\n\r\n...\r\n\r\n> If the \"http\" origin exists and contains important resources that have no\r\n> equivalent at the \"https\" origin, the operator MUST NOT publish an HTTPS RR.",
              "createdAt": "2021-09-07T17:45:30Z",
              "updatedAt": "2021-09-07T17:45:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ4Mjg3MzI3",
          "commit": {
            "abbreviatedOid": "f626aa6"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-07T18:37:14Z",
          "updatedAt": "2021-09-07T18:37:22Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I feel like \"important\" may be a sticking point here.  I infer what you mean, but there's no definition of \"important\" that someone could point to confirm that they are compliant with this MUST.  Is it sufficient to simply say \"contains resources\"?  The content of a 301 isn't a resource, it's merely the payload of a redirect.",
              "createdAt": "2021-09-07T18:37:14Z",
              "updatedAt": "2021-09-07T18:37:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ4MzAwNTA0",
          "commit": {
            "abbreviatedOid": "a679407"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-07T18:54:51Z",
          "updatedAt": "2021-09-07T18:54:52Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Here's another variation:\r\n\r\n>If this redirection would result in a loss of functionality (e.g. important\r\nresources that are only available on the \"http\" origin), the operator MUST\r\nNOT publish an HTTPS RR.\r\n",
              "createdAt": "2021-09-07T18:54:52Z",
              "updatedAt": "2021-09-07T18:54:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ4NDg1MjU5",
          "commit": {
            "abbreviatedOid": "a679407"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-07T22:39:07Z",
          "updatedAt": "2021-09-07T22:39:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 335,
      "id": "MDExOlB1bGxSZXF1ZXN0NzEzNzU2OTcy",
      "title": "Respond to comments from Dale Worley",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/335",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-08-16T21:26:45Z",
      "updatedAt": "2021-10-07T21:02:29Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "main",
      "baseRefOid": "be222a737c9cc808712c8f7257964ed466fdd27c",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-worley-review",
      "headRefOid": "566b987e6586a294c42708167a16d57df31261b9",
      "closedAt": "2021-10-07T21:02:26Z",
      "mergedAt": "2021-10-07T21:02:26Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "955de2c9a04975b850e139850dc7b9ac40827011"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzMxOTAzMTM2",
          "commit": {
            "abbreviatedOid": "49e3500"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-17T15:16:22Z",
          "updatedAt": "2021-08-17T15:16:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ5NTM3OTEz",
          "commit": {
            "abbreviatedOid": "22035e0"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-08T19:32:30Z",
          "updatedAt": "2021-09-08T19:32:30Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "```suggestion\r\n## Terminology\r\n```",
              "createdAt": "2021-09-08T19:32:30Z",
              "updatedAt": "2021-09-08T19:32:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ5NTQ2Mjcx",
          "commit": {
            "abbreviatedOid": "14d2317"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-08T19:42:20Z",
          "updatedAt": "2021-09-08T19:42:20Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "```suggestion\r\nAAAA, and/or A records.  (See {{svcb-compatible}} for aliasing of SVCB-compatible RR types.) \r\n The TargetName SHOULD NOT be equal\r\n```",
              "createdAt": "2021-09-08T19:42:20Z",
              "updatedAt": "2021-09-08T19:42:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ5NTU3NDUz",
          "commit": {
            "abbreviatedOid": "14d2317"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-08T19:55:41Z",
          "updatedAt": "2021-09-08T19:55:42Z",
          "comments": [
            {
              "originalPosition": 234,
              "body": "@Habbie @vcunat This text change is based on the GENART review from Dale Worley.  Does this still work for your filtering requirements?",
              "createdAt": "2021-09-08T19:55:41Z",
              "updatedAt": "2021-09-08T19:55:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ5NTYxODM4",
          "commit": {
            "abbreviatedOid": "4a4d9f2"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-08T20:00:48Z",
          "updatedAt": "2021-09-08T20:00:48Z",
          "comments": [
            {
              "originalPosition": 354,
              "body": "Maybe add \"mandatory\" here?",
              "createdAt": "2021-09-08T20:00:48Z",
              "updatedAt": "2021-09-08T20:00:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ5NTY2OTQ1",
          "commit": {
            "abbreviatedOid": "4a4d9f2"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-08T20:06:57Z",
          "updatedAt": "2021-09-08T20:06:58Z",
          "comments": [
            {
              "originalPosition": 354,
              "body": "That suggests a different type (which didn't specify \"mandatory\" here) would make \"mandatory\" an optional-to-implement param.  Which is... weird, verging on nonsensical.\r\n\r\nIn fact, I think this line is duplicative with \"automatically mandatory keys.\"  Mandatory keys aren't required to be present in every record; a record is unusable if a mandatory type is present and not understood.  If a client MUST implement a key to be compliant with an RR type definition, how is that distinct from the set of automatically mandatory keys?",
              "createdAt": "2021-09-08T20:06:57Z",
              "updatedAt": "2021-09-08T20:06:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwMDY4NzE2",
          "commit": {
            "abbreviatedOid": "14d2317"
          },
          "author": "vcunat",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-09T08:57:20Z",
          "updatedAt": "2021-09-09T08:57:21Z",
          "comments": [
            {
              "originalPosition": 234,
              "body": "Filtering?  Is there some context I've missed or forgot?  If it's filtering in sense of Response Policy Zones and similar, I don't see why consider it in this RFC.  That certainly isn't a case of \"invalid according to the SvcParam's specification\", and SERVFAIL isn't the usual filtering action (because caching).\r\n\r\nRegardless of filtering, I wonder if SERVFAIL is the best thing to do in case the wrong record would be only non-mandatory (in the additional section).",
              "createdAt": "2021-09-09T08:57:20Z",
              "updatedAt": "2021-09-09T08:57:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwNDQ0Njky",
          "commit": {
            "abbreviatedOid": "4a4d9f2"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-09T14:39:57Z",
          "updatedAt": "2021-09-09T14:39:57Z",
          "comments": [
            {
              "originalPosition": 234,
              "body": "This is in reference to [this discussion](https://mailarchive.ietf.org/arch/msg/dnsop/DZKcP6tViymFl6axketzstO10i0/) from DNSOP.  I pinged you here because you commented on PR #313, which generated this text, and we want to make sure not to regress on consensus.",
              "createdAt": "2021-09-09T14:39:57Z",
              "updatedAt": "2021-09-09T14:40:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwNTg2OTIw",
          "commit": {
            "abbreviatedOid": "14d2317"
          },
          "author": "vcunat",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-09T16:40:43Z",
          "updatedAt": "2021-09-09T16:40:43Z",
          "comments": [
            {
              "originalPosition": 234,
              "body": "Ah, thanks... I confused the \"filtering\" meaning.  I think this new text is better.\r\n\r\nSome implementations may like to check records to larger extent, some may not, but in any case extensibility needs to be kept in mind.",
              "createdAt": "2021-09-09T16:40:43Z",
              "updatedAt": "2021-09-09T16:40:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwODA2NTE1",
          "commit": {
            "abbreviatedOid": "4a4d9f2"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-09T20:44:12Z",
          "updatedAt": "2021-09-09T20:44:12Z",
          "comments": [
            {
              "originalPosition": 354,
              "body": "OK, removed.  I agree, this can be inferred from the other rows.",
              "createdAt": "2021-09-09T20:44:12Z",
              "updatedAt": "2021-09-09T20:44:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwODA2NzUw",
          "commit": {
            "abbreviatedOid": "4a4d9f2"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-09T20:44:31Z",
          "updatedAt": "2021-09-09T20:44:32Z",
          "comments": [
            {
              "originalPosition": 234,
              "body": "I've relaxed the recommendation to use SERVFAIL specifically.",
              "createdAt": "2021-09-09T20:44:31Z",
              "updatedAt": "2021-09-09T20:44:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84uFtEs",
          "commit": {
            "abbreviatedOid": "5b969fc"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "While this took awhile to review, this generally looks good and has a bunch of improvements in it.  See some minor comments above for discussion prior to Approval.\r\nThis may also take some work to merge in and we should re-validate that no HTTPS/https/HTTP things slipped in.",
          "createdAt": "2021-10-06T21:33:06Z",
          "updatedAt": "2021-10-06T22:25:48Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "It's not just for the case where the SVCB record is absent.  Some of the optimizations later on rely on this parallel behavior (eg, for cases where the TargetName is already in-cache).\r\n\r\n```suggestion\r\nbe needed for connection establishment if the SVCB record is absent, as well as to enable optimizations in {{optimizations}}.\r\n```",
              "createdAt": "2021-10-06T21:33:06Z",
              "updatedAt": "2021-10-06T22:25:48Z"
            },
            {
              "originalPosition": 132,
              "body": "Do we want to mention that the A/AAAA for the TargetName may already be in-cache with valid/unexpired entries, or is this obvious?",
              "createdAt": "2021-10-06T21:37:18Z",
              "updatedAt": "2021-10-06T22:25:48Z"
            },
            {
              "originalPosition": 258,
              "body": "What prevents a SVCB-compatible record from being in a different Class if defined as such?",
              "createdAt": "2021-10-06T22:10:36Z",
              "updatedAt": "2021-10-06T22:25:48Z"
            },
            {
              "originalPosition": 262,
              "body": "If we have a SVCB-compatible record like \"NS2\" that itself is used for recursive to authoritative logic, it's possible that this might not be identical in-terms of Recursive resolution process (or Auth server processing).  How do we allow for such in the future ?  Should those be \"unless specified otherwise\"?",
              "createdAt": "2021-10-06T22:13:30Z",
              "updatedAt": "2021-10-06T22:25:48Z"
            },
            {
              "originalPosition": 265,
              "body": "The quotes make this seem like a literal RR type.  Is there a convention for this, or would there be some better way to represent this?",
              "createdAt": "2021-10-06T22:14:38Z",
              "updatedAt": "2021-10-06T22:25:48Z"
            },
            {
              "originalPosition": 270,
              "body": "```suggestion\r\nthe HTTPS RR type ({{https}}), which avoids Attrleaf label prefixes {{?Attrleaf=RFC8552}} in order to improve\r\ncompatibility with wildcards and CNAMEs, which are widely used with HTTP.\r\n\r\n```\r\n",
              "createdAt": "2021-10-06T22:19:15Z",
              "updatedAt": "2021-10-07T20:20:12Z"
            },
            {
              "originalPosition": 291,
              "body": "Are we sure we don't want to include some of this block?  While it may be somewhat redundant, having it repeated here helps with readability, IMHO.",
              "createdAt": "2021-10-06T22:21:55Z",
              "updatedAt": "2021-10-06T22:25:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84uF2D1",
          "commit": {
            "abbreviatedOid": "5b969fc"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T22:26:23Z",
          "updatedAt": "2021-10-06T22:26:23Z",
          "comments": [
            {
              "originalPosition": 270,
              "body": "Note in particular the s/HTTPS/HTTP/.\r\nThe new line after also helps readability.",
              "createdAt": "2021-10-06T22:26:23Z",
              "updatedAt": "2021-10-06T22:26:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84uG5mN",
          "commit": {
            "abbreviatedOid": "5b969fc"
          },
          "author": "vcunat",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T07:53:36Z",
          "updatedAt": "2021-10-07T07:53:36Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "The general consensus in the last decade or so is to avoid different classes than IN, if I remember right.  DNSOP would probably be able to provide some references; I can't find them quickly.",
              "createdAt": "2021-10-07T07:53:36Z",
              "updatedAt": "2021-10-07T07:53:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84uJ4zA",
          "commit": {
            "abbreviatedOid": "5b969fc"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T20:09:26Z",
          "updatedAt": "2021-10-07T20:32:58Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "OK, how about\r\n\r\n```suggestion\r\nbe needed for connection establishment if the SVCB record is absent, in order to minimize delay\r\nin that case and enable the optimizations discussed in {{optimizations}}.\r\n```",
              "createdAt": "2021-10-07T20:09:26Z",
              "updatedAt": "2021-10-07T20:32:58Z"
            },
            {
              "originalPosition": 133,
              "body": "Responding to https://github.com/MikeBishop/dns-alt-svc/pull/335#r723694121\r\n\r\nIt's true that these queries might not be \"issued\", but I'd rather avoid discussing caches here.  Maybe we can solve this with more precise language:\r\n```suggestion\r\nfallback to lower-priority alternatives.  Clients resolve AAAA and/or A\r\nrecords for the selected TargetName, and MAY choose between them using an\r\n```",
              "createdAt": "2021-10-07T20:12:35Z",
              "updatedAt": "2021-10-07T20:32:58Z"
            },
            {
              "originalPosition": 132,
              "body": "See below",
              "createdAt": "2021-10-07T20:12:40Z",
              "updatedAt": "2021-10-07T20:32:58Z"
            },
            {
              "originalPosition": 258,
              "body": "This section is about defining the word \"SVCB-compatible\", so the question is: is a definition that allows other classes more useful, or less useful?\r\n\r\nI think it's probably less useful, because my goal is that resolvers and authorities should be able to add new SVCB-compatible RR types with a ~1 line change (just add another type number to the \"SVCB-compatible types\" list).  (And also because other classes no longer exist.)",
              "createdAt": "2021-10-07T20:15:28Z",
              "updatedAt": "2021-10-07T20:32:58Z"
            },
            {
              "originalPosition": 262,
              "body": "I think a SVCB-based type that requires some additional logic is \"partially SVCB-compatible\".  That may be a good choice in the future, but I don't think we need to define it here.",
              "createdAt": "2021-10-07T20:16:19Z",
              "updatedAt": "2021-10-07T20:32:58Z"
            },
            {
              "originalPosition": 266,
              "body": "Responding to https://github.com/MikeBishop/dns-alt-svc/pull/335#r723713663\r\n\r\nIs this clearer?\r\n```suggestion\r\nWhen following an AliasMode record ({{alias-mode}}) of RR type $T , the\r\nfollowup query to the TargetName MUST also be for type $T.\r\n```",
              "createdAt": "2021-10-07T20:18:16Z",
              "updatedAt": "2021-10-07T20:32:58Z"
            },
            {
              "originalPosition": 265,
              "body": "See below.",
              "createdAt": "2021-10-07T20:18:22Z",
              "updatedAt": "2021-10-07T20:32:58Z"
            },
            {
              "originalPosition": 291,
              "body": "OK, I've reintroduced the zone file format, to jog the reader's memory.",
              "createdAt": "2021-10-07T20:29:46Z",
              "updatedAt": "2021-10-07T20:32:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84uKBnz",
          "commit": {
            "abbreviatedOid": "eeeb335"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T20:49:37Z",
          "updatedAt": "2021-10-07T20:49:37Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nwith HTTP by avoiding the need for an Attrleaf label {{?Attrleaf=RFC8552}}\r\n```\r\n\r\nDo we also want a normative reference to HTTP here?",
              "createdAt": "2021-10-07T20:49:37Z",
              "updatedAt": "2021-10-07T20:49:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84uKCxO",
          "commit": {
            "abbreviatedOid": "eeeb335"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good.  I see a few regressions relative to the issue on HTTPS/HTTP/\"http\"/\"https\" so we may want to re-open and take another pass after merging.",
          "createdAt": "2021-10-07T20:51:48Z",
          "updatedAt": "2021-10-07T20:51:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBsWBq84uKDbQ",
          "commit": {
            "abbreviatedOid": "53830bb"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T20:55:05Z",
          "updatedAt": "2021-10-07T20:55:06Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I don't think we need a reference.",
              "createdAt": "2021-10-07T20:55:05Z",
              "updatedAt": "2021-10-07T20:55:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 336,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE1MjcwMzI4",
      "title": "Address TSVART feedback from Kyle Rose",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/336",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-08-18T17:05:33Z",
      "updatedAt": "2021-09-08T01:16:56Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "d8beda3f4ecacbd53074af53289a243a24630f03",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-krose-comments",
      "headRefOid": "85e38add6552cdc671ed3436fe724a4cfe8a2b3c",
      "closedAt": "2021-09-08T01:16:53Z",
      "mergedAt": "2021-09-08T01:16:53Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "e4d3c52888f0d3940c011c2992f3a95c7c8b9218"
      },
      "comments": [
        {
          "author": "moonshiner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not Erik or Mike, but I these changes look good. (I did not confirm they addressed all of Kyle's feedback) ",
          "createdAt": "2021-09-03T19:14:50Z",
          "updatedAt": "2021-09-03T19:14:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ4MTEzMzMw",
          "commit": {
            "abbreviatedOid": "3bfb10b"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-07T15:22:54Z",
          "updatedAt": "2021-09-07T15:22:54Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ4NDc1MTM0",
          "commit": {
            "abbreviatedOid": "3bfb10b"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-07T22:19:55Z",
          "updatedAt": "2021-09-07T22:26:44Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nArbitrary keys can be represented using the unknown-key presentation format\r\n```",
              "createdAt": "2021-09-07T22:19:55Z",
              "updatedAt": "2021-09-07T22:26:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 337,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE1Mzc1Mjc0",
      "title": "Fix IANA instructions",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/337",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-08-18T19:56:29Z",
      "updatedAt": "2021-09-08T19:27:49Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "d8beda3f4ecacbd53074af53289a243a24630f03",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-iana",
      "headRefOid": "066b31474be868f74e13291e8d5541e37cc54fec",
      "closedAt": "2021-09-08T19:27:46Z",
      "mergedAt": "2021-09-08T19:27:46Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "e6d2b3a33dd19c5f99023f8377716a97332269b2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzMzMzIwMjUy",
          "commit": {
            "abbreviatedOid": "066b314"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-18T20:26:48Z",
          "updatedAt": "2021-08-18T20:27:21Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "[DNS Parameters](https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml) doesn't list any sub-pages, just registries.  You pointed out that there is a sub-page of this collection (SSHFP), but it contains multiple registries.  (It's also kind of odd to me, since those registries are listed under DNS Parameters in the master list but aren't on the DNS Parameters page.)  Requesting a new page, which suggests a collection of registries, under an existing collection of registries feels odd, even if there's precedent.  Especially if we have a single registry to put there.\r\n\r\nUnless we anticipate adding more SVCB registries to this collection in the future, I would think this is a new registry under the DNS Parameters category.",
              "createdAt": "2021-08-18T20:26:48Z",
              "updatedAt": "2021-08-18T20:28:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzMzMzQwNjc3",
          "commit": {
            "abbreviatedOid": "066b314"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-18T20:52:36Z",
          "updatedAt": "2021-08-18T20:52:36Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "RR-type-specific registries that are on the main page:\r\n* [AFSDB RR Subtype](https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-8)\r\n* [CSYNC Flags](https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#csync-flags)\r\n* [DHCID RR Identifier Type Codes](https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-9)\r\n* [DHCID RR Digest Type Codes](https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dhcid-rr-digest-type-codes)\r\n* [ZONEMD Schemes](https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#zonemd-schemes)\r\n* [ZONEMD Hash Algorithms](https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#zonemd-hash-algorithms)\r\n\r\nRR-type-specific registries that are on a different page within the category:\r\n* [AMTRELAY Resource Record Parameters](https://www.iana.org/assignments/amtrelay-resource-record/amtrelay-resource-record.xhtml#relay-type-field)\r\n* [DNS KEY Resource Record Protocol Octet Values](https://www.iana.org/assignments/dns-key-rr/dns-key-rr.xhtml#dns-key-rr-1)\r\n* [DNSKEY FLAGS](https://www.iana.org/assignments/dnskey-flags/dnskey-flags.xhtml#dnskey-flags-1)\r\n  - Separate page from the \"Octet Values\"!\r\n* [DNS SSHFP Resource Record Parameters](https://www.iana.org/assignments/dns-sshfp-rr-parameters/dns-sshfp-rr-parameters.xhtml#dns-sshfp-rr-parameters-2)\r\n  - Two registries on this page; the others only have one.\r\n\r\nRR-type-specific registries that get their own category:\r\n* [CERT RR Certificate Types](https://www.iana.org/assignments/cert-rr-types/cert-rr-types.xhtml)\r\n* [DANE stuff](https://www.iana.org/assignments/dane-parameters/dane-parameters.xhtml#certificate-usages)\r\n  - 3 registries about TLSA\r\n* [Secret Key Transaction Authentication for DNS (TSIG) Algorithm Names](https://www.iana.org/assignments/tsig-algorithm-names/tsig-algorithm-names.xhtml#tsig-algorithm-names-1)\r\n\r\nIf there is an organizing principle here, it is highly mysterious, but if it were up to me, I would put registries for \"DNS internal\" types (e.g. DNSKEY, ZONEMD, CSYNC, TSIG) on the main page, and all the others (AFSDB, DHCID, DANE, AMTRELAY, SSHFP, CERT, SVCB) on separate pages within the category.\r\n\r\nAs a practical matter, adding a First-Come-First-Served registry to the (already enormous) main page of DNS parameters seems less than ideal.",
              "createdAt": "2021-08-18T20:52:36Z",
              "updatedAt": "2021-08-18T20:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0MTMzMjU4",
          "commit": {
            "abbreviatedOid": "066b314"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-19T15:05:51Z",
          "updatedAt": "2021-08-19T15:05:51Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Fair enough -- I didn't realize there were so many.  It's a pity there isn't really a multi-tier option to make these more explorable.",
              "createdAt": "2021-08-19T15:05:51Z",
              "updatedAt": "2021-08-19T15:05:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ4NDc5NDIx",
          "commit": {
            "abbreviatedOid": "066b314"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-07T22:28:51Z",
          "updatedAt": "2021-09-07T22:28:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 339,
      "id": "MDExOlB1bGxSZXF1ZXN0NzI4ODkyMzgw",
      "title": "s/SvcDomainName/TargetName/",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/339",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #338",
      "createdAt": "2021-09-07T19:30:26Z",
      "updatedAt": "2021-09-08T01:08:45Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "master",
      "baseRefOid": "d8beda3f4ecacbd53074af53289a243a24630f03",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-remove-svc",
      "headRefOid": "8545b3a675bfae4620a1d8bf49d2e6d51a4ac021",
      "closedAt": "2021-09-08T01:08:45Z",
      "mergedAt": "2021-09-08T01:08:45Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "b705bee80ea44ff4011fa189cce49a075010968b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ4NDczNzg2",
          "commit": {
            "abbreviatedOid": "8545b3a"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-07T22:17:11Z",
          "updatedAt": "2021-09-07T22:17:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 341,
      "id": "PR_kwDOBsWBq84ry7Aw",
      "title": "Adjust use of HTTPS vs. \"https\", etc.",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/341",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #340",
      "createdAt": "2021-09-15T17:21:47Z",
      "updatedAt": "2021-10-07T20:03:01Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "main",
      "baseRefOid": "0583a840c7b0b0bf88c4c2ee121e9fb50dd8022a",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-https",
      "headRefOid": "b7e350f32ed8b047d4382dda2125b246d5a69f53",
      "closedAt": "2021-10-07T20:02:54Z",
      "mergedAt": "2021-10-07T20:02:54Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "be222a737c9cc808712c8f7257964ed466fdd27c"
      },
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "We may want @royfielding or @mnot to give this a once-over as well.",
          "createdAt": "2021-09-27T20:14:25Z",
          "updatedAt": "2021-09-27T20:14:25Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBsWBq84tlESe",
          "commit": {
            "abbreviatedOid": "e56ca98"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-27T19:58:10Z",
          "updatedAt": "2021-09-27T20:13:52Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "```suggestion\r\n# Service Bindings for HTTP {#https}\r\n```",
              "createdAt": "2021-09-27T19:58:11Z",
              "updatedAt": "2021-09-27T20:13:52Z"
            },
            {
              "originalPosition": 174,
              "body": "```suggestion\r\nSHOULD behave as if it has received an HTTP 307 (Temporary Redirect) status code\r\nwith this \"https\" URL in the \"Location\" field.  (Receipt of an incompatible ServiceMode RR does not\r\n```",
              "createdAt": "2021-09-27T20:01:52Z",
              "updatedAt": "2021-09-27T20:13:52Z"
            },
            {
              "originalPosition": 182,
              "body": "```suggestion\r\nWhen an HTTP connection fails due to an error in the underlying secure\r\n```",
              "createdAt": "2021-09-27T20:02:18Z",
              "updatedAt": "2021-09-27T20:13:52Z"
            },
            {
              "originalPosition": 248,
              "body": "```suggestion\r\n* Meaning: Service Binding for HTTP\r\n```",
              "createdAt": "2021-09-27T20:03:41Z",
              "updatedAt": "2021-09-27T20:13:52Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nto network services, such as for HTTP origins.  SVCB records\r\n```",
              "createdAt": "2021-09-27T20:04:47Z",
              "updatedAt": "2021-09-27T20:13:52Z"
            },
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nThe HTTPS RR is a variation of SVCB for use with HTTP {{!HTTP=I-D.ietf-httpbis-semantics}}.\r\n```",
              "createdAt": "2021-09-27T20:07:32Z",
              "updatedAt": "2021-09-27T20:13:52Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nassociated with a URI with an \"https\" or \"http\" scheme, they currently resolve only A and/or AAAA\r\n```",
              "createdAt": "2021-09-27T20:08:16Z",
              "updatedAt": "2021-09-27T20:13:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84tlKwF",
          "commit": {
            "abbreviatedOid": "e56ca98"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-27T20:25:42Z",
          "updatedAt": "2021-09-27T20:33:14Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "This is an example, and the next part is specific to \"https\" origins, so I don't know if it makes sense to list both schemes here.",
              "createdAt": "2021-09-27T20:25:42Z",
              "updatedAt": "2021-09-27T20:33:14Z"
            },
            {
              "originalPosition": 117,
              "body": "My argument here is that a Service Binding mapping is specific to a scheme, not a protocol, and this section only defines a mapping for the \"https\" scheme.  Use of an \"http\" scheme with HTTPS or SVCB is actually forbidden!\r\n\r\nConversely, if you wanted to use some protocol that is not HTTP but somehow relies on the \"https\" scheme (maybe e.g. secure websockets?), this section would still apply.",
              "createdAt": "2021-09-27T20:29:50Z",
              "updatedAt": "2021-09-27T20:33:14Z"
            },
            {
              "originalPosition": 182,
              "body": "Given that HTTP connections don't generically have a secure transport, I find this version harder to understand.",
              "createdAt": "2021-09-27T20:30:25Z",
              "updatedAt": "2021-09-27T20:33:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84toD7a",
          "commit": {
            "abbreviatedOid": "effee6b"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-28T13:52:21Z",
          "updatedAt": "2021-09-28T13:52:22Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "If the connection isn't attempting to use a secure transport, it can't satisfy the \"when\" clause anyway.  But sure, we can leave this one.",
              "createdAt": "2021-09-28T13:52:21Z",
              "updatedAt": "2021-09-28T13:52:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84toEcj",
          "commit": {
            "abbreviatedOid": "effee6b"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-28T13:53:50Z",
          "updatedAt": "2021-09-28T13:53:50Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "But you still have to do the lookup with \"http\"-schemed URIs, or you won't discover the HSTS-like directive.  So this does apply to all HTTP usage, just differently.",
              "createdAt": "2021-09-28T13:53:50Z",
              "updatedAt": "2021-09-28T13:53:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84toGRa",
          "commit": {
            "abbreviatedOid": "effee6b"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-28T13:59:03Z",
          "updatedAt": "2021-09-28T13:59:03Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Here again, I don't think it is specific.  If a record exists for the hostname, you apply the behavior in 8.5 and then all of these things are applicable.  When a client makes a connection to any HTTP URI, \"http\" or \"https\", they're doing an HTTPS resolution so that \"clients that learn additional information can gain privacy, performance, and operational advantages\" including the fact that they could use TLS.",
              "createdAt": "2021-09-28T13:59:03Z",
              "updatedAt": "2021-09-28T13:59:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84toSeF",
          "commit": {
            "abbreviatedOid": "effee6b"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-28T14:31:48Z",
          "updatedAt": "2021-09-28T14:53:52Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "It does apply to \"http\", but it doesn't create a service binding for \"http\".  The implications for \"http\" usage are a special behavior of the HTTPS RR type, separate from the Service Binding functionality, which is only for \"https\".\r\n\r\nHow about \"Using Service Bindings with HTTP\", or just \"The HTTPS RR Type\"?",
              "createdAt": "2021-09-28T14:31:48Z",
              "updatedAt": "2021-09-28T14:53:52Z"
            },
            {
              "originalPosition": 20,
              "body": "The next sentence is\r\n```\r\nThis is adequate for services that use\r\nbasic HTTP/TLS (fixed port, no QUIC, no {{!ECH=I-D.ietf-tls-esni}}), but\r\nclients that learn additional information can ...\r\n```\r\nClients don't use HTTP/TLS when the URI has an \"http\" scheme, so this becomes a non sequitur ... unless we're talking about RFC 8164, which is another layer of complexity that I would prefer not to raise.\r\n\r\nThis is just supposed to be an example, so there's no need to make it comprehensive.  How about: \"For example, when accessing an \"https\" URI, clients currently resolve only ...\"?",
              "createdAt": "2021-09-28T14:50:22Z",
              "updatedAt": "2021-09-28T14:53:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84togSD",
          "commit": {
            "abbreviatedOid": "effee6b"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-28T15:12:37Z",
          "updatedAt": "2021-09-28T15:12:38Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "\"Using Service Bindings with HTTP\" sounds good.",
              "createdAt": "2021-09-28T15:12:37Z",
              "updatedAt": "2021-09-28T15:12:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84tohQc",
          "commit": {
            "abbreviatedOid": "4282500"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-28T15:15:30Z",
          "updatedAt": "2021-09-28T15:15:30Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "Done",
              "createdAt": "2021-09-28T15:15:30Z",
              "updatedAt": "2021-09-28T15:15:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84tojMD",
          "commit": {
            "abbreviatedOid": "4282500"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-28T15:21:34Z",
          "updatedAt": "2021-09-28T15:21:35Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Well, I'd contend that failure to use TLS isn't adequate and finding the HTTPS record enables you to use TLS, so that remains a true statement.  But you're arguing that that's a special property of HTTPS and irrelevant to the SVCB class as a whole, which is what this example is trying to illustrate.\r\n\r\nI still feel like this statement is true of HTTP all-up, and I don't believe the example is more illustrative by restricting it to a particular scheme.  Not dying on this hill, but I think the example is overly specific when it doesn't add anything.",
              "createdAt": "2021-09-28T15:21:34Z",
              "updatedAt": "2021-09-28T15:21:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84tojbn",
          "commit": {
            "abbreviatedOid": "74eae44"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-28T15:22:20Z",
          "updatedAt": "2021-09-28T15:22:20Z",
          "comments": [
            {
              "originalPosition": 248,
              "body": "This is another instance of the same question.  Maybe we could agree on 'Service Binding for \"https\" origins', 'Service Binding for the \"https\" URI scheme', or 'Service Binding type for use with HTTP'?",
              "createdAt": "2021-09-28T15:22:20Z",
              "updatedAt": "2021-09-28T15:22:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84tol0R",
          "commit": {
            "abbreviatedOid": "74eae44"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-28T15:29:43Z",
          "updatedAt": "2021-09-28T15:29:44Z",
          "comments": [
            {
              "originalPosition": 248,
              "body": "As before, I prefer the last option since it affects all HTTP requests.",
              "createdAt": "2021-09-28T15:29:44Z",
              "updatedAt": "2021-09-28T15:29:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84tpBpL",
          "commit": {
            "abbreviatedOid": "74eae44"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-28T17:10:39Z",
          "updatedAt": "2021-09-28T17:54:01Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "OK, how about\r\n\r\n> For example, HTTP clients currently resolve only A and/or AAAA records for the origin hostname, learning only its IP addresses.  If HTTP clients learn more information about the origin before connecting, they may be able to upgrade \"http\" URLs to \"https\", enable HTTP/3 or ECH, or switch to an operationally preferable endpoint.",
              "createdAt": "2021-09-28T17:10:40Z",
              "updatedAt": "2021-09-28T17:54:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84tpeu_",
          "commit": {
            "abbreviatedOid": "74eae44"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-28T19:00:52Z",
          "updatedAt": "2021-09-28T19:00:53Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Works for me.",
              "createdAt": "2021-09-28T19:00:53Z",
              "updatedAt": "2021-09-28T19:00:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84tph7Z",
          "commit": {
            "abbreviatedOid": "906cf0f"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-28T19:14:54Z",
          "updatedAt": "2021-09-28T19:14:54Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Done",
              "createdAt": "2021-09-28T19:14:54Z",
              "updatedAt": "2021-09-28T19:14:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84tpiQR",
          "commit": {
            "abbreviatedOid": "b2be6d2"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-28T19:16:26Z",
          "updatedAt": "2021-09-28T19:16:26Z",
          "comments": [
            {
              "originalPosition": 248,
              "body": "Done",
              "createdAt": "2021-09-28T19:16:26Z",
              "updatedAt": "2021-09-28T19:16:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84uFFZh",
          "commit": {
            "abbreviatedOid": "b2be6d2"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good other than the one comment above (which I don't feel strongly about).",
          "createdAt": "2021-10-06T18:25:22Z",
          "updatedAt": "2021-10-06T18:32:26Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "```suggestion\r\nsecure and authenticated \"https\" scheme connection.\r\n```",
              "createdAt": "2021-10-06T18:25:22Z",
              "updatedAt": "2021-10-06T18:32:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84uFP4D",
          "commit": {
            "abbreviatedOid": "b2be6d2"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T19:11:20Z",
          "updatedAt": "2021-10-06T19:11:21Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "Oops, thanks.  But ... hmm.  How about just\r\n```suggestion\r\nsecure and authenticated connection.\r\n```",
              "createdAt": "2021-10-06T19:11:21Z",
              "updatedAt": "2021-10-06T19:11:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84uFQRn",
          "commit": {
            "abbreviatedOid": "68be1a8"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-06T19:13:08Z",
          "updatedAt": "2021-10-06T19:13:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 344,
      "id": "PR_kwDOBsWBq84sST6G",
      "title": "Correct ALPN comparison",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/344",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is the more verbose of the two options I considered.  It includes\r\nmore contextual information about what a client might choose to do with\r\nHTTPS RRs.\r\n\r\nIn Alt-Svc, clients are required to consider an alternative \"failed\"\r\nwhen the chosen ALPN is not negotiated by a server.  (This is something\r\nI think we should remove, but I'll take that up in the revision.)  This\r\nis a point of comparison with HTTPS RRs that is worth highlighting.\r\n\r\nThis could just say:\r\n\r\n> Clients are not required to abort a connection attempt if a chosen\r\nALPN ID is not negotiated by the server.\r\n\r\nThe problem with that is that it doesn't really provide any information\r\non why that might be a problem.  Other text on the draft only really\r\ntalks about what to offer (which is absoltely the right thing to do).\r\nThat leaves readers with no context for the recommendation other than\r\ntext in RFC 7838.  This contextualizes it some.  It is perfectly\r\nreasonable for clients to only use HTTPS RRs for what they perceive to\r\nbe protocol upgrades, using fallback behaviour for old protocols like\r\nHTTP/1.1.\r\n\r\nCloses #343.",
      "createdAt": "2021-09-27T01:10:31Z",
      "updatedAt": "2021-10-07T21:02:58Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "main",
      "baseRefOid": "e6d2b3a33dd19c5f99023f8377716a97332269b2",
      "headRepository": "martinthomson/dns-alt-svc",
      "headRefName": "https-alpn-comparison",
      "headRefOid": "71e50708110ae72b3a640033cdacaab115bdfacd",
      "closedAt": "2021-10-07T21:02:58Z",
      "mergedAt": "2021-10-07T21:02:57Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "46c7dbea060abb374bea8511ba138b39e02c8c1e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBsWBq84tjWX2",
          "commit": {
            "abbreviatedOid": "87fe35e"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-27T13:00:13Z",
          "updatedAt": "2021-09-27T13:00:14Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nUnlike Alt-Svc Field Values, HTTPS RRs can contain multiple ALPN IDs.\r\n```\r\n\r\nIn my view, the text on ALPNs in RFC 7838 is ambiguous, and I would like to avoid attempting to clarify it in this draft.  (We can leave that for alt-svc-bis.)  I don't think \"the client is required to abort if the indicated ALPN is not selected\" is the only plausible reading of RFC 7838, and it's not the interpretation I prefer.\r\n\r\nSince we don't seem to have agreement on the actual distinction between these drafts, I think we're best off simply removing this explanatory text.",
              "createdAt": "2021-09-27T13:00:13Z",
              "updatedAt": "2021-09-27T13:00:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84uFTPq",
          "commit": {
            "abbreviatedOid": "87fe35e"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T19:27:17Z",
          "updatedAt": "2021-10-06T19:27:17Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Given that the text does say:\r\n>    If the connection to the alternative service does not negotiate the expected protocol (for example, ALPN fails to negotiate h2, or an Upgrade request to h2c is not accepted), the connection to the alternative service MUST be considered to have failed.\r\n\r\nperhaps we use some of this language?\r\n\r\n```suggestion\r\nUnlike Alt-Svc Field Values, HTTPS RRs can contain multiple ALPN IDs.  Clients are allowed to succeed and use  connections to alternatives that negotiate a protocol other than that indicated by the chosen ALPN IDs.\r\n```",
              "createdAt": "2021-10-06T19:27:17Z",
              "updatedAt": "2021-10-06T19:27:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84uFYF0",
          "commit": {
            "abbreviatedOid": "87fe35e"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T19:50:17Z",
          "updatedAt": "2021-10-06T19:50:17Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I think that language will almost certainly be removed or substantially altered in Alt-Svc-bis, so attempting to match it or clarify it here is probably not going to age well.\r\n\r\nRather than risk a conflict with RFC 7838 or our own text, I think a back-ref might be best.\r\n\r\n```suggestion\r\nUnlike Alt-Svc Field Values, HTTPS RRs can contain multiple ALPN IDs.  The\r\nmeaning and use of these IDs is discussed in {{use}}.\r\n```\r\n",
              "createdAt": "2021-10-06T19:50:17Z",
              "updatedAt": "2021-10-06T19:50:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84uFdAS",
          "commit": {
            "abbreviatedOid": "87fe35e"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T20:13:08Z",
          "updatedAt": "2021-10-06T20:13:08Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I'm fine with Ben's latest proposal.  Martin?",
              "createdAt": "2021-10-06T20:13:08Z",
              "updatedAt": "2021-10-06T20:13:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84uF5jL",
          "commit": {
            "abbreviatedOid": "87fe35e"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T22:51:23Z",
          "updatedAt": "2021-10-06T22:51:23Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Yes, I think that Ben nailed it.",
              "createdAt": "2021-10-06T22:51:23Z",
              "updatedAt": "2021-10-06T22:51:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBsWBq84uF6kn",
          "commit": {
            "abbreviatedOid": "71e5070"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-06T22:59:36Z",
          "updatedAt": "2021-10-06T22:59:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBsWBq84uJE0j",
          "commit": {
            "abbreviatedOid": "71e5070"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-07T16:18:10Z",
          "updatedAt": "2021-10-07T16:18:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 346,
      "id": "PR_kwDOBsWBq84sSaUT",
      "title": "Remove trailing whitespace",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/346",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This should fix CI failures.",
      "createdAt": "2021-09-27T02:08:58Z",
      "updatedAt": "2021-09-27T12:53:21Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "main",
      "baseRefOid": "e6d2b3a33dd19c5f99023f8377716a97332269b2",
      "headRepository": "martinthomson/dns-alt-svc",
      "headRefName": "fix-lint",
      "headRefOid": "16fb42c01a3b619337ab63bad6f030fe62f70672",
      "closedAt": "2021-09-27T12:53:20Z",
      "mergedAt": "2021-09-27T12:53:20Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "58a76606928cf7e64033c5036266a67131a5c90e"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2021-09-27T12:53:17Z",
          "updatedAt": "2021-09-27T12:53:17Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 347,
      "id": "PR_kwDOBsWBq84sUIOj",
      "title": "Mention \"mandatory\" under \"Initial SvcParamKeys\"",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/347",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #310",
      "createdAt": "2021-09-27T13:37:51Z",
      "updatedAt": "2021-10-06T19:14:25Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "main",
      "baseRefOid": "58a76606928cf7e64033c5036266a67131a5c90e",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-add-mandatory",
      "headRefOid": "1058df07277ad52727b53b9c64647157b5a39628",
      "closedAt": "2021-10-06T19:14:18Z",
      "mergedAt": "2021-10-06T19:14:18Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "727d2065e0e5ff53e4999a208b074e93d1276915"
      },
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me.  I also proposed an update to this.",
          "createdAt": "2021-10-06T18:53:17Z",
          "updatedAt": "2021-10-06T18:53:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBsWBq84uFQFd",
          "commit": {
            "abbreviatedOid": "1058df0"
          },
          "author": "enygren",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-06T19:12:17Z",
          "updatedAt": "2021-10-06T19:12:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 348,
      "id": "PR_kwDOBsWBq84sVV0d",
      "title": "Adjust H3 ref",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/348",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "I don't think we have a normative dependency on any of the HTTP mappings.  We might ought to have one on HTTP itself, but I'm raising that in my review on #341.",
      "createdAt": "2021-09-27T20:12:20Z",
      "updatedAt": "2021-09-27T20:34:17Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "main",
      "baseRefOid": "58a76606928cf7e64033c5036266a67131a5c90e",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "h3_refs",
      "headRefOid": "1f504cb0b732049bb6cae668c2534b897fd26e28",
      "closedAt": "2021-09-27T20:34:17Z",
      "mergedAt": "2021-09-27T20:34:17Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "cd2a236f1f35a624a1bf4f1be1c08c9ce2db37d3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 350,
      "id": "PR_kwDOBsWBq84s1oQN",
      "title": "mandatory to required to avoid confusion",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/350",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We also used \"mandatory\" in a way different from the SvcParam.  Proposing changing that to \"required\"",
      "createdAt": "2021-10-06T18:52:28Z",
      "updatedAt": "2021-10-06T19:11:55Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "bemasc-add-mandatory",
      "baseRefOid": "ede2bf2810eeea9e4bdad96234bc6c2c17340c3c",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "enygren-clarify-mandatory-wording",
      "headRefOid": "d95da44bde5119f2a9fb249d967de82f0b46c495",
      "closedAt": "2021-10-06T19:11:55Z",
      "mergedAt": "2021-10-06T19:11:55Z",
      "mergedBy": "enygren",
      "mergeCommit": {
        "oid": "1058df07277ad52727b53b9c64647157b5a39628"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBsWBq84uFPco",
          "commit": {
            "abbreviatedOid": "d95da44"
          },
          "author": "bemasc",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-06T19:09:17Z",
          "updatedAt": "2021-10-06T19:09:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 351,
      "id": "PR_kwDOBsWBq84s13X6",
      "title": "it appears that Attrleaf reference is normally Normative",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/351",
      "state": "MERGED",
      "author": "moonshiner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This address issue #300 ",
      "createdAt": "2021-10-06T19:27:05Z",
      "updatedAt": "2021-10-06T19:51:27Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "main",
      "baseRefOid": "727d2065e0e5ff53e4999a208b074e93d1276915",
      "headRepository": "moonshiner/dns-alt-svc",
      "headRefName": "tjw-attrleaf",
      "headRefOid": "7849a5fa90657f6933eaecc380c32ae3aa281cf1",
      "closedAt": "2021-10-06T19:51:26Z",
      "mergedAt": "2021-10-06T19:51:26Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "2a29628224f7196c13e73a81890932d01575b8b4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 352,
      "id": "PR_kwDOBsWBq84s2ObL",
      "title": "Use GitHub Actions instead of Circle",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/352",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-06T20:22:08Z",
      "updatedAt": "2021-10-06T20:22:24Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "main",
      "baseRefOid": "2a29628224f7196c13e73a81890932d01575b8b4",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "github_actions",
      "headRefOid": "c7ab046e33ab09e4bca4ef5ab9c6a71b185f3a3c",
      "closedAt": "2021-10-06T20:22:21Z",
      "mergedAt": "2021-10-06T20:22:21Z",
      "mergedBy": "MikeBishop",
      "mergeCommit": {
        "oid": "0583a840c7b0b0bf88c4c2ee121e9fb50dd8022a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 353,
      "id": "PR_kwDOBsWBq84s9gG5",
      "title": "Changelog for -08",
      "url": "https://github.com/MikeBishop/dns-alt-svc/pull/353",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-08T20:34:10Z",
      "updatedAt": "2021-10-12T19:57:19Z",
      "baseRepository": "MikeBishop/dns-alt-svc",
      "baseRefName": "main",
      "baseRefOid": "46c7dbea060abb374bea8511ba138b39e02c8c1e",
      "headRepository": "MikeBishop/dns-alt-svc",
      "headRefName": "bemasc-changelog",
      "headRefOid": "77227cd0105a58cc838b8330905e72762b447c7d",
      "closedAt": "2021-10-12T19:57:16Z",
      "mergedAt": "2021-10-12T19:57:16Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "d41f1fdb8b4cb136c24073f4480b4f611aed43fb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBsWBq84uWKmV",
          "commit": {
            "abbreviatedOid": "77227cd"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-12T15:44:39Z",
          "updatedAt": "2021-10-12T15:44:39Z",
          "comments": []
        }
      ]
    }
  ]
}